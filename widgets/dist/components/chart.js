// node_modules/chart.js/dist/chunks/helpers.segment.mjs
function noop() {
}
var uid = function() {
  let id = 0;
  return function() {
    return id++;
  };
}();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source = sources[i];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, { merger: _mergerIf });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
var keyResolvers = {
  "": (v) => v,
  x: (o) => o.x,
  y: (o) => o.y
};
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return { lo, hi };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => table[index2][key] <= value : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = /* @__PURE__ */ new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set2.add(items[i]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(
        Math.min(
          _lookupByKey(_parsed, iScale.axis, min).lo,
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
        ),
        0,
        pointCount - 1
      );
    }
    if (maxDefined) {
      count = _limitValue(
        Math.max(
          _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
        ),
        start,
        pointCount
      ) - start;
    } else {
      count = pointCount - start;
    }
  }
  return { start, count };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
function index_esm(input) {
  return new Color(input);
}
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
};
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
});
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart2, pixel, width) {
  const devicePixelRatio = chart2.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + yOffset, y - xOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "star":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      rad += QUARTER_PI;
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(
    flip ? previous.cp1x : previous.cp2x,
    flip ? previous.cp1y : previous.cp2y,
    flip ? target.cp2x : target.cp1x,
    flip ? target.cp2y : target.cp1y,
    target.x,
    target.y
  );
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = "";
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(
        target,
        prop,
        () => _resolveWithPrefixes(prop, prefixes, scopes, target)
      );
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(
        target,
        prop,
        () => _resolveWithContext(target, prop, receiver)
      );
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(
    Array.from(set2),
    [""],
    rootScopes,
    fallback,
    () => subGetTarget(resolver, prop, value)
  );
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(
        prev,
        point,
        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
        options.tension
      );
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle2 = (element) => window.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle2(el).getPropertyValue(property);
}
var positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return { x, y, box };
}
function getRelativePosition(evt, chart2) {
  if ("native" in evt) {
    return evt;
  }
  const { canvas, currentDevicePixelRatio } = chart2;
  const style = getComputedStyle2(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart2;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle2(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle2(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart2, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart2.height * pixelRatio);
  const deviceWidth = Math.floor(chart2.width * pixelRatio);
  chart2.height = deviceHeight / pixelRatio;
  chart2.width = deviceWidth / pixelRatio;
  const canvas = chart2.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart2.height}px`;
    canvas.style.width = `${chart2.width}px`;
  }
  if (chart2.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart2.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart2.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = { x: p1.cp2x, y: p1.cp2y };
  const cp2 = { x: p2.cp1x, y: p2.cp1y };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return { start, end, loop, style: segment.style };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return { start, end };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({ start: start % count, end: (end - 1) % count, loop });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({ start: start % count, end: last % count, loop });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({ start: s % count, end: e % count, loop: l, style: st });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

// node_modules/chart.js/dist/chart.mjs
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart2, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart: chart2,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart2) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart2.draw();
        this._notify(chart2, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart2, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart2) {
    const charts = this._charts;
    let anims = charts.get(chart2);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart2, anims);
    }
    return anims;
  }
  listen(chart2, event, cb) {
    this._getAnims(chart2).listeners[event].push(cb);
  }
  add(chart2, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart2).items.push(...items);
  }
  has(chart2) {
    return this._getAnims(chart2).items.length > 0;
  }
  start(chart2) {
    const anims = this._charts.get(chart2);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart2) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart2);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart2) {
    const anims = this._charts.get(chart2);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart2, anims, Date.now(), "complete");
  }
  remove(chart2) {
    return this._charts.delete(chart2);
  }
};
var animator = new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
    const from2 = resolve([cfg.from, currentValue, to2]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to2]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({ res, rej });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var numbers = ["x", "y", "borderWidth", "radius", "tension"];
var colors = ["color", "borderColor", "backgroundColor"];
defaults.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
var animationOptions = Object.keys(defaults.animation);
defaults.describe("animation", {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
});
defaults.set("animations", {
  colors: {
    type: "color",
    properties: colors
  },
  numbers: {
    type: "number",
    properties: numbers
  }
});
defaults.describe("animations", {
  _fallback: "animation"
});
defaults.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (v) => v | 0
      }
    }
  }
});
var Animations = class {
  constructor(chart2, config) {
    this._chart = chart2;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart2, filterVisible) {
  const keys = [];
  const metasets = chart2._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart: chart2, _cachedMeta: meta } = controller;
  const stacks = chart2._stacks || (chart2._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart2, axis) {
  const scales2 = chart2.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(
    parent,
    {
      active: false,
      dataset: void 0,
      datasetIndex: index2,
      index: index2,
      mode: "default",
      type: "dataset"
    }
  );
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart2) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart2, true), values: null };
var DatasetController = class {
  constructor(chart2, datasetIndex) {
    this.chart = chart2;
    this._ctx = chart2.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart2 = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart2, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart2, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart2, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart2 = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart2, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, { mode });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart2 = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart2.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart2 = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart2.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart2, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return { sharedOptions, includeOptions };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(["_removeElements", start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(["_insertElements", start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
};
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return { start, end, reverse, top, bottom };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
BarController.id = "bar";
BarController.defaults = {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
};
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, { $shared: false });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
BubbleController.id = "bubble";
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return { ratioX, ratioY, offsetX, offsetY };
}
var DoughnutController = class extends DatasetController {
  constructor(chart2, datasetIndex) {
    super(chart2, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart2 = this.chart;
    const { chartArea } = chart2;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart2 = this.chart;
    const chartArea = chart2.chartArea;
    const opts = chart2.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart2 = this.chart;
    const labels = chart2.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart2.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart2 = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart2.data.datasets.length; i < ilen; ++i) {
        if (chart2.isDatasetVisible(i)) {
          meta = chart2.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
DoughnutController.id = "doughnut";
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing"
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart2) {
          const data = chart2.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart2.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart2.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart2.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ": " + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
LineController.id = "line";
LineController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
};
LineController.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
var PolarAreaController = class extends DatasetController {
  constructor(chart2, datasetIndex) {
    super(chart2, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart2 = this.chart;
    const labels = chart2.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart2.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart2 = this.chart;
    const chartArea = chart2.chartArea;
    const opts = chart2.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart2.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart2 = this.chart;
    const opts = chart2.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart2.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
PolarAreaController.id = "polarArea";
PolarAreaController.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart2) {
          const data = chart2.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart2.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart2.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart2.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};
var PieController = class extends DoughnutController {
};
PieController.id = "pie";
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
RadarController.id = "radar";
RadarController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
var Element = class {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.active = false;
    this.options = void 0;
    this.$animations = void 0;
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
Element.defaults = {};
Element.defaultRoutes = void 0;
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = { formatters };
defaults.set("scale", {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: false,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
defaults.route("scale.ticks", "color", "", "color");
defaults.route("scale.grid", "color", "", "borderColor");
defaults.route("scale.grid", "borderColor", "", "borderColor");
defaults.route("scale.title", "color", "", "color");
defaults.describe("scale", {
  _fallback: false,
  _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
  _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
});
defaults.describe("scales", {
  _fallback: "scale"
});
defaults.describe("scale.ticks", {
  _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
  _indexable: (name) => name !== "backdropPadding"
});
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart: chart2 } = scale;
  const { chartArea, scales: scales2 } = chart2;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return { titleX, titleY, maxWidth, rotation };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return { min, max };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(
        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))
      ));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart: chart2, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart2.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart2.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart2.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart2 = this.chart;
    const options = this.options;
    const { grid, position } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart2, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndex.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart2, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color: color2,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign: tickTextAlign,
        textBaseline,
        translation: [x, y],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return { textAlign, x };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart2 = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return { top: 0, left: this.left, bottom: chart2.height, right: this.right };
    }
    if (position === "top" || position === "bottom") {
      return { top: this.top, left: 0, bottom: this.bottom, right: chart2.width };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine(
            { x: item.x1, y: item.y1 },
            { x: item.x2, y: item.y2 },
            item
          );
        }
        if (grid.drawTicks) {
          drawLine(
            { x: item.tx1, y: item.ty1 },
            { x: item.tx2, y: item.ty2 },
            {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            }
          );
        }
      }
    }
  }
  drawBorder() {
    const { chart: chart2, ctx, options: { grid } } = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart2, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart2, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart2, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart2, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = new Registry();
var ScatterController = class extends DatasetController {
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
ScatterController.id = "scatter";
ScatterController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(item) {
          return "(" + item.label + ", " + item.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PolarAreaController,
  PieController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapter = class {
  constructor(options) {
    this.options = options || {};
  }
  init(chartOptions) {
  }
  formats() {
    return abstract();
  }
  parse(value, format) {
    return abstract();
  }
  format(timestamp, format) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
};
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return { lo: start.lo, hi: end.hi };
      }
    }
  }
  return { lo: 0, hi: data.length - 1 };
}
function evaluateInteractionItems(chart2, axis, position, handler, intersect) {
  const metasets = chart2.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart2.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart2.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({ element, datasetIndex, index: index2 });
    }
  };
  evaluateInteractionItems(chart2, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart2, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
    const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({ element, datasetIndex, index: index2 });
    }
  }
  evaluateInteractionItems(chart2, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart2.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{ element, datasetIndex, index: index2 }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({ element, datasetIndex, index: index2 });
    }
  }
  evaluateInteractionItems(chart2, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart2.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart2, position, axis, useFinalPosition) : getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart2, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart2, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({ element, datasetIndex, index: index2 });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart2, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart2);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart2.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({ element, datasetIndex: meta.index, index: index2 });
        }
      });
      return elements2;
    },
    dataset(chart2, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart2);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart2.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({ element: data[i], datasetIndex, index: i });
        }
      }
      return items;
    },
    point(chart2, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart2);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart2, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart2);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart2, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart2, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart2);
      return getAxisItems(chart2, position, "x", options.intersect, useFinalPosition);
    },
    y(chart2, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart2);
      return getAxisItems(chart2, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || { size: 0, count: 1 };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = { left: 0, top: 0, right: 0, bottom: 0 };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(
      layout.width || chartArea.w,
      layout.height || chartArea.h,
      getMargins(layout.horizontal, chartArea)
    );
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults.set("layout", {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart2, item) {
    if (!chart2.boxes) {
      chart2.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart2.boxes.push(item);
  },
  removeBox(chart2, layoutItem) {
    const index2 = chart2.boxes ? chart2.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart2.boxes.splice(index2, 1);
    }
  },
  configure(chart2, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart2, width, height, minPadding) {
    if (!chart2) {
      return;
    }
    const padding = toPadding(chart2.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart2.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart2.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart2.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart2.chartArea);
      box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart2, type, listener) {
  }
  removeEventListener(chart2, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart2, type, listener) {
  chart2.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart2) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart2);
  return {
    type,
    chart: chart2,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart2, type, listener) {
  const canvas = chart2.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
function createDetachObserver(chart2, type, listener) {
  const canvas = chart2.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart2) => {
    if (chart2.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart2, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart2, resize);
}
function unlistenDevicePixelRatioChanges(chart2) {
  drpListeningCharts.delete(chart2);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart2, type, listener) {
  const canvas = chart2.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart2, resize);
  return observer;
}
function releaseObserver(chart2, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart2);
  }
}
function createProxyAndListen(chart2, type, listener) {
  const canvas = chart2.canvas;
  const proxy = throttled((event) => {
    if (chart2.ctx !== null) {
      listener(fromNativeEvent(event, chart2));
    }
  }, chart2, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ["height", "width"].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart2, type, listener) {
    this.removeEventListener(chart2, type);
    const proxies = chart2.$proxies || (chart2.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart2, type, listener);
  }
  removeEventListener(chart2, type) {
    const proxies = chart2.$proxies || (chart2.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart2, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart2, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart2, true);
      this._notify(this._init, chart2, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart2).filter(filter) : this._descriptors(chart2);
    const result = this._notify(descriptors2, chart2, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart2, "stop");
      this._notify(this._init, chart2, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart2, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart2, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart2) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart2);
    this._notifyStateChanges(chart2);
    return descriptors2;
  }
  _createDescriptors(chart2, all) {
    const config = chart2 && chart2.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart2, plugins2, options, all);
  }
  _notifyStateChanges(chart2) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart2, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart2, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return { plugins: plugins2, localIds };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart2, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart2.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart2.config, { plugin, local: localIds[id] }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [""], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y") {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || { scales: {} };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = /* @__PURE__ */ Object.create(null);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(
      datasetType,
      () => [[
        `datasets.${datasetType}`,
        ""
      ]]
    );
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(
      `${datasetType}.transition.${transition}`,
      () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]
    );
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(
      `${datasetType}-${elementType}`,
      () => [[
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]]
    );
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(
      `${type}-plugin-${id}`,
      () => [[
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]]
    );
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      { type },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
    const result = { $shared: true };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "3.9.1";
var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart2 = context.chart;
  const animationOptions2 = chart2.options.animation;
  chart2.notifyPlugins("afterRender");
  callback(animationOptions2 && animationOptions2.onComplete, [context], chart2);
}
function onAnimationProgress(context) {
  const chart2 = context.chart;
  const animationOptions2 = chart2.options.animation;
  callback(animationOptions2 && animationOptions2.onProgress, [context], chart2);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
var Chart = class {
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error(
        "Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused."
      );
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = { width, height };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", { size: newSize });
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(
        Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        })
      );
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", { mode });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(
      _dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(","))
    );
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({ datasetIndex: i }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", { mode });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = { meta, index: index2, mode, cancelable: true };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({ chart: this });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, { visible });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins("destroy");
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
var invalidatePlugins = () => each(Chart.instances, (chart2) => chart2._plugins.invalidate());
var enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const { x, y, startAngle, pixelMargin, fullCircles } = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
  const { options } = element;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.stroke();
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(["x", "y"], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
    ctx.restore();
  }
};
ArcElement.id = "arc";
ArcElement.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
};
ArcElement.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, { property, start: value, end: value });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
LineElement.id = "line";
LineElement.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
};
LineElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
};
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
PointElement.id = "point";
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return { left, top, right, bottom };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
BarElement.id = "bar";
BarElement.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
BarElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  LineElement,
  PointElement,
  BarElement
});
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs(
        (pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy)
      );
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", { value: data });
  }
}
function cleanDecimatedData(chart2) {
  chart2.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return { start, count };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart2, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart2);
      return;
    }
    const availableWidth = chart2.width;
    chart2.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart2.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([indexAxis, chart2.options.indexAxis]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart2.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart2.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart2) {
    cleanDecimatedData(chart2);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return { property, start, end };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({ x: first.x, y });
      points.push({ x: last.x, y });
    } else if (x !== null) {
      points.push({ x, y: first.y });
      points.push({ x, y: last.y });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: { tension: 0 },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [index2];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({ points, options: {} });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return { first, last, point };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || { start: 0, end: TAU };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart: chart2, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart2, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart2, index2) {
  const meta = chart2.getDatasetMeta(index2);
  const visible = meta && chart2.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, { line, target, above, below, area, scale, axis });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, { line, target, color: above, scale, property });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, { line, target, color: below, scale, property });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart2, _args, options) {
    const count = (chart2.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart2.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart2.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart: chart2,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart2, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart2.getSortedVisibleDatasetMetas();
    const area = chart2.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart2.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart2, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart2.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart2.ctx, source, chart2.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart2, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart2.ctx, source, chart2.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({ width: currentColWidth, height: currentColHeight });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({ width: currentColWidth, height: currentColHeight });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { color: fontColor, padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
};
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart2, _args, options) {
    const legend = chart2.legend = new Legend({ ctx: chart2.ctx, options, chart: chart2 });
    layouts.configure(chart2, legend, options);
    layouts.addBox(chart2, legend);
  },
  stop(chart2) {
    layouts.removeBox(chart2, chart2.legend);
    delete chart2.legend;
  },
  beforeUpdate(chart2, _args, options) {
    const legend = chart2.legend;
    layouts.configure(chart2, legend, options);
    legend.options = options;
  },
  afterUpdate(chart2) {
    const legend = chart2.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart2, args) {
    if (!args.replay) {
      chart2.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart2) {
        const datasets = chart2.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart2.legend.options;
        return chart2._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
};
function createTitle(chart2, titleOpts) {
  const title = new Title({
    ctx: chart2.ctx,
    options: titleOpts,
    chart: chart2
  });
  layouts.configure(chart2, title, titleOpts);
  layouts.addBox(chart2, title);
  chart2.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart2, _args, options) {
    createTitle(chart2, options);
  },
  stop(chart2) {
    const titleBlock = chart2.titleBlock;
    layouts.removeBox(chart2, titleBlock);
    delete chart2.titleBlock;
  },
  beforeUpdate(chart2, _args, options) {
    const title = chart2.titleBlock;
    layouts.configure(chart2, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart2, _args, options) {
    const title = new Title({
      ctx: chart2.ctx,
      options,
      chart: chart2
    });
    layouts.configure(chart2, title, options);
    layouts.addBox(chart2, title);
    map2.set(chart2, title);
  },
  stop(chart2) {
    layouts.removeBox(chart2, map2.get(chart2));
    map2.delete(chart2);
  },
  beforeUpdate(chart2, _args, options) {
    const title = map2.get(chart2);
    layouts.configure(chart2, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart2, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart2.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart: chart2,
    label,
    parsed: controller.getParsed(index2),
    raw: chart2.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return { width, height };
}
function determineYAlign(chart2, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart2.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart2, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart2.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart2, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart2;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart2, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart2, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart2, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart2, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart2) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart2.width - size.width),
    y: _limitValue(y, 0, chart2.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart2 = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart2.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, { chart: this.chart, tooltip: this, replay });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return { x1, x2, x3, y1, y2, y3 };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart2 = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart2, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart2);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart2, _args, options) {
    if (options) {
      chart2.tooltip = new Tooltip({ chart: chart2, options });
    }
  },
  beforeUpdate(chart2, _args, options) {
    if (chart2.tooltip) {
      chart2.tooltip.initialize(options);
    }
  },
  reset(chart2, _args, options) {
    if (chart2.tooltip) {
      chart2.tooltip.initialize(options);
    }
  },
  afterDraw(chart2) {
    const tooltip = chart2.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart2.notifyPlugins("beforeTooltipDraw", args) === false) {
        return;
      }
      tooltip.draw(chart2.ctx);
      chart2.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart2, args) {
    if (chart2.tooltip) {
      const useFinalPosition = args.replay;
      if (chart2.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop,
      beforeBody: noop,
      beforeLabel: noop,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop,
      afterBody: noop,
      beforeFooter: noop,
      footer: noop,
      afterFooter: noop
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({ index: index2, label: raw });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({ value });
    }
    return ticks;
  }
  getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
CategoryScale.id = "category";
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{ value: rmin }, { value: rmax }];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(
    _decimalPlaces(spacing),
    _decimalPlaces(niceMin)
  );
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({ value: min });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({ value: max });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({ value: niceMax });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
LinearScale.id = "linear";
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({ value: tickVal, major: isMajor(tickVal) });
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || exp === endExp && significand < endSignificand);
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({ value: lastTick, major: isMajor(tickVal) });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, 1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, 1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
LogarithmicScale.id = "logarithmic";
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(
    orig.l - limits.l,
    limits.r - orig.r,
    orig.t - limits.t,
    limits.b - orig.b
  );
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
    renderText(
      ctx,
      scale._pointLabels[i],
      x,
      y + plFont.lineHeight / 2,
      plFont,
      {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      }
    );
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [value, index2], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(this.getContext(index2 - 1));
          drawRadiusLine(this, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(
          -width / 2 - padding.left,
          -offset - tickFont.size / 2 - padding.top,
          width + padding.width,
          tickFont.size + padding.height
        );
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
RadialLinearScale.id = "radialLinear";
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
var INTERVALS = {
  millisecond: { common: true, size: 1, steps: 1e3 },
  second: { common: true, size: 1e3, steps: 60 },
  minute: { common: true, size: 6e4, steps: 60 },
  hour: { common: true, size: 36e5, steps: 24 },
  day: { common: true, size: 864e5, steps: 30 },
  week: { common: false, size: 6048e5, steps: 4 },
  month: { common: true, size: 2628e6, steps: 12 },
  quarter: { common: false, size: 7884e6, steps: 4 },
  year: { common: true, size: 3154e7 }
};
var UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map3[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return { min, max };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index2, ticks, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index2, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
TimeScale.id = "time";
TimeScale.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: false
    }
  }
};
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        { time: min, pos: 0 },
        { time: max, pos: 1 }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({ time: curr, pos: i / (ilen - 1) });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
TimeSeriesScale.id = "timeseries";
TimeSeriesScale.defaults = TimeScale.defaults;
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/chart.js/auto/auto.mjs
Chart.register(...registerables);
var auto_default = Chart;

// packages/widgets/resources/js/components/chart.js
function chart({ cachedData, options, type }) {
  return {
    init: function() {
      this.initChart();
      this.$wire.$on("updateChartData", ({ data }) => {
        chart = this.getChart();
        chart.data = data;
        chart.update("resize");
      });
      Alpine.effect(() => {
        Alpine.store("theme");
        this.$nextTick(() => {
          this.getChart().destroy();
          this.initChart();
        });
      });
      window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
        if (Alpine.store("theme") !== "system") {
          return;
        }
        this.$nextTick(() => {
          this.getChart().destroy();
          this.initChart();
        });
      });
    },
    initChart: function(data = null) {
      var _a, _b, _c, _d, _e, _f, _g;
      auto_default.defaults.animation.duration = 0;
      auto_default.defaults.backgroundColor = getComputedStyle(
        this.$refs.backgroundColorElement
      ).color;
      const borderColor = getComputedStyle(
        this.$refs.borderColorElement
      ).color;
      auto_default.defaults.borderColor = borderColor;
      auto_default.defaults.color = getComputedStyle(
        this.$refs.textColorElement
      ).color;
      auto_default.defaults.font.family = getComputedStyle(this.$el).fontFamily;
      auto_default.defaults.plugins.legend.labels.boxWidth = 12;
      auto_default.defaults.plugins.legend.position = "bottom";
      const gridColor = getComputedStyle(
        this.$refs.gridColorElement
      ).color;
      options ?? (options = {});
      options.borderWidth ?? (options.borderWidth = 2);
      options.pointBackgroundColor ?? (options.pointBackgroundColor = borderColor);
      options.pointHitRadius ?? (options.pointHitRadius = 4);
      options.pointRadius ?? (options.pointRadius = 2);
      options.scales ?? (options.scales = {});
      (_a = options.scales).x ?? (_a.x = {});
      (_b = options.scales.x).grid ?? (_b.grid = {});
      options.scales.x.grid.color = gridColor;
      (_c = options.scales.x.grid).display ?? (_c.display = false);
      (_d = options.scales.x.grid).drawBorder ?? (_d.drawBorder = false);
      (_e = options.scales).y ?? (_e.y = {});
      (_f = options.scales.y).grid ?? (_f.grid = {});
      options.scales.y.grid.color = gridColor;
      (_g = options.scales.y.grid).drawBorder ?? (_g.drawBorder = false);
      return new auto_default(this.$refs.canvas, {
        type,
        data: data ?? cachedData,
        options
      });
    },
    getChart: function() {
      return auto_default.getChart(this.$refs.canvas);
    }
  };
}
export {
  chart as default
};
/*! Bundled license information:

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * @kurkle/color v0.2.1
   * https://github.com/kurkle/color#readme
   * (c) 2022 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chart.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5tanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2hhcnQubWpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9hdXRvL2F1dG8ubWpzIiwgIi4uLy4uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL2NoYXJ0LmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKiFcbiAqIENoYXJ0LmpzIHYzLjkuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgdWlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkKys7XG4gIH07XG59KCkpO1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHR5cGUuc2xpY2UoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnNsaWNlKC02KSA9PT0gJ0FycmF5XScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5jb25zdCBpc051bWJlckZpbml0ZSA9ICh2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG5mdW5jdGlvbiBmaW5pdGVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59XG5jb25zdCB0b1BlcmNlbnRhZ2UgPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxuICAgIDogdmFsdWUgLyBkaW1lbnNpb247XG5jb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogZGltZW5zaW9uXG4gICAgOiArdmFsdWU7XG5mdW5jdGlvbiBjYWxsYmFjayhmbiwgYXJncywgdGhpc0FyZykge1xuICBpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVhY2gobG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG4gIGxldCBpLCBsZW4sIGtleXM7XG4gIGlmIChpc0FycmF5KGxvb3BhYmxlKSkge1xuICAgIGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobG9vcGFibGUpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcbiAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTAsIGExKSB7XG4gIGxldCBpLCBpbGVuLCB2MCwgdjE7XG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2MCA9IGEwW2ldO1xuICAgIHYxID0gYTFbaV07XG4gICAgaWYgKHYwLmRhdGFzZXRJbmRleCAhPT0gdjEuZGF0YXNldEluZGV4IHx8IHYwLmluZGV4ICE9PSB2MS5pbmRleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lJDEoc291cmNlKSB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcChjbG9uZSQxKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcbiAgICBmb3IgKDsgayA8IGtsZW47ICsraykge1xuICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUkMShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5kZXhPZihrZXkpID09PSAtMTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZSQxKHN2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbWVyZ2VyID0gb3B0aW9ucy5tZXJnZXIgfHwgX21lcmdlcjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgIGlmICghaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBtZXJnZUlmKHRhcmdldCwgc291cmNlKSB7XG4gIHJldHVybiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwge21lcmdlcjogX21lcmdlcklmfSk7XG59XG5mdW5jdGlvbiBfbWVyZ2VySWYoa2V5LCB0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2VJZih0dmFsLCBzdmFsKTtcbiAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUkMShzdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlcHJlY2F0ZWQoc2NvcGUsIHZhbHVlLCBwcmV2aW91cywgY3VycmVudCkge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcblx0XHRcdCdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xuICB9XG59XG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gICcnOiB2ID0+IHYsXG4gIHg6IG8gPT4gby54LFxuICB5OiBvID0+IG8ueVxufTtcbmZ1bmN0aW9uIHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpIHtcbiAgY29uc3QgcmVzb2x2ZXIgPSBrZXlSZXNvbHZlcnNba2V5XSB8fCAoa2V5UmVzb2x2ZXJzW2tleV0gPSBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSk7XG4gIHJldHVybiByZXNvbHZlcihvYmopO1xufVxuZnVuY3Rpb24gX2dldEtleVJlc29sdmVyKGtleSkge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuZnVuY3Rpb24gX3NwbGl0S2V5KGtleSkge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzID0gW107XG4gIGxldCB0bXAgPSAnJztcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgdG1wICs9IHBhcnQ7XG4gICAgaWYgKHRtcC5lbmRzV2l0aCgnXFxcXCcpKSB7XG4gICAgICB0bXAgPSB0bXAuc2xpY2UoMCwgLTEpICsgJy4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2godG1wKTtcbiAgICAgIHRtcCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuY29uc3QgZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IHNldHNFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xufVxuXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBUQVUgPSAyICogUEk7XG5jb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5jb25zdCBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xuY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5jb25zdCBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcbmNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBuaWNlTnVtKHJhbmdlKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cbmZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHtcbiAgICByZXN1bHQucHVzaChzcXJ0KTtcbiAgfVxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuZnVuY3Rpb24gYWxtb3N0RXF1YWxzKHgsIHksIGVwc2lsb24pIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG59XG5mdW5jdGlvbiBhbG1vc3RXaG9sZSh4LCBlcHNpbG9uKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5mdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoYXJyYXksIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5taW4gPSBNYXRoLm1pbih0YXJnZXQubWluLCB2YWx1ZSk7XG4gICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeCkge1xuICBpZiAoIWlzTnVtYmVyRmluaXRlKHgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gMTtcbiAgbGV0IHAgPSAwO1xuICB3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG4gICAgZSAqPSAxMDtcbiAgICBwKys7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuICBjb25zdCBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG4gIGNvbnN0IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmdsZSxcbiAgICBkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG4gIH07XG59XG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocHQxLCBwdDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cbmZ1bmN0aW9uIF9hbmdsZURpZmYoYSwgYikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQW5nbGUoYSkge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnQsIGVuZCwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlKSB7XG4gIHJldHVybiBfbGltaXRWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG59XG5mdW5jdGlvbiBfaXNCZXR3ZWVuKHZhbHVlLCBzdGFydCwgZW5kLCBlcHNpbG9uID0gMWUtNikge1xuICByZXR1cm4gdmFsdWUgPj0gTWF0aC5taW4oc3RhcnQsIGVuZCkgLSBlcHNpbG9uICYmIHZhbHVlIDw9IE1hdGgubWF4KHN0YXJ0LCBlbmQpICsgZXBzaWxvbjtcbn1cblxuZnVuY3Rpb24gX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGNtcCkge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkO1xuICB3aGlsZSAoaGkgLSBsbyA+IDEpIHtcbiAgICBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICBpZiAoY21wKG1pZCkpIHtcbiAgICAgIGxvID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuY29uc3QgX2xvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlLCBsYXN0KSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgbGFzdFxuICAgID8gaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPD0gdmFsdWVcbiAgICA6IGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDwgdmFsdWUpO1xuY29uc3QgX3Jsb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcbmZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHZhbHVlcy5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cbmNvbnN0IGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGlmIChhcnJheS5fY2hhcnRqcykge1xuICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuZnVuY3Rpb24gX2FycmF5VW5pcXVlKGl0ZW1zKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzZXQuYWRkKGl0ZW1zW2ldKTtcbiAgfVxuICBpZiAoc2V0LnNpemUgPT09IGlsZW4pIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZywgdXBkYXRlRm4pIHtcbiAgY29uc3QgdXBkYXRlQXJncyA9IHVwZGF0ZUZuIHx8ICgoYXJncykgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuICBsZXQgYXJncyA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24oLi4ucmVzdCkge1xuICAgIGFyZ3MgPSB1cGRhdGVBcmdzKHJlc3QpO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbmNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5jb25zdCBfdGV4dFggPSAoYWxpZ24sIGxlZnQsIHJpZ2h0LCBydGwpID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcbmZ1bmN0aW9uIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgY29uc3Qge2lTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShNYXRoLm1pbihcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtaW4pLmxvLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pLFxuICAgICAgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShNYXRoLm1heChcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtYXgsIHRydWUpLmhpICsgMSxcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCksIHRydWUpLmhpICsgMSksXG4gICAgICBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbmZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcbiAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gIHJldHVybiBjaGFuZ2VkO1xufVxuXG5jb25zdCBhdEVkZ2UgPSAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQsIHMsIHApID0+IC0oTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkpO1xuY29uc3QgZWxhc3RpY091dCA9ICh0LCBzLCBwKSA9PiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSArIDE7XG5jb25zdCBlZmZlY3RzID0ge1xuICBsaW5lYXI6IHQgPT4gdCxcbiAgZWFzZUluUXVhZDogdCA9PiB0ICogdCxcbiAgZWFzZU91dFF1YWQ6IHQgPT4gLXQgKiAodCAtIDIpLFxuICBlYXNlSW5PdXRRdWFkOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuICBlYXNlSW5DdWJpYzogdCA9PiB0ICogdCAqIHQsXG4gIGVhc2VPdXRDdWJpYzogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0Q3ViaWM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuICBlYXNlSW5RdWFydDogdCA9PiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVhcnQ6IHQgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuICBlYXNlSW5PdXRRdWFydDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG4gIGVhc2VJblF1aW50OiB0ID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVpbnQ6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0UXVpbnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcbiAgZWFzZUluU2luZTogdCA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcbiAgZWFzZU91dFNpbmU6IHQgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuICBlYXNlSW5PdXRTaW5lOiB0ID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuICBlYXNlSW5FeHBvOiB0ID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuICBlYXNlT3V0RXhwbzogdCA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcbiAgZWFzZUluT3V0RXhwbzogdCA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG4gIGVhc2VJbkNpcmM6IHQgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuICBlYXNlT3V0Q2lyYzogdCA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG4gIGVhc2VJbk91dENpcmM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG4gIGVhc2VJbkVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZU91dEVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG4gIGVhc2VJbk91dEVsYXN0aWModCkge1xuICAgIGNvbnN0IHMgPSAwLjExMjU7XG4gICAgY29uc3QgcCA9IDAuNDU7XG4gICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOlxuICAgICAgdCA8IDAuNVxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcbiAgICAgICAgOiAwLjUgKyAwLjUgKiBlbGFzdGljT3V0KHQgKiAyIC0gMSwgcywgcCk7XG4gIH0sXG4gIGVhc2VJbkJhY2sodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9LFxuICBlYXNlT3V0QmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcbiAgZWFzZUluT3V0QmFjayh0KSB7XG4gICAgbGV0IHMgPSAxLjcwMTU4O1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG4gIH0sXG4gIGVhc2VJbkJvdW5jZTogdCA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcbiAgZWFzZU91dEJvdW5jZSh0KSB7XG4gICAgY29uc3QgbSA9IDcuNTYyNTtcbiAgICBjb25zdCBkID0gMi43NTtcbiAgICBpZiAodCA8ICgxIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgKDIgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMS41IC8gZCkpICogdCArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgKDIuNSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgyLjI1IC8gZCkpICogdCArIDAuOTM3NTtcbiAgICB9XG4gICAgcmV0dXJuIG0gKiAodCAtPSAoMi42MjUgLyBkKSkgKiB0ICsgMC45ODQzNzU7XG4gIH0sXG4gIGVhc2VJbk91dEJvdW5jZTogdCA9PiAodCA8IDAuNSlcbiAgICA/IGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNVxuICAgIDogZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjUsXG59O1xuXG4vKiFcbiAqIEBrdXJrbGUvY29sb3IgdjAuMi4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20va3Vya2xlL2NvbG9yI3JlYWRtZVxuICogKGMpIDIwMjIgSnVra2EgS3Vya2VsYVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHJvdW5kKHYpIHtcbiAgcmV0dXJuIHYgKyAwLjUgfCAwO1xufVxuY29uc3QgbGltID0gKHYsIGwsIGgpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIGgpLCBsKTtcbmZ1bmN0aW9uIHAyYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5jb25zdCBtYXAkMSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LCBBOiAxMCwgQjogMTEsIEM6IDEyLCBEOiAxMywgRTogMTQsIEY6IDE1LCBhOiAxMCwgYjogMTEsIGM6IDEyLCBkOiAxMywgZTogMTQsIGY6IDE1fTtcbmNvbnN0IGhleCA9IFsuLi4nMDEyMzQ1Njc4OUFCQ0RFRiddO1xuY29uc3QgaDEgPSBiID0+IGhleFtiICYgMHhGXTtcbmNvbnN0IGgyID0gYiA9PiBoZXhbKGIgJiAweEYwKSA+PiA0XSArIGhleFtiICYgMHhGXTtcbmNvbnN0IGVxID0gYiA9PiAoKGIgJiAweEYwKSA+PiA0KSA9PT0gKGIgJiAweEYpO1xuY29uc3QgaXNTaG9ydCA9IHYgPT4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcbmZ1bmN0aW9uIGhleFBhcnNlKHN0cikge1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKGxlbiA9PT0gNCB8fCBsZW4gPT09IDUpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogMjU1ICYgbWFwJDFbc3RyWzFdXSAqIDE3LFxuICAgICAgICBnOiAyNTUgJiBtYXAkMVtzdHJbMl1dICogMTcsXG4gICAgICAgIGI6IDI1NSAmIG1hcCQxW3N0clszXV0gKiAxNyxcbiAgICAgICAgYTogbGVuID09PSA1ID8gbWFwJDFbc3RyWzRdXSAqIDE3IDogMjU1XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiBtYXAkMVtzdHJbMV1dIDw8IDQgfCBtYXAkMVtzdHJbMl1dLFxuICAgICAgICBnOiBtYXAkMVtzdHJbM11dIDw8IDQgfCBtYXAkMVtzdHJbNF1dLFxuICAgICAgICBiOiBtYXAkMVtzdHJbNV1dIDw8IDQgfCBtYXAkMVtzdHJbNl1dLFxuICAgICAgICBhOiBsZW4gPT09IDkgPyAobWFwJDFbc3RyWzddXSA8PCA0IHwgbWFwJDFbc3RyWzhdXSkgOiAyNTVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5jb25zdCBhbHBoYSA9IChhLCBmKSA9PiBhIDwgMjU1ID8gZihhKSA6ICcnO1xuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcbiAgdmFyIGYgPSBpc1Nob3J0KHYpID8gaDEgOiBoMjtcbiAgcmV0dXJuIHZcbiAgICA/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArIGFscGhhKHYuYSwgZilcbiAgICA6IHVuZGVmaW5lZDtcbn1cbmNvbnN0IEhVRV9SRSA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBoc2wycmdibihoLCBzLCBsKSB7XG4gIGNvbnN0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyAzMCkgJSAxMikgPT4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG4gIHJldHVybiBbZigwKSwgZig4KSwgZig0KV07XG59XG5mdW5jdGlvbiBoc3YycmdibihoLCBzLCB2KSB7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDYwKSAlIDYpID0+IHYgLSB2ICogcyAqIE1hdGgubWF4KE1hdGgubWluKGssIDQgLSBrLCAxKSwgMCk7XG4gIHJldHVybiBbZig1KSwgZigzKSwgZigxKV07XG59XG5mdW5jdGlvbiBod2IycmdibihoLCB3LCBiKSB7XG4gIGNvbnN0IHJnYiA9IGhzbDJyZ2JuKGgsIDEsIDAuNSk7XG4gIGxldCBpO1xuICBpZiAodyArIGIgPiAxKSB7XG4gICAgaSA9IDEgLyAodyArIGIpO1xuICAgIHcgKj0gaTtcbiAgICBiICo9IGk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJnYltpXSAqPSAxIC0gdyAtIGI7XG4gICAgcmdiW2ldICs9IHc7XG4gIH1cbiAgcmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCkge1xuICBpZiAociA9PT0gbWF4KSB7XG4gICAgcmV0dXJuICgoZyAtIGIpIC8gZCkgKyAoZyA8IGIgPyA2IDogMCk7XG4gIH1cbiAgaWYgKGcgPT09IG1heCkge1xuICAgIHJldHVybiAoYiAtIHIpIC8gZCArIDI7XG4gIH1cbiAgcmV0dXJuIChyIC0gZykgLyBkICsgNDtcbn1cbmZ1bmN0aW9uIHJnYjJoc2wodikge1xuICBjb25zdCByYW5nZSA9IDI1NTtcbiAgY29uc3QgciA9IHYuciAvIHJhbmdlO1xuICBjb25zdCBnID0gdi5nIC8gcmFuZ2U7XG4gIGNvbnN0IGIgPSB2LmIgLyByYW5nZTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICBsZXQgaCwgcywgZDtcbiAgaWYgKG1heCAhPT0gbWluKSB7XG4gICAgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgaCA9IGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCk7XG4gICAgaCA9IGggKiA2MCArIDAuNTtcbiAgfVxuICByZXR1cm4gW2ggfCAwLCBzIHx8IDAsIGxdO1xufVxuZnVuY3Rpb24gY2FsbG4oZiwgYSwgYiwgYykge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoYSlcbiAgICAgID8gZihhWzBdLCBhWzFdLCBhWzJdKVxuICAgICAgOiBmKGEsIGIsIGMpXG4gICkubWFwKG4yYik7XG59XG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcbiAgcmV0dXJuIGNhbGxuKGhzbDJyZ2JuLCBoLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2IoaCwgdywgYikge1xuICByZXR1cm4gY2FsbG4oaHdiMnJnYm4sIGgsIHcsIGIpO1xufVxuZnVuY3Rpb24gaHN2MnJnYihoLCBzLCB2KSB7XG4gIHJldHVybiBjYWxsbihoc3YycmdibiwgaCwgcywgdik7XG59XG5mdW5jdGlvbiBodWUoaCkge1xuICByZXR1cm4gKGggJSAzNjAgKyAzNjApICUgMzYwO1xufVxuZnVuY3Rpb24gaHVlUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBIVUVfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHY7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs1XSAhPT0gdikge1xuICAgIGEgPSBtWzZdID8gcDJiKCttWzVdKSA6IG4yYigrbVs1XSk7XG4gIH1cbiAgY29uc3QgaCA9IGh1ZSgrbVsyXSk7XG4gIGNvbnN0IHAxID0gK21bM10gLyAxMDA7XG4gIGNvbnN0IHAyID0gK21bNF0gLyAxMDA7XG4gIGlmIChtWzFdID09PSAnaHdiJykge1xuICAgIHYgPSBod2IycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSBpZiAobVsxXSA9PT0gJ2hzdicpIHtcbiAgICB2ID0gaHN2MnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2Uge1xuICAgIHYgPSBoc2wycmdiKGgsIHAxLCBwMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiB2WzBdLFxuICAgIGc6IHZbMV0sXG4gICAgYjogdlsyXSxcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByb3RhdGUodiwgZGVnKSB7XG4gIHZhciBoID0gcmdiMmhzbCh2KTtcbiAgaFswXSA9IGh1ZShoWzBdICsgZGVnKTtcbiAgaCA9IGhzbDJyZ2IoaCk7XG4gIHYuciA9IGhbMF07XG4gIHYuZyA9IGhbMV07XG4gIHYuYiA9IGhbMl07XG59XG5mdW5jdGlvbiBoc2xTdHJpbmcodikge1xuICBpZiAoIXYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYSA9IHJnYjJoc2wodik7XG4gIGNvbnN0IGggPSBhWzBdO1xuICBjb25zdCBzID0gbjJwKGFbMV0pO1xuICBjb25zdCBsID0gbjJwKGFbMl0pO1xuICByZXR1cm4gdi5hIDwgMjU1XG4gICAgPyBgaHNsYSgke2h9LCAke3N9JSwgJHtsfSUsICR7YjJuKHYuYSl9KWBcbiAgICA6IGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XG59XG5jb25zdCBtYXAgPSB7XG4gIHg6ICdkYXJrJyxcbiAgWjogJ2xpZ2h0JyxcbiAgWTogJ3JlJyxcbiAgWDogJ2JsdScsXG4gIFc6ICdncicsXG4gIFY6ICdtZWRpdW0nLFxuICBVOiAnc2xhdGUnLFxuICBBOiAnZWUnLFxuICBUOiAnb2wnLFxuICBTOiAnb3InLFxuICBCOiAncmEnLFxuICBDOiAnbGF0ZWcnLFxuICBEOiAnaWdodHMnLFxuICBSOiAnaW4nLFxuICBROiAndHVycXVvaXMnLFxuICBFOiAnaGknLFxuICBQOiAncm8nLFxuICBPOiAnYWwnLFxuICBOOiAnbGUnLFxuICBNOiAnZGUnLFxuICBMOiAneWVsbG8nLFxuICBGOiAnZW4nLFxuICBLOiAnY2gnLFxuICBHOiAnYXJrcycsXG4gIEg6ICdlYScsXG4gIEk6ICdpZ2h0ZycsXG4gIEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuICBPaWNlWGU6ICdmMGY4ZmYnLFxuICBhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICdmZmZmJyxcbiAgYXF1YW1hclJlOiAnN2ZmZmQ0JyxcbiAgYXp1WTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwJyxcbiAgYmxhbktlZE9tb25kOiAnZmZlYmNkJyxcbiAgWGU6ICdmZicsXG4gIFhldmlUZXQ6ICc4YTJiZTInLFxuICBiUHduOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FNdFhlOiAnNWY5ZWEwJyxcbiAgS2FydFl1c2U6ICc3ZmZmMDAnLFxuICBLb2NUYXRlOiAnZDI2OTFlJyxcbiAgY1NPOiAnZmY3ZjUwJyxcbiAgY1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuICBjU25zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICdmZmZmJyxcbiAgeFhlOiAnOGInLFxuICB4Y3lhbjogJzhiOGInLFxuICB4Z1RNblBkOiAnYjg4NjBiJyxcbiAgeFdheTogJ2E5YTlhOScsXG4gIHhnWUY6ICc2NDAwJyxcbiAgeGdZeTogJ2E5YTlhOScsXG4gIHhraGFraTogJ2JkYjc2YicsXG4gIHhtYWdGdGE6ICc4YjAwOGInLFxuICB4VGl2ZWdZRjogJzU1NmIyZicsXG4gIHhTYW5nZTogJ2ZmOGMwMCcsXG4gIHhTY0VkOiAnOTkzMmNjJyxcbiAgeFlkOiAnOGIwMDAwJyxcbiAgeHNPbW9uOiAnZTk5NjdhJyxcbiAgeHNIZ1lGOiAnOGZiYzhmJyxcbiAgeFVYZTogJzQ4M2Q4YicsXG4gIHhVV2F5OiAnMmY0ZjRmJyxcbiAgeFVnWXk6ICcyZjRmNGYnLFxuICB4UWU6ICdjZWQxJyxcbiAgeHZpVGV0OiAnOTQwMGQzJyxcbiAgZEFwcFJrOiAnZmYxNDkzJyxcbiAgZEFwc2t5WGU6ICdiZmZmJyxcbiAgZGltV2F5OiAnNjk2OTY5JyxcbiAgZGltZ1l5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyWGU6ICcxZTkwZmYnLFxuICBmaVlicmljazogJ2IyMjIyMicsXG4gIGZsU093RXRlOiAnZmZmYWYwJyxcbiAgZm9Zc3RXQW46ICcyMjhiMjInLFxuICBmdUtzaWE6ICdmZjAwZmYnLFxuICBnYVJzYlNvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3RXRlOiAnZjhmOGZmJyxcbiAgZ1RkOiAnZmZkNzAwJyxcbiAgZ1RNblBkOiAnZGFhNTIwJyxcbiAgV2F5OiAnODA4MDgwJyxcbiAgZ1lGOiAnODAwMCcsXG4gIGdZRkx3OiAnYWRmZjJmJyxcbiAgZ1l5OiAnODA4MDgwJyxcbiAgaG9uZXlNdzogJ2YwZmZmMCcsXG4gIGhvdHBSazogJ2ZmNjliNCcsXG4gIFJkaWFuWWQ6ICdjZDVjNWMnLFxuICBSZGlnbzogJzRiMDA4MicsXG4gIGl2U3k6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdkZNcjogJ2U2ZTZmYScsXG4gIGxhdkZNclhzaDogJ2ZmZjBmNScsXG4gIGxhd25nWUY6ICc3Y2ZjMDAnLFxuICBObW9uY0VmZm9uOiAnZmZmYWNkJyxcbiAgWlhlOiAnYWRkOGU2JyxcbiAgWmNTTzogJ2YwODA4MCcsXG4gIFpjeWFuOiAnZTBmZmZmJyxcbiAgWmdUTW5QZEx3OiAnZmFmYWQyJyxcbiAgWldheTogJ2QzZDNkMycsXG4gIFpnWUY6ICc5MGVlOTAnLFxuICBaZ1l5OiAnZDNkM2QzJyxcbiAgWnBSazogJ2ZmYjZjMScsXG4gIFpzT21vbjogJ2ZmYTA3YScsXG4gIFpzSGdZRjogJzIwYjJhYScsXG4gIFpza3lYZTogJzg3Y2VmYScsXG4gIFpVV2F5OiAnNzc4ODk5JyxcbiAgWlVnWXk6ICc3Nzg4OTknLFxuICBac3RBbFhlOiAnYjBjNGRlJyxcbiAgWkx3OiAnZmZmZmUwJyxcbiAgbGltZTogJ2ZmMDAnLFxuICBsaW1lZ1lGOiAnMzJjZDMyJyxcbiAgbFJGOiAnZmFmMGU2JyxcbiAgbWFnRnRhOiAnZmYwMGZmJyxcbiAgbWFQb246ICc4MDAwMDAnLFxuICBWYXF1YW1hclJlOiAnNjZjZGFhJyxcbiAgVlhlOiAnY2QnLFxuICBWU2NFZDogJ2JhNTVkMycsXG4gIFZwdXJwTjogJzkzNzBkYicsXG4gIFZzSGdZRjogJzNjYjM3MScsXG4gIFZVWGU6ICc3YjY4ZWUnLFxuICBWc3ByUmdnWUY6ICdmYTlhJyxcbiAgVlFlOiAnNDhkMWNjJyxcbiAgVnZpVGV0WWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodFhlOiAnMTkxOTcwJyxcbiAgbVJ0Y1lhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5UHNlOiAnZmZlNGUxJyxcbiAgbW9jY2FzUjogJ2ZmZTRiNScsXG4gIG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnODAnLFxuICBUZGxhY2U6ICdmZGY1ZTYnLFxuICBUaXZlOiAnODA4MDAwJyxcbiAgVGl2ZWRCYjogJzZiOGUyMycsXG4gIFNhbmdlOiAnZmZhNTAwJyxcbiAgU2FuZ2VZZDogJ2ZmNDUwMCcsXG4gIFNjRWQ6ICdkYTcwZDYnLFxuICBwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuICBwT2VnWUY6ICc5OGZiOTgnLFxuICBwT2VRZTogJ2FmZWVlZScsXG4gIHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuICBwYXBheWF3RXA6ICdmZmVmZDUnLFxuICBwSEtwdWZmOiAnZmZkYWI5JyxcbiAgcGVydTogJ2NkODUzZicsXG4gIHBSazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dNclhlOiAnYjBlMGU2JyxcbiAgcHVycE46ICc4MDAwODAnLFxuICBZYmVjY2FwdXJwTjogJzY2MzM5OScsXG4gIFlkOiAnZmYwMDAwJyxcbiAgUHN5YnJvd246ICdiYzhmOGYnLFxuICBQeU9YZTogJzQxNjllMScsXG4gIHNhZGROYlB3bjogJzhiNDUxMycsXG4gIHNPbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHliUHduOiAnZjRhNDYwJyxcbiAgc0hnWUY6ICcyZThiNTcnLFxuICBzSHNoZWxsOiAnZmZmNWVlJyxcbiAgc2lGbmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3lYZTogJzg3Y2VlYicsXG4gIFVYZTogJzZhNWFjZCcsXG4gIFVXYXk6ICc3MDgwOTAnLFxuICBVZ1l5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwclJnZ1lGOiAnZmY3ZicsXG4gIHN0QWxYZTogJzQ2ODJiNCcsXG4gIHRhbjogJ2QyYjQ4YycsXG4gIHRlTzogJzgwODAnLFxuICB0RXN0TjogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIFFlOiAnNDBlMGQwJyxcbiAgdmlUZXQ6ICdlZTgyZWUnLFxuICBKSHQ6ICdmNWRlYjMnLFxuICB3RXRlOiAnZmZmZmZmJyxcbiAgd0V0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgTHc6ICdmZmZmMDAnLFxuICBMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cbmxldCBuYW1lcztcbmZ1bmN0aW9uIG5hbWVQYXJzZShzdHIpIHtcbiAgaWYgKCFuYW1lcykge1xuICAgIG5hbWVzID0gdW5wYWNrKCk7XG4gICAgbmFtZXMudHJhbnNwYXJlbnQgPSBbMCwgMCwgMCwgMF07XG4gIH1cbiAgY29uc3QgYSA9IG5hbWVzW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIGEgJiYge1xuICAgIHI6IGFbMF0sXG4gICAgZzogYVsxXSxcbiAgICBiOiBhWzJdLFxuICAgIGE6IGEubGVuZ3RoID09PSA0ID8gYVszXSA6IDI1NVxuICB9O1xufVxuY29uc3QgUkdCX1JFID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiByZ2JQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IFJHQl9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgciwgZywgYjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzddICE9PSByKSB7XG4gICAgY29uc3QgdiA9ICttWzddO1xuICAgIGEgPSBtWzhdID8gcDJiKHYpIDogbGltKHYgKiAyNTUsIDAsIDI1NSk7XG4gIH1cbiAgciA9ICttWzFdO1xuICBnID0gK21bM107XG4gIGIgPSArbVs1XTtcbiAgciA9IDI1NSAmIChtWzJdID8gcDJiKHIpIDogbGltKHIsIDAsIDI1NSkpO1xuICBnID0gMjU1ICYgKG1bNF0gPyBwMmIoZykgOiBsaW0oZywgMCwgMjU1KSk7XG4gIGIgPSAyNTUgJiAobVs2XSA/IHAyYihiKSA6IGxpbShiLCAwLCAyNTUpKTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByZ2JTdHJpbmcodikge1xuICByZXR1cm4gdiAmJiAoXG4gICAgdi5hIDwgMjU1XG4gICAgICA/IGByZ2JhKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0sICR7YjJuKHYuYSl9KWBcbiAgICAgIDogYHJnYigke3Yucn0sICR7di5nfSwgJHt2LmJ9KWBcbiAgKTtcbn1cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cbmZ1bmN0aW9uIG1vZEhTTCh2LCBpLCByYXRpbykge1xuICBpZiAodikge1xuICAgIGxldCB0bXAgPSByZ2IyaHNsKHYpO1xuICAgIHRtcFtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRtcFtpXSArIHRtcFtpXSAqIHJhdGlvLCBpID09PSAwID8gMzYwIDogMSkpO1xuICAgIHRtcCA9IGhzbDJyZ2IodG1wKTtcbiAgICB2LnIgPSB0bXBbMF07XG4gICAgdi5nID0gdG1wWzFdO1xuICAgIHYuYiA9IHRtcFsyXTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmUodiwgcHJvdG8pIHtcbiAgcmV0dXJuIHYgPyBPYmplY3QuYXNzaWduKHByb3RvIHx8IHt9LCB2KSA6IHY7XG59XG5mdW5jdGlvbiBmcm9tT2JqZWN0KGlucHV0KSB7XG4gIHZhciB2ID0ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NX07XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuICAgICAgdiA9IHtyOiBpbnB1dFswXSwgZzogaW5wdXRbMV0sIGI6IGlucHV0WzJdLCBhOiAyNTV9O1xuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdi5hID0gbjJiKGlucHV0WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdiA9IGNsb25lKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuICAgIHYuYSA9IG4yYih2LmEpO1xuICB9XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuICAgIHJldHVybiByZ2JQYXJzZShzdHIpO1xuICB9XG4gIHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gICAgbGV0IHY7XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2ID0gZnJvbU9iamVjdChpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdiA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aGlzLl9yZ2IgPSB2O1xuICAgIHRoaXMuX3ZhbGlkID0gISF2O1xuICB9XG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gIH1cbiAgZ2V0IHJnYigpIHtcbiAgICB2YXIgdiA9IGNsb25lKHRoaXMuX3JnYik7XG4gICAgaWYgKHYpIHtcbiAgICAgIHYuYSA9IGIybih2LmEpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBzZXQgcmdiKG9iaikge1xuICAgIHRoaXMuX3JnYiA9IGZyb21PYmplY3Qob2JqKTtcbiAgfVxuICByZ2JTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gcmdiU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhleFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhzbFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoc2xTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBtaXgoY29sb3IsIHdlaWdodCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgY29uc3QgYzEgPSB0aGlzLnJnYjtcbiAgICAgIGNvbnN0IGMyID0gY29sb3IucmdiO1xuICAgICAgbGV0IHcyO1xuICAgICAgY29uc3QgcCA9IHdlaWdodCA9PT0gdzIgPyAwLjUgOiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3ID0gMiAqIHAgLSAxO1xuICAgICAgY29uc3QgYSA9IGMxLmEgLSBjMi5hO1xuICAgICAgY29uc3QgdzEgPSAoKHcgKiBhID09PSAtMSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG4gICAgICB3MiA9IDEgLSB3MTtcbiAgICAgIGMxLnIgPSAweEZGICYgdzEgKiBjMS5yICsgdzIgKiBjMi5yICsgMC41O1xuICAgICAgYzEuZyA9IDB4RkYgJiB3MSAqIGMxLmcgKyB3MiAqIGMyLmcgKyAwLjU7XG4gICAgICBjMS5iID0gMHhGRiAmIHcxICogYzEuYiArIHcyICogYzIuYiArIDAuNTtcbiAgICAgIGMxLmEgPSBwICogYzEuYSArICgxIC0gcCkgKiBjMi5hO1xuICAgICAgdGhpcy5yZ2IgPSBjMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW50ZXJwb2xhdGUoY29sb3IsIHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuX3JnYiA9IGludGVycG9sYXRlKHRoaXMuX3JnYiwgY29sb3IuX3JnYiwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xuICB9XG4gIGFscGhhKGEpIHtcbiAgICB0aGlzLl9yZ2IuYSA9IG4yYihhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcmVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgLSByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncmV5c2NhbGUoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIGNvbnN0IHZhbCA9IHJvdW5kKHJnYi5yICogMC4zICsgcmdiLmcgKiAwLjU5ICsgcmdiLmIgKiAwLjExKTtcbiAgICByZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb3BhcXVlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxICsgcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmVnYXRlKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLl9yZ2I7XG4gICAgdi5yID0gMjU1IC0gdi5yO1xuICAgIHYuZyA9IDI1NSAtIHYuZztcbiAgICB2LmIgPSAyNTUgLSB2LmI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlnaHRlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkYXJrZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdGF0ZShkZWcpIHtcbiAgICByb3RhdGUodGhpcy5fcmdiLCBkZWcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBpbmRleF9lc20oaW5wdXQpIHtcbiAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCB0eXBlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpID8gdmFsdWUgOiBpbmRleF9lc20odmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiBpbmRleF9lc20odmFsdWUpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkuaGV4U3RyaW5nKCk7XG59XG5cbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBnZXRTY29wZSQxKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCAnJyksIHNjb3BlKTtcbn1cbmNsYXNzIERlZmF1bHRzIHtcbiAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgfVxuICBzZXQoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQodGhpcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICB9XG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICBvdmVycmlkZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChvdmVycmlkZXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCBzY29wZSk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2NvcGVPYmplY3QsIHtcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG52YXIgZGVmYXVsdHMgPSBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udCkge1xuICBpZiAoIWZvbnQgfHwgaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cbmZ1bmN0aW9uIF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBzdHJpbmcpIHtcbiAgbGV0IHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICBnYy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICBsb25nZXN0ID0gdGV4dFdpZHRoO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2xvbmdlc3RUZXh0KGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcbiAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgbGV0IGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQ7XG4gIGxldCBsb25nZXN0ID0gMDtcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuICBsZXQgaSwgaiwgamxlbiwgdGhpbmcsIG5lc3RlZFRoaW5nO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xuICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmIGlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG4gICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpbmcpKSB7XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIG5lc3RlZFRoaW5nID0gdGhpbmdbal07XG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG4gIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgaWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgIH1cbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCB3aWR0aCkge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KSB7XG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHgsIHkpIHtcbiAgZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgbnVsbCk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCB3KSB7XG4gIGxldCB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBjb3JuZXJSYWRpdXMsIHdpZHRoO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgZGVmYXVsdDpcbiAgICBpZiAodykge1xuICAgICAgY3R4LmVsbGlwc2UoeCwgeSwgdyAvIDIsIHJhZGl1cywgMCwgMCwgVEFVKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAndHJpYW5nbGUnOlxuICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgIHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIGN0eC5hcmMoeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuICAgIGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdCc6XG4gICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogc2l6ZTtcbiAgICAgIGN0eC5yZWN0KHggLSB3aWR0aCwgeSAtIHNpemUsIDIgKiB3aWR0aCwgMiAqIHNpemUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICBjYXNlICdyZWN0Um90JzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjcm9zc1JvdCc6XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ2Nyb3NzJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3N0YXInOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2xpbmUnOlxuICAgIHhPZmZzZXQgPSB3ID8gdyAvIDIgOiBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rhc2gnOlxuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqIHJhZGl1cywgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgIGJyZWFrO1xuICB9XG4gIGN0eC5maWxsKCk7XG4gIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEocG9pbnQsIGFyZWEsIG1hcmdpbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41O1xuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cbmZ1bmN0aW9uIGNsaXBBcmVhKGN0eCwgYXJlYSkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdW5jbGlwQXJlYShjdHgpIHtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCwgbW9kZSkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiByZW5kZXJUZXh0KGN0eCwgdGV4dCwgeCwgeSwgZm9udCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaSwgbGluZTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnN0cm9rZVdpZHRoKSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG4gICAgeSArPSBmb250LmxpbmVIZWlnaHQ7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG4gIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3I7XG4gIH1cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cykge1xuICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICBjb25zdCBsZWZ0ID0geCAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcbiAgICBjb25zdCB0b3AgPSB5IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgY29uc3QgeURlY29yYXRpb24gPSBvcHRzLnN0cmlrZXRocm91Z2ggPyAodG9wICsgYm90dG9tKSAvIDIgOiBib3R0b207XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAtSEFMRl9QSSwgUEksIHRydWUpO1xuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGgpO1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIHJhZGl1cy50b3BSaWdodCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLyk7XG5jb25zdCBGT05UX1NUWUxFID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLyk7XG5mdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWUsIHNpemUpIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICBjYXNlICdweCc6XG4gICAgcmV0dXJuIHZhbHVlO1xuICBjYXNlICclJzpcbiAgICB2YWx1ZSAvPSAxMDA7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cbmNvbnN0IG51bWJlck9yWmVybyA9IHYgPT4gK3YgfHwgMDtcbmZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBwcm9wcykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdG9UUkJMKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwge3RvcDogJ3knLCByaWdodDogJ3gnLCBib3R0b206ICd5JywgbGVmdDogJ3gnfSk7XG59XG5mdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWyd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXSk7XG59XG5mdW5jdGlvbiB0b1BhZGRpbmcodmFsdWUpIHtcbiAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKTtcbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XG4gIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHRvRm9udChvcHRpb25zLCBmYWxsYmFjaykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250O1xuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICB9XG4gIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgc3R5bGUgPSAnJztcbiAgfVxuICBjb25zdCBmb250ID0ge1xuICAgIGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mYW1pbHksIGZhbGxiYWNrLmZhbWlseSksXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgIHNpemUsXG4gICAgc3R5bGUsXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICBzdHJpbmc6ICcnXG4gIH07XG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuICByZXR1cm4gZm9udDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzLCBjb250ZXh0LCBpbmRleCwgaW5mbykge1xuICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4LCBncmFjZSwgYmVnaW5BdFplcm8pIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlLCBhZGQpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICByZXR1cm4ge1xuICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dCwgY29udGV4dCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMgPSBbJyddLCByb290U2NvcGVzID0gc2NvcGVzLCBmYWxsYmFjaywgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdKSB7XG4gIGlmICghZGVmaW5lZChmYWxsYmFjaykpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3Blczogcm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfY3JlYXRlUmVzb2x2ZXIoW3Njb3BlLCAuLi5zY29wZXNdLCBwcmVmaXhlcywgcm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIGRlbGV0ZSBzY29wZXNbMF1bcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfYXR0YWNoQ29udGV4dChwcm94eSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICBjb25zdCBjYWNoZSA9IHtcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICBfcHJveHk6IHByb3h5LFxuICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgX3N0YWNrOiBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgc2V0Q29udGV4dDogKGN0eCkgPT4gX2F0dGFjaENvbnRleHQocHJveHksIGN0eCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgb3ZlcnJpZGU6IChzY29wZSkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHByb3h5W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfZGVzY3JpcHRvcnMocHJveHksIGRlZmF1bHRzID0ge3NjcmlwdGFibGU6IHRydWUsIGluZGV4YWJsZTogdHJ1ZX0pIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5jb25zdCByZWFkS2V5ID0gKHByZWZpeCwgbmFtZSkgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wLCB2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcbiAgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5mdW5jdGlvbiBfY2FjaGVkKHRhcmdldCwgcHJvcCwgcmVzb2x2ZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSBfYXR0YWNoQ29udGV4dCh2YWx1ZSwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIHZhbHVlID0gdmFsdWUoX2NvbnRleHQsIF9zdWJQcm94eSB8fCByZWNlaXZlcik7XG4gIF9zdGFjay5kZWxldGUocHJvcCk7XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgaXNJbmRleGFibGUpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGlmIChkZWZpbmVkKF9jb250ZXh0LmluZGV4KSAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gdmFsdWVbX2NvbnRleHQuaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlWzBdKSkge1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZXNvbHZlRmFsbGJhY2soZmFsbGJhY2ssIHByb3AsIHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrKHByb3AsIHZhbHVlKSA6IGZhbGxiYWNrO1xufVxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5LCBwYXJlbnQpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBhZGRTY29wZXMoc2V0LCBwYXJlbnRTY29wZXMsIGtleSwgcGFyZW50RmFsbGJhY2ssIHZhbHVlKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBmYWxzZSAmJiBkZWZpbmVkKHBhcmVudEZhbGxiYWNrKSAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIocGFyZW50U2NvcGVzLCByZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBwcm9wLCBmYWxsYmFjayB8fCBwcm9wLCB2YWx1ZSk7XG4gIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pIHtcbiAgd2hpbGUgKGtleSkge1xuICAgIGtleSA9IGFkZFNjb3BlcyhzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCBwcm94eSkge1xuICBsZXQgdmFsdWU7XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9yZXNvbHZlKGtleSwgc2NvcGVzKSB7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gc2NvcGVba2V5XTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMoc2NvcGVzKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY29wZSkuZmlsdGVyKGsgPT4gIWsuc3RhcnRzV2l0aCgnXycpKSkge1xuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuZnVuY3Rpb24gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHtrZXkgPSAncid9ID0gdGhpcy5fcGFyc2luZztcbiAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgcGFyc2VkW2ldID0ge1xuICAgICAgcjogaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwga2V5KSwgaW5kZXgpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5jb25zdCBFUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5jb25zdCBnZXRQb2ludCA9IChwb2ludHMsIGkpID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzKSA9PiBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbmZ1bmN0aW9uIHNwbGluZUN1cnZlKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG4gIGNvbnN0IHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gIGNvbnN0IG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG4gIGNvbnN0IGQwMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhjdXJyZW50LCBwcmV2aW91cyk7XG4gIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG4gIHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcbiAgY29uc3QgZmEgPSB0ICogczAxO1xuICBjb25zdCBmYiA9IHQgKiBzMTI7XG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGFscGhhSywgYmV0YUssIHRhdUssIHNxdWFyZWRNYWduaXR1ZGUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYWxwaGFLID0gbUtbaV0gLyBkZWx0YUtbaV07XG4gICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgc3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG4gICAgaWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGRlbHRhSyA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUsgPSBBcnJheShwb2ludHNMZW4pO1xuICBsZXQgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBjb25zdCBzbG9wZURlbHRhID0gcG9pbnRBZnRlcltpbmRleEF4aXNdIC0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgIDogKHNpZ24oZGVsdGFLW2kgLSAxXSkgIT09IHNpZ24oZGVsdGFLW2ldKSkgPyAwXG4gICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cbiAgbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKTtcbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cbmZ1bmN0aW9uIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhwb2ludHMsIG9wdGlvbnMsIGFyZWEsIGxvb3AsIGluZGV4QXhpcykge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGNvbnRyb2xQb2ludHM7XG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlKSB7XG4gIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWUsIG5vZGUsIHBhcmVudFByb3BlcnR5KSB7XG4gIGxldCB2YWx1ZUluUGl4ZWxzO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICB2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50KSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlcywgc3R5bGUsIHN1ZmZpeCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCB1c2VPZmZzZXRQb3MgPSAoeCwgeSwgdGFyZ2V0KSA9PiAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICF0YXJnZXQuc2hhZG93Um9vdCk7XG5mdW5jdGlvbiBnZXRDYW52YXNQb3NpdGlvbihlLCBjYW52YXMpIHtcbiAgY29uc3QgdG91Y2hlcyA9IGUudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlO1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2U7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2dCwgY2hhcnQpIHtcbiAgaWYgKCduYXRpdmUnIGluIGV2dCkge1xuICAgIHJldHVybiBldnQ7XG4gIH1cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjaGFydDtcbiAgaWYgKGJvcmRlckJveCkge1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLnJvdW5kKCh4IC0geE9mZnNldCkgLyB3aWR0aCAqIGNhbnZhcy53aWR0aCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKSxcbiAgICB5OiBNYXRoLnJvdW5kKCh5IC0geU9mZnNldCkgLyBoZWlnaHQgKiBjYW52YXMuaGVpZ2h0IC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgbWF4V2lkdGgsIG1heEhlaWdodDtcbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5jb25zdCByb3VuZDEgPSB2ID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiByZXRpbmFTY2FsZShjaGFydCwgZm9yY2VSYXRpbywgZm9yY2VTdHlsZSkge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgY2hhcnQuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgY2hhcnQud2lkdGggPSBkZXZpY2VXaWR0aCAvIHBpeGVsUmF0aW87XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfcG9pbnRJbkxpbmUocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG5cbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsLCByZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBkaXJlY3Rpb24pIHtcbiAgbGV0IHN0eWxlLCBvcmlnaW5hbDtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgY3R4LnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3JpZ2luYWwpIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgc3RhcnQgJT0gY291bnQ7XG4gIGlmIChsb29wKSB7XG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuICBlbmQgJT0gY291bnQ7XG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuICBmdW5jdGlvbiBhZGRTdHlsZShzLCBlLCBsLCBzdCkge1xuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgIGlmIChzID09PSBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgfSkpKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgICB9XG4gICAgICBwcmV2ID0gcHQ7XG4gICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgcmV0dXJuIHByZXZTdHlsZSAmJiBKU09OLnN0cmluZ2lmeShzdHlsZSkgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSk7XG59XG5cbmV4cG9ydCB7IF9pc1BvaW50SW5BcmVhIGFzICQsIF9mYWN0b3JpemUgYXMgQSwgZmluaXRlT3JEZWZhdWx0IGFzIEIsIGNhbGxiYWNrIGFzIEMsIF9hZGRHcmFjZSBhcyBELCBfbGltaXRWYWx1ZSBhcyBFLCB0b0RlZ3JlZXMgYXMgRiwgX21lYXN1cmVUZXh0IGFzIEcsIEhBTEZfUEkgYXMgSCwgX2ludDE2UmFuZ2UgYXMgSSwgX2FsaWduUGl4ZWwgYXMgSiwgdG9QYWRkaW5nIGFzIEssIGNsaXBBcmVhIGFzIEwsIHJlbmRlclRleHQgYXMgTSwgdW5jbGlwQXJlYSBhcyBOLCB0b0ZvbnQgYXMgTywgUEkgYXMgUCwgZWFjaCBhcyBRLCBfdG9MZWZ0UmlnaHRDZW50ZXIgYXMgUiwgX2FsaWduU3RhcnRFbmQgYXMgUywgVEFVIGFzIFQsIG92ZXJyaWRlcyBhcyBVLCBtZXJnZSBhcyBWLCBfY2FwaXRhbGl6ZSBhcyBXLCBnZXRSZWxhdGl2ZVBvc2l0aW9uIGFzIFgsIF9ybG9va3VwQnlLZXkgYXMgWSwgX2xvb2t1cEJ5S2V5IGFzIFosIF9hcnJheVVuaXF1ZSBhcyBfLCByZXNvbHZlIGFzIGEsIHRvTGluZUhlaWdodCBhcyBhJCwgZ2V0QW5nbGVGcm9tUG9pbnQgYXMgYTAsIGdldE1heGltdW1TaXplIGFzIGExLCBfZ2V0UGFyZW50Tm9kZSBhcyBhMiwgcmVhZFVzZWRTaXplIGFzIGEzLCB0aHJvdHRsZWQgYXMgYTQsIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgYXMgYTUsIF9pc0RvbVN1cHBvcnRlZCBhcyBhNiwgZGVzY3JpcHRvcnMgYXMgYTcsIGlzRnVuY3Rpb24gYXMgYTgsIF9hdHRhY2hDb250ZXh0IGFzIGE5LCBnZXRSdGxBZGFwdGVyIGFzIGFBLCBvdmVycmlkZVRleHREaXJlY3Rpb24gYXMgYUIsIF90ZXh0WCBhcyBhQywgcmVzdG9yZVRleHREaXJlY3Rpb24gYXMgYUQsIGRyYXdQb2ludExlZ2VuZCBhcyBhRSwgbm9vcCBhcyBhRiwgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIGFzIGFHLCBfc2V0TWluQW5kTWF4QnlLZXkgYXMgYUgsIG5pY2VOdW0gYXMgYUksIGFsbW9zdFdob2xlIGFzIGFKLCBhbG1vc3RFcXVhbHMgYXMgYUssIF9kZWNpbWFsUGxhY2VzIGFzIGFMLCBfbG9uZ2VzdFRleHQgYXMgYU0sIF9maWx0ZXJCZXR3ZWVuIGFzIGFOLCBfbG9va3VwIGFzIGFPLCBpc1BhdHRlcm5PckdyYWRpZW50IGFzIGFQLCBnZXRIb3ZlckNvbG9yIGFzIGFRLCBjbG9uZSQxIGFzIGFSLCBfbWVyZ2VyIGFzIGFTLCBfbWVyZ2VySWYgYXMgYVQsIF9kZXByZWNhdGVkIGFzIGFVLCBfc3BsaXRLZXkgYXMgYVYsIHRvRm9udFN0cmluZyBhcyBhVywgc3BsaW5lQ3VydmUgYXMgYVgsIHNwbGluZUN1cnZlTW9ub3RvbmUgYXMgYVksIGdldFN0eWxlIGFzIGFaLCBmb250U3RyaW5nIGFzIGFfLCBfY3JlYXRlUmVzb2x2ZXIgYXMgYWEsIF9kZXNjcmlwdG9ycyBhcyBhYiwgbWVyZ2VJZiBhcyBhYywgdWlkIGFzIGFkLCBkZWJvdW5jZSBhcyBhZSwgcmV0aW5hU2NhbGUgYXMgYWYsIGNsZWFyQ2FudmFzIGFzIGFnLCBzZXRzRXF1YWwgYXMgYWgsIF9lbGVtZW50c0VxdWFsIGFzIGFpLCBfaXNDbGlja0V2ZW50IGFzIGFqLCBfaXNCZXR3ZWVuIGFzIGFrLCBfcmVhZFZhbHVlVG9Qcm9wcyBhcyBhbCwgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMgYXMgYW0sIF9jb21wdXRlU2VnbWVudHMgYXMgYW4sIF9ib3VuZFNlZ21lbnRzIGFzIGFvLCBfc3RlcHBlZEludGVycG9sYXRpb24gYXMgYXAsIF9iZXppZXJJbnRlcnBvbGF0aW9uIGFzIGFxLCBfcG9pbnRJbkxpbmUgYXMgYXIsIF9zdGVwcGVkTGluZVRvIGFzIGFzLCBfYmV6aWVyQ3VydmVUbyBhcyBhdCwgZHJhd1BvaW50IGFzIGF1LCBhZGRSb3VuZGVkUmVjdFBhdGggYXMgYXYsIHRvVFJCTCBhcyBhdywgdG9UUkJMQ29ybmVycyBhcyBheCwgX2JvdW5kU2VnbWVudCBhcyBheSwgX25vcm1hbGl6ZUFuZ2xlIGFzIGF6LCBpc0FycmF5IGFzIGIsIFBJVEFVIGFzIGIwLCBJTkZJTklUWSBhcyBiMSwgUkFEX1BFUl9ERUcgYXMgYjIsIFFVQVJURVJfUEkgYXMgYjMsIFRXT19USElSRFNfUEkgYXMgYjQsIF9hbmdsZURpZmYgYXMgYjUsIGNvbG9yIGFzIGMsIGRlZmF1bHRzIGFzIGQsIGVmZmVjdHMgYXMgZSwgcmVzb2x2ZU9iamVjdEtleSBhcyBmLCBpc051bWJlckZpbml0ZSBhcyBnLCBjcmVhdGVDb250ZXh0IGFzIGgsIGlzT2JqZWN0IGFzIGksIGRlZmluZWQgYXMgaiwgaXNOdWxsT3JVbmRlZiBhcyBrLCBsaXN0ZW5BcnJheUV2ZW50cyBhcyBsLCB0b1BlcmNlbnRhZ2UgYXMgbSwgdG9EaW1lbnNpb24gYXMgbiwgZm9ybWF0TnVtYmVyIGFzIG8sIF9hbmdsZUJldHdlZW4gYXMgcCwgX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMgYXMgcSwgcmVxdWVzdEFuaW1GcmFtZSBhcyByLCBzaWduIGFzIHMsIHRvUmFkaWFucyBhcyB0LCB1bmxpc3RlbkFycmF5RXZlbnRzIGFzIHUsIHZhbHVlT3JEZWZhdWx0IGFzIHYsIF9zY2FsZVJhbmdlc0NoYW5nZWQgYXMgdywgaXNOdW1iZXIgYXMgeCwgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIGFzIHksIGxvZzEwIGFzIHogfTtcbiIsICIvKiFcbiAqIENoYXJ0LmpzIHYzLjkuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVxdWVzdEFuaW1GcmFtZSwgYSBhcyByZXNvbHZlLCBlIGFzIGVmZmVjdHMsIGMgYXMgY29sb3IsIGQgYXMgZGVmYXVsdHMsIGkgYXMgaXNPYmplY3QsIGIgYXMgaXNBcnJheSwgdiBhcyB2YWx1ZU9yRGVmYXVsdCwgdSBhcyB1bmxpc3RlbkFycmF5RXZlbnRzLCBsIGFzIGxpc3RlbkFycmF5RXZlbnRzLCBmIGFzIHJlc29sdmVPYmplY3RLZXksIGcgYXMgaXNOdW1iZXJGaW5pdGUsIGggYXMgY3JlYXRlQ29udGV4dCwgaiBhcyBkZWZpbmVkLCBzIGFzIHNpZ24sIGsgYXMgaXNOdWxsT3JVbmRlZiwgXyBhcyBfYXJyYXlVbmlxdWUsIHQgYXMgdG9SYWRpYW5zLCBtIGFzIHRvUGVyY2VudGFnZSwgbiBhcyB0b0RpbWVuc2lvbiwgVCBhcyBUQVUsIG8gYXMgZm9ybWF0TnVtYmVyLCBwIGFzIF9hbmdsZUJldHdlZW4sIEggYXMgSEFMRl9QSSwgUCBhcyBQSSwgcSBhcyBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgdyBhcyBfc2NhbGVSYW5nZXNDaGFuZ2VkLCB4IGFzIGlzTnVtYmVyLCB5IGFzIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSwgeiBhcyBsb2cxMCwgQSBhcyBfZmFjdG9yaXplLCBCIGFzIGZpbml0ZU9yRGVmYXVsdCwgQyBhcyBjYWxsYmFjaywgRCBhcyBfYWRkR3JhY2UsIEUgYXMgX2xpbWl0VmFsdWUsIEYgYXMgdG9EZWdyZWVzLCBHIGFzIF9tZWFzdXJlVGV4dCwgSSBhcyBfaW50MTZSYW5nZSwgSiBhcyBfYWxpZ25QaXhlbCwgSyBhcyB0b1BhZGRpbmcsIEwgYXMgY2xpcEFyZWEsIE0gYXMgcmVuZGVyVGV4dCwgTiBhcyB1bmNsaXBBcmVhLCBPIGFzIHRvRm9udCwgUSBhcyBlYWNoLCBSIGFzIF90b0xlZnRSaWdodENlbnRlciwgUyBhcyBfYWxpZ25TdGFydEVuZCwgVSBhcyBvdmVycmlkZXMsIFYgYXMgbWVyZ2UsIFcgYXMgX2NhcGl0YWxpemUsIFggYXMgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgWSBhcyBfcmxvb2t1cEJ5S2V5LCBaIGFzIF9sb29rdXBCeUtleSwgJCBhcyBfaXNQb2ludEluQXJlYSwgYTAgYXMgZ2V0QW5nbGVGcm9tUG9pbnQsIGExIGFzIGdldE1heGltdW1TaXplLCBhMiBhcyBfZ2V0UGFyZW50Tm9kZSwgYTMgYXMgcmVhZFVzZWRTaXplLCBhNCBhcyB0aHJvdHRsZWQsIGE1IGFzIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsIGE2IGFzIF9pc0RvbVN1cHBvcnRlZCwgYTcgYXMgZGVzY3JpcHRvcnMsIGE4IGFzIGlzRnVuY3Rpb24sIGE5IGFzIF9hdHRhY2hDb250ZXh0LCBhYSBhcyBfY3JlYXRlUmVzb2x2ZXIsIGFiIGFzIF9kZXNjcmlwdG9ycywgYWMgYXMgbWVyZ2VJZiwgYWQgYXMgdWlkLCBhZSBhcyBkZWJvdW5jZSwgYWYgYXMgcmV0aW5hU2NhbGUsIGFnIGFzIGNsZWFyQ2FudmFzLCBhaCBhcyBzZXRzRXF1YWwsIGFpIGFzIF9lbGVtZW50c0VxdWFsLCBhaiBhcyBfaXNDbGlja0V2ZW50LCBhayBhcyBfaXNCZXR3ZWVuLCBhbCBhcyBfcmVhZFZhbHVlVG9Qcm9wcywgYW0gYXMgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMsIGFuIGFzIF9jb21wdXRlU2VnbWVudHMsIGFvIGFzIF9ib3VuZFNlZ21lbnRzLCBhcCBhcyBfc3RlcHBlZEludGVycG9sYXRpb24sIGFxIGFzIF9iZXppZXJJbnRlcnBvbGF0aW9uLCBhciBhcyBfcG9pbnRJbkxpbmUsIGFzIGFzIF9zdGVwcGVkTGluZVRvLCBhdCBhcyBfYmV6aWVyQ3VydmVUbywgYXUgYXMgZHJhd1BvaW50LCBhdiBhcyBhZGRSb3VuZGVkUmVjdFBhdGgsIGF3IGFzIHRvVFJCTCwgYXggYXMgdG9UUkJMQ29ybmVycywgYXkgYXMgX2JvdW5kU2VnbWVudCwgYXogYXMgX25vcm1hbGl6ZUFuZ2xlLCBhQSBhcyBnZXRSdGxBZGFwdGVyLCBhQiBhcyBvdmVycmlkZVRleHREaXJlY3Rpb24sIGFDIGFzIF90ZXh0WCwgYUQgYXMgcmVzdG9yZVRleHREaXJlY3Rpb24sIGFFIGFzIGRyYXdQb2ludExlZ2VuZCwgYUYgYXMgbm9vcCwgYUcgYXMgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBhSCBhcyBfc2V0TWluQW5kTWF4QnlLZXksIGFJIGFzIG5pY2VOdW0sIGFKIGFzIGFsbW9zdFdob2xlLCBhSyBhcyBhbG1vc3RFcXVhbHMsIGFMIGFzIF9kZWNpbWFsUGxhY2VzLCBhTSBhcyBfbG9uZ2VzdFRleHQsIGFOIGFzIF9maWx0ZXJCZXR3ZWVuLCBhTyBhcyBfbG9va3VwIH0gZnJvbSAnLi9jaHVua3MvaGVscGVycy5zZWdtZW50Lm1qcyc7XG5leHBvcnQgeyBkIGFzIGRlZmF1bHRzIH0gZnJvbSAnLi9jaHVua3MvaGVscGVycy5zZWdtZW50Lm1qcyc7XG5cbmNsYXNzIEFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5fY2hhcnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBfbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgdHlwZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGFuaW1zLmxpc3RlbmVyc1t0eXBlXTtcbiAgICBjb25zdCBudW1TdGVwcyA9IGFuaW1zLmR1cmF0aW9uO1xuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZuID0+IGZuKHtcbiAgICAgIGNoYXJ0LFxuICAgICAgaW5pdGlhbDogYW5pbXMuaW5pdGlhbCxcbiAgICAgIG51bVN0ZXBzLFxuICAgICAgY3VycmVudFN0ZXA6IE1hdGgubWluKGRhdGUgLSBhbmltcy5zdGFydCwgbnVtU3RlcHMpXG4gICAgfSkpO1xuICB9XG4gIF9yZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGUoZGF0ZSA9IERhdGUubm93KCkpIHtcbiAgICBsZXQgcmVtYWluaW5nID0gMDtcbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0uX2FjdGl2ZSkge1xuICAgICAgICAgIGlmIChpdGVtLl90b3RhbCA+IGFuaW1zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgY2hhcnQuZHJhdygpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAncHJvZ3Jlc3MnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJlbWFpbmluZyArPSBpdGVtcy5sZW5ndGg7XG4gICAgfSk7XG4gICAgdGhpcy5fbGFzdERhdGUgPSBkYXRlO1xuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEFuaW1zKGNoYXJ0KSB7XG4gICAgY29uc3QgY2hhcnRzID0gdGhpcy5fY2hhcnRzO1xuICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIGFuaW1zID0ge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICBjb21wbGV0ZTogW10sXG4gICAgICAgICAgcHJvZ3Jlc3M6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFydHMuc2V0KGNoYXJ0LCBhbmltcyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltcztcbiAgfVxuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG4gIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICB9XG4gIGhhcyhjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuICBzdGFydChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBhbmltcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgYW5pbXMuZHVyYXRpb24gPSBhbmltcy5pdGVtcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiBNYXRoLm1heChhY2MsIGN1ci5fZHVyYXRpb24pLCAwKTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpdGVtc1tpXS5jYW5jZWwoKTtcbiAgICB9XG4gICAgYW5pbXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBEYXRlLm5vdygpLCAnY29tcGxldGUnKTtcbiAgfVxuICByZW1vdmUoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cbnZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcigpO1xuXG5jb25zdCB0cmFuc3BhcmVudCA9ICd0cmFuc3BhcmVudCc7XG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICBib29sZWFuKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZmFjdG9yID4gMC41ID8gdG8gOiBmcm9tO1xuICB9LFxuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBjb2xvcihmcm9tIHx8IHRyYW5zcGFyZW50KTtcbiAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGNvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5jbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihjZmcsIHRhcmdldCwgcHJvcCwgdG8pIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy50aWNrKERhdGUubm93KCkpO1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgIH1cbiAgfVxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3A7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBsZXQgZmFjdG9yO1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdG87XG4gICAgICB0aGlzLl9ub3RpZnkodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcbiAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0aGlzLl9mbihmcm9tLCB0bywgZmFjdG9yKTtcbiAgfVxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbnVtYmVycyA9IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cycsICd0ZW5zaW9uJ107XG5jb25zdCBjb2xvcnMgPSBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JhY2tncm91bmRDb2xvciddO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb24nLCB7XG4gIGRlbGF5OiB1bmRlZmluZWQsXG4gIGR1cmF0aW9uOiAxMDAwLFxuICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICBmbjogdW5kZWZpbmVkLFxuICBmcm9tOiB1bmRlZmluZWQsXG4gIGxvb3A6IHVuZGVmaW5lZCxcbiAgdG86IHVuZGVmaW5lZCxcbiAgdHlwZTogdW5kZWZpbmVkLFxufSk7XG5jb25zdCBhbmltYXRpb25PcHRpb25zID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuYW5pbWF0aW9uKTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb24nLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9pbmRleGFibGU6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdvblByb2dyZXNzJyAmJiBuYW1lICE9PSAnb25Db21wbGV0ZScgJiYgbmFtZSAhPT0gJ2ZuJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICBjb2xvcnM6IHtcbiAgICB0eXBlOiAnY29sb3InLFxuICAgIHByb3BlcnRpZXM6IGNvbG9yc1xuICB9LFxuICBudW1iZXJzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgcHJvcGVydGllczogbnVtYmVyc1xuICB9LFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCd0cmFuc2l0aW9ucycsIHtcbiAgYWN0aXZlOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwXG4gICAgfVxuICB9LFxuICByZXNpemU6IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiAwXG4gICAgfVxuICB9LFxuICBzaG93OiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIGZyb206ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuICBoaWRlOiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGZuOiB2ID0+IHYgfCAwXG4gICAgICB9LFxuICAgIH1cbiAgfVxufSk7XG5jbGFzcyBBbmltYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICB9XG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09IGtleSB8fCAhYW5pbWF0ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB2YWx1ZXMub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi50aGlzLl9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBydW5uaW5nW3Byb3BdID0gYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihjZmcsIHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIHVwZGF0ZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwocnVubmluZyk7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXZlcnNlID0gb3B0cy5yZXZlcnNlO1xuICBjb25zdCBtaW4gPSBvcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgY29uc3QgbWF4ID0gb3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXG4gICAgZW5kOiByZXZlcnNlID8gbWluIDogbWF4XG4gIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHkuZW5kLFxuICAgIHJpZ2h0OiB4LmVuZCxcbiAgICBib3R0b206IHkuc3RhcnQsXG4gICAgbGVmdDogeC5zdGFydFxuICB9O1xufVxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XG4gIGxldCB0LCByLCBiLCBsO1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHIsXG4gICAgYm90dG9tOiBiLFxuICAgIGxlZnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHZhbHVlID09PSBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIGZpbHRlclZpc2libGUpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSk7XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qga2V5cyA9IHN0YWNrLmtleXM7XG4gIGNvbnN0IHNpbmdsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdzaW5nbGUnO1xuICBsZXQgaSwgaWxlbiwgZGF0YXNldEluZGV4LCBvdGhlclZhbHVlO1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZGF0YXNldEluZGV4ID0gK2tleXNbaV07XG4gICAgaWYgKGRhdGFzZXRJbmRleCA9PT0gZHNJbmRleCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG90aGVyVmFsdWUgPSBzdGFjay52YWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoaXNOdW1iZXJGaW5pdGUob3RoZXJWYWx1ZSkgJiYgKHNpbmdsZU1vZGUgfHwgKHZhbHVlID09PSAwIHx8IHNpZ24odmFsdWUpID09PSBzaWduKG90aGVyVmFsdWUpKSkpIHtcbiAgICAgIHZhbHVlICs9IG90aGVyVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgYWRhdGEgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICBsZXQgaSwgaWxlbiwga2V5O1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGFkYXRhW2ldID0ge1xuICAgICAgeDoga2V5LFxuICAgICAgeTogZGF0YVtrZXldXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWRhdGE7XG59XG5mdW5jdGlvbiBpc1N0YWNrZWQoc2NhbGUsIG1ldGEpIHtcbiAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XG59XG5mdW5jdGlvbiBnZXRVc2VyQm91bmRzKHNjYWxlKSB7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBzY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW5EZWZpbmVkID8gbWluIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIG1heDogbWF4RGVmaW5lZCA/IG1heCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrS2V5LCBpbmRleFZhbHVlKSB7XG4gIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgcmV0dXJuIHN1YlN0YWNrW2luZGV4VmFsdWVdIHx8IChzdWJTdGFja1tpbmRleFZhbHVlXSA9IHt9KTtcbn1cbmZ1bmN0aW9uIGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgcG9zaXRpdmUsIHR5cGUpIHtcbiAgZm9yIChjb25zdCBtZXRhIG9mIHZTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgY29uc3Qge2NoYXJ0LCBfY2FjaGVkTWV0YTogbWV0YX0gPSBjb250cm9sbGVyO1xuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pO1xuICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIGluZGV4OiBkYXRhc2V0SW5kZXh9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICBjb25zdCBpbGVuID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IHN0YWNrO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcbiAgICBzdGFjay5fdG9wID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCB0cnVlLCBtZXRhLnR5cGUpO1xuICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsIGF4aXMpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCxcbiAgICB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgZGF0YXNldDogdW5kZWZpbmVkLFxuICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgIGluZGV4LFxuICAgICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQocGFyZW50LCBpbmRleCwgZWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgcGFyc2VkOiB1bmRlZmluZWQsXG4gICAgcmF3OiB1bmRlZmluZWQsXG4gICAgZWxlbWVudCxcbiAgICBpbmRleCxcbiAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgdHlwZTogJ2RhdGEnXG4gIH0pO1xufVxuZnVuY3Rpb24gY2xlYXJTdGFja3MobWV0YSwgaXRlbXMpIHtcbiAgY29uc3QgZGF0YXNldEluZGV4ID0gbWV0YS5jb250cm9sbGVyLmluZGV4O1xuICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGl0ZW1zID0gaXRlbXMgfHwgbWV0YS5fcGFyc2VkO1xuICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcykge1xuICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgIGlmICghc3RhY2tzIHx8IHN0YWNrc1theGlzXSA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICB9XG59XG5jb25zdCBpc0RpcmVjdFVwZGF0ZU1vZGUgPSAobW9kZSkgPT4gbW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZSc7XG5jb25zdCBjbG9uZUlmTm90U2hhcmVkID0gKGNhY2hlZCwgc2hhcmVkKSA9PiBzaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KSA9PiBjYW5TdGFjayAmJiAhbWV0YS5oaWRkZW4gJiYgbWV0YS5fc3RhY2tlZFxuICAmJiB7a2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLCB2YWx1ZXM6IG51bGx9O1xuY2xhc3MgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX2N0eCA9IGNoYXJ0LmN0eDtcbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29iamVjdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmxpbmtTY2FsZXMoKTtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gIH1cbiAgdXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KSB7XG4gICAgaWYgKHRoaXMuaW5kZXggIT09IGRhdGFzZXRJbmRleCkge1xuICAgICAgY2xlYXJTdGFja3ModGhpcy5fY2FjaGVkTWV0YSk7XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gIH1cbiAgbGlua1NjYWxlcygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpID0+IGF4aXMgPT09ICd4JyA/IHggOiBheGlzID09PSAncicgPyByIDogeTtcbiAgICBjb25zdCB4aWQgPSBtZXRhLnhBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnhBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3gnKSk7XG4gICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgIGNvbnN0IHJpZCA9IG1ldGEuckF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuckF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAncicpKTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBtZXRhLmluZGV4QXhpcztcbiAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgIGNvbnN0IHZpZCA9IG1ldGEudkF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeWlkLCB4aWQsIHJpZCk7XG4gICAgbWV0YS54U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeGlkKTtcbiAgICBtZXRhLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh5aWQpO1xuICAgIG1ldGEuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHJpZCk7XG4gICAgbWV0YS5pU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoaWlkKTtcbiAgICBtZXRhLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh2aWQpO1xuICB9XG4gIGdldERhdGFzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgfVxuICBnZXRNZXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuICB9XG4gIGdldFNjYWxlRm9ySWQoc2NhbGVJRCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcbiAgfVxuICBfZ2V0T3RoZXJTY2FsZShzY2FsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGVcbiAgICAgID8gbWV0YS52U2NhbGVcbiAgICAgIDogbWV0YS5pU2NhbGU7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCdyZXNldCcpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgfVxuICB9XG4gIF9kYXRhQ2hlY2soKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICBjb25zdCBfZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICBtZXRhLl9wYXJzZWQgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcbiAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICB9XG4gIGJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBzdGFja0NoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICBpZiAobWV0YS5zdGFjayAhPT0gZGF0YXNldC5zdGFjaykge1xuICAgICAgc3RhY2tDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgbWV0YS5zdGFjayA9IGRhdGFzZXQuc3RhY2s7XG4gICAgfVxuICAgIHRoaXMuX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldFNjb3BlS2V5cyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLl9wYXJzaW5nID0gdGhpcy5vcHRpb25zLnBhcnNpbmc7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgfVxuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IG1ldGEsIF9kYXRhOiBkYXRhfSA9IHRoaXM7XG4gICAgY29uc3Qge2lTY2FsZSwgX3N0YWNrZWR9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgICBtZXRhLl9zb3J0ZWQgPSB0cnVlO1xuICAgICAgcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJyYXkoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWV0YS5fc29ydGVkID0gc29ydGVkO1xuICAgIH1cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXG4gICAgICAgIFt2QXhpc106IHZTY2FsZS5wYXJzZShkYXRhW2luZGV4XSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShpdGVtWzBdLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB4QXhpc0tleSksIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgZ2V0UGFyc2VkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFtpbmRleF07XG4gIH1cbiAgZ2V0RGF0YUVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgfVxuICBhcHBseVN0YWNrKHNjYWxlLCBwYXJzZWQsIG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICB2YWx1ZXM6IHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcbiAgICBmdW5jdGlvbiBfc2tpcCgpIHtcbiAgICAgIHBhcnNlZCA9IF9wYXJzZWRbaV07XG4gICAgICBjb25zdCBvdGhlclZhbHVlID0gcGFyc2VkW290aGVyU2NhbGUuYXhpc107XG4gICAgICByZXR1cm4gIWlzTnVtYmVyRmluaXRlKHBhcnNlZFtzY2FsZS5heGlzXSkgfHwgb3RoZXJNaW4gPiBvdGhlclZhbHVlIHx8IG90aGVyTWF4IDwgb3RoZXJWYWx1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgZm9yIChpID0gaWxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICBnZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQ7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc051bWJlckZpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogaVNjYWxlID8gJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSA6ICcnLFxuICAgICAgdmFsdWU6IHZTY2FsZSA/ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSkgOiAnJ1xuICAgIH07XG4gIH1cbiAgX3VwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGUobW9kZSB8fCAnZGVmYXVsdCcpO1xuICAgIG1ldGEuX2NsaXAgPSB0b0NsaXAodmFsdWVPckRlZmF1bHQodGhpcy5vcHRpb25zLmNsaXAsIGRlZmF1bHRDbGlwKG1ldGEueFNjYWxlLCBtZXRhLnlTY2FsZSwgdGhpcy5nZXRNYXhPdmVyZmxvdygpKSkpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7fVxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhY3RpdmUgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZHJhd0NvdW50IHx8IChlbGVtZW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgY29uc3QgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgbGV0IGk7XG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGVsZW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlICYmIGRyYXdBY3RpdmVFbGVtZW50c09uVG9wKSB7XG4gICAgICAgIGFjdGl2ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5kcmF3KGN0eCwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgfVxuICB9XG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuICAgIGNvbnRleHQuYWN0aXZlID0gISFhY3RpdmU7XG4gICAgY29udGV4dC5tb2RlID0gbW9kZTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICB9XG4gIF9yZXNvbHZlRWxlbWVudE9wdGlvbnMoZWxlbWVudFR5cGUsIG1vZGUgPSAnZGVmYXVsdCcsIGluZGV4KSB7XG4gICAgY29uc3QgYWN0aXZlID0gbW9kZSA9PT0gJ2FjdGl2ZSc7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGVsZW1lbnRUeXBlICsgJy0nICsgbW9kZTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgY29uc3Qgc2hhcmluZyA9IHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyAmJiBkZWZpbmVkKGluZGV4KTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2xvbmVJZk5vdFNoYXJlZChjYWNoZWQsIHNoYXJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEVsZW1lbnRTY29wZUtleXModGhpcy5fdHlwZSwgZWxlbWVudFR5cGUpO1xuICAgIGNvbnN0IHByZWZpeGVzID0gYWN0aXZlID8gW2Ake2VsZW1lbnRUeXBlfUhvdmVyYCwgJ2hvdmVyJywgZWxlbWVudFR5cGUsICcnXSA6IFtlbGVtZW50VHlwZSwgJyddO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5lbGVtZW50c1tlbGVtZW50VHlwZV0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIF9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgdHJhbnNpdGlvbiwgYWN0aXZlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgYW5pbWF0aW9uLSR7dHJhbnNpdGlvbn1gO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAoY2hhcnQub3B0aW9ucy5hbmltYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKHRoaXMuX3R5cGUsIHRyYW5zaXRpb24pO1xuICAgICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICAgIG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgdHJhbnNpdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnMoY2hhcnQsIG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb25zKTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9jYWNoZWFibGUpIHtcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIGdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zaGFyZWRPcHRpb25zIHx8ICh0aGlzLl9zaGFyZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICB9XG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuICB1cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCBwcm9wZXJ0aWVzLCBtb2RlKSB7XG4gICAgaWYgKGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUpLnVwZGF0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIF9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgbW9kZSwgYWN0aXZlKSB7XG4gICAgZWxlbWVudC5hY3RpdmUgPSBhY3RpdmU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSk7XG4gICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUsIGFjdGl2ZSkudXBkYXRlKGVsZW1lbnQsIHtcbiAgICAgIG9wdGlvbnM6ICghYWN0aXZlICYmIHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSkgfHwgb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xuICB9XG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cbiAgX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGZvciAoY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gb2YgdGhpcy5fc3luY0xpc3QpIHtcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5wYXJzZSgwLCBjb3VudCk7XG4gICAgfVxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gIH1cbiAgX2luc2VydEVsZW1lbnRzKHN0YXJ0LCBjb3VudCwgcmVzZXROZXdFbGVtZW50cyA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbW92ZSA9IChhcnIpID0+IHtcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdmUoZGF0YSk7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgbW92ZShtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlKHN0YXJ0LCBjb3VudCk7XG4gICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZGF0YSwgc3RhcnQsIGNvdW50LCAncmVzZXQnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fVxuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG4gIF9zeW5jKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gPSBhcmdzO1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4LCAuLi5hcmdzXSk7XG4gIH1cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG4gIF9vbkRhdGFQb3AoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGggLSAxLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cbiAgX29uRGF0YVVuc2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIDAsIGFyZ3VtZW50cy5sZW5ndGhdKTtcbiAgfVxufVxuRGF0YXNldENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7fTtcbkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5kYXRhc2V0RWxlbWVudFR5cGUgPSBudWxsO1xuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCB0eXBlKSB7XG4gIGlmICghc2NhbGUuX2NhY2hlLiRiYXIpIHtcbiAgICBjb25zdCB2aXNpYmxlTWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKTtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aXNpYmxlTWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gIGNvbnN0IHNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgbGV0IGksIGlsZW4sIGN1cnIsIHByZXY7XG4gIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChwcmV2KSkge1xuICAgICAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhjdXJyIC0gcHJldikgfHwgbWluKTtcbiAgICB9XG4gICAgcHJldiA9IGN1cnI7XG4gIH07XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cbiAgcHJldiA9IHVuZGVmaW5lZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHNjYWxlLnRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG4gIHJldHVybiBtaW47XG59XG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuICBsZXQgc2l6ZSwgcmF0aW87XG4gIGlmIChpc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcbiAgICBzaXplID0gcnVsZXIubWluICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gICAgcmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG4gIH0gZWxzZSB7XG4gICAgc2l6ZSA9IHRoaWNrbmVzcyAqIHN0YWNrQ291bnQ7XG4gICAgcmF0aW8gPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvLFxuICAgIHN0YXJ0OiBydWxlci5waXhlbHNbaW5kZXhdIC0gKHNpemUgLyAyKVxuICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcbiAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgIHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcbiAgfVxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG4gIH1cbiAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxuICAgIHN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgY29uc3Qgc3RhcnRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVswXSwgaSk7XG4gIGNvbnN0IGVuZFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzFdLCBpKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGxldCBiYXJTdGFydCA9IG1pbjtcbiAgbGV0IGJhckVuZCA9IG1heDtcbiAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgYmFyRW5kID0gbWluO1xuICB9XG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuICBpdGVtLl9jdXN0b20gPSB7XG4gICAgYmFyU3RhcnQsXG4gICAgYmFyRW5kLFxuICAgIHN0YXJ0OiBzdGFydFZhbHVlLFxuICAgIGVuZDogZW5kVmFsdWUsXG4gICAgbWluLFxuICAgIG1heFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGlmIChpc0FycmF5KGVudHJ5KSkge1xuICAgIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbVt2U2NhbGUuYXhpc10gPSB2U2NhbGUucGFyc2UoZW50cnksIGkpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgY29uc3QgcGFyc2VkID0gW107XG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcbiAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZW50cnkgPSBkYXRhW2ldO1xuICAgIGl0ZW0gPSB7fTtcbiAgICBpdGVtW2lTY2FsZS5heGlzXSA9IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaV0sIGkpO1xuICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5mdW5jdGlvbiBpc0Zsb2F0QmFyKGN1c3RvbSkge1xuICByZXR1cm4gY3VzdG9tICYmIGN1c3RvbS5iYXJTdGFydCAhPT0gdW5kZWZpbmVkICYmIGN1c3RvbS5iYXJFbmQgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gIGlmIChzaXplICE9PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gIH1cbiAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5mdW5jdGlvbiBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKSB7XG4gIGxldCByZXZlcnNlLCBzdGFydCwgZW5kLCB0b3AsIGJvdHRvbTtcbiAgaWYgKHByb3BlcnRpZXMuaG9yaXpvbnRhbCkge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPiBwcm9wZXJ0aWVzLng7XG4gICAgc3RhcnQgPSAnbGVmdCc7XG4gICAgZW5kID0gJ3JpZ2h0JztcbiAgfSBlbHNlIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlIDwgcHJvcGVydGllcy55O1xuICAgIHN0YXJ0ID0gJ2JvdHRvbSc7XG4gICAgZW5kID0gJ3RvcCc7XG4gIH1cbiAgaWYgKHJldmVyc2UpIHtcbiAgICB0b3AgPSAnZW5kJztcbiAgICBib3R0b20gPSAnc3RhcnQnO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9ICdzdGFydCc7XG4gICAgYm90dG9tID0gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX07XG59XG5mdW5jdGlvbiBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCkge1xuICBsZXQgZWRnZSA9IG9wdGlvbnMuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgcmVzID0ge307XG4gIGlmICghZWRnZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVkZ2UgPT09IHRydWUpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSB7dG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBsZWZ0OiB0cnVlfTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfSA9IGJvcmRlclByb3BzKHByb3BlcnRpZXMpO1xuICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICBwcm9wZXJ0aWVzLmVuYWJsZUJvcmRlclJhZGl1cyA9IHRydWU7XG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW3BhcnNlRWRnZShib3R0b20sIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH1cbiAgfVxuICByZXNbcGFyc2VFZGdlKGVkZ2UsIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbn1cbmZ1bmN0aW9uIHBhcnNlRWRnZShlZGdlLCBhLCBiLCByZXZlcnNlKSB7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgZWRnZSA9IHN3YXAoZWRnZSwgYSwgYik7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGIsIGEpO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBhLCBiKTtcbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG4gIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5mdW5jdGlvbiBzdGFydEVuZCh2LCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB2ID09PSAnc3RhcnQnID8gc3RhcnQgOiB2ID09PSAnZW5kJyA/IGVuZCA6IHY7XG59XG5mdW5jdGlvbiBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIHtpbmZsYXRlQW1vdW50fSwgcmF0aW8pIHtcbiAgcHJvcGVydGllcy5pbmZsYXRlQW1vdW50ID0gaW5mbGF0ZUFtb3VudCA9PT0gJ2F1dG8nXG4gICAgPyByYXRpbyA9PT0gMSA/IDAuMzMgOiAwXG4gICAgOiBpbmZsYXRlQW1vdW50O1xufVxuY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIG9iajtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9iaiA9IGRhdGFbaV07XG4gICAgICBpdGVtID0ge307XG4gICAgICBpdGVtW2lTY2FsZS5heGlzXSA9IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgaUF4aXNLZXkpLCBpKTtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUocmVzb2x2ZU9iamVjdEtleShvYmosIHZBeGlzS2V5KSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIHN1cGVyLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XG4gICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIGN1c3RvbS5taW4pO1xuICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCBjdXN0b20ubWF4KTtcbiAgICB9XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuc3RhY2sgPSB0aGlzLmdldERhdGFzZXQoKS5zdGFjaztcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMobWV0YS5kYXRhLCAwLCBtZXRhLmRhdGEubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhiYXJzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgdnBpeGVscyA9IHJlc2V0IHx8IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZTY2FsZS5heGlzXSkgPyB7YmFzZSwgaGVhZDogYmFzZX0gOiB0aGlzLl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpKTtcbiAgICAgIGNvbnN0IGlwaXhlbHMgPSB0aGlzLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpLCBydWxlcik7XG4gICAgICBjb25zdCBzdGFjayA9IChwYXJzZWQuX3N0YWNrcyB8fCB7fSlbdlNjYWxlLmF4aXNdO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgYmFzZTogdnBpeGVscy5iYXNlLFxuICAgICAgICBlbmFibGVCb3JkZXJSYWRpdXM6ICFzdGFjayB8fCBpc0Zsb2F0QmFyKHBhcnNlZC5fY3VzdG9tKSB8fCAoaW5kZXggPT09IHN0YWNrLl90b3AgfHwgaW5kZXggPT09IHN0YWNrLl9ib3R0b20pLFxuICAgICAgICB4OiBob3Jpem9udGFsID8gdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXIsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcbiAgICAgICAgaGVpZ2h0OiBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogTWF0aC5hYnModnBpeGVscy5zaXplKSxcbiAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyBNYXRoLmFicyh2cGl4ZWxzLnNpemUpIDogaXBpeGVscy5zaXplXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIF9nZXRTdGFja3MobGFzdCwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qge2lTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gaVNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpXG4gICAgICAuZmlsdGVyKG1ldGEgPT4gbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IGlTY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgY29uc3Qgc2tpcE51bGwgPSAobWV0YSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWV0YS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VkICYmIHBhcnNlZFttZXRhLnZTY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbCkgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgbWV0YSBvZiBtZXRhc2V0cykge1xuICAgICAgaWYgKGRhdGFJbmRleCAhPT0gdW5kZWZpbmVkICYmIHNraXBOdWxsKG1ldGEpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWNrZWQgPT09IGZhbHNlIHx8IHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAobWV0YS5pbmRleCA9PT0gbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGFja3MubGVuZ3RoKSB7XG4gICAgICBzdGFja3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG4gIF9nZXRTdGFja0NvdW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gIH1cbiAgX2dldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBuYW1lLCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpO1xuICAgIGNvbnN0IGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgID8gc3RhY2tzLmluZGV4T2YobmFtZSlcbiAgICAgIDogLTE7XG4gICAgcmV0dXJuIChpbmRleCA9PT0gLTEpXG4gICAgICA/IHN0YWNrcy5sZW5ndGggLSAxXG4gICAgICA6IGluZGV4O1xuICB9XG4gIF9nZXRSdWxlcigpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHBpeGVscyA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwaXhlbHMucHVzaChpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKVtpU2NhbGUuYXhpc10sIGkpKTtcbiAgICB9XG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW4sXG4gICAgICBwaXhlbHMsXG4gICAgICBzdGFydDogaVNjYWxlLl9zdGFydFBpeGVsLFxuICAgICAgZW5kOiBpU2NhbGUuX2VuZFBpeGVsLFxuICAgICAgc3RhY2tDb3VudDogdGhpcy5fZ2V0U3RhY2tDb3VudCgpLFxuICAgICAgc2NhbGU6IGlTY2FsZSxcbiAgICAgIGdyb3VwZWQ6IG9wdHMuZ3JvdXBlZCxcbiAgICAgIHJhdGlvOiBiYXJUaGlja25lc3MgPyAxIDogb3B0cy5jYXRlZ29yeVBlcmNlbnRhZ2UgKiBvcHRzLmJhclBlcmNlbnRhZ2VcbiAgICB9O1xuICB9XG4gIF9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpbmRleCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YToge3ZTY2FsZSwgX3N0YWNrZWR9LCBvcHRpb25zOiB7YmFzZTogYmFzZVZhbHVlLCBtaW5CYXJMZW5ndGh9fSA9IHRoaXM7XG4gICAgY29uc3QgYWN0dWFsQmFzZSA9IGJhc2VWYWx1ZSB8fCAwO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCBmbG9hdGluZyA9IGlzRmxvYXRCYXIoY3VzdG9tKTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRbdlNjYWxlLmF4aXNdO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGxlbmd0aCA9IF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiB2YWx1ZTtcbiAgICBsZXQgaGVhZCwgc2l6ZTtcbiAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZSkge1xuICAgICAgc3RhcnQgPSBsZW5ndGggLSB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiBzaWduKHZhbHVlKSAhPT0gc2lnbihjdXN0b20uYmFyRW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCArPSB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICFpc051bGxPclVuZGVmKGJhc2VWYWx1ZSkgJiYgIWZsb2F0aW5nID8gYmFzZVZhbHVlIDogc3RhcnQ7XG4gICAgbGV0IGJhc2UgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydFZhbHVlKTtcbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQgPSBiYXNlO1xuICAgIH1cbiAgICBzaXplID0gaGVhZCAtIGJhc2U7XG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuICAgIH1cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemUsXG4gICAgICBiYXNlLFxuICAgICAgaGVhZCxcbiAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHRoaXMuX2dldFN0YWNrSW5kZXgodGhpcy5pbmRleCwgdGhpcy5fY2FjaGVkTWV0YS5zdGFjaywgc2tpcE51bGwgPyBpbmRleCA6IHVuZGVmaW5lZCk7XG4gICAgICBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCByYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudGVyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpbmRleClbc2NhbGUuYXhpc10sIGluZGV4KTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJ1bGVyLm1pbiAqIHJ1bGVyLnJhdGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGNlbnRlciAtIHNpemUgLyAyLFxuICAgICAgaGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXG4gICAgICBjZW50ZXIsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAodGhpcy5nZXRQYXJzZWQoaSlbdlNjYWxlLmF4aXNdICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3RzW2ldLmRyYXcodGhpcy5fY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbkJhckNvbnRyb2xsZXIuaWQgPSAnYmFyJztcbkJhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG4gIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICBiYXJQZXJjZW50YWdlOiAwLjksXG4gIGdyb3VwZWQ6IHRydWUsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICB9XG4gIH1cbn07XG5CYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgb2Zmc2V0OiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgQnViYmxlQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtICYmIGl0ZW0uciAmJiAraXRlbS5yLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IG1ldGEubGFiZWwsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgKHIgPyAnLCAnICsgciA6ICcnKSArICcpJ1xuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMucmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBsZXQgdmFsdWVzID0gc3VwZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSk7XG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXMsIHskc2hhcmVkOiBmYWxzZX0pO1xuICAgIH1cbiAgICBjb25zdCByYWRpdXMgPSB2YWx1ZXMucmFkaXVzO1xuICAgIGlmIChtb2RlICE9PSAnYWN0aXZlJykge1xuICAgICAgdmFsdWVzLnJhZGl1cyA9IDA7XG4gICAgfVxuICAgIHZhbHVlcy5yYWRpdXMgKz0gdmFsdWVPckRlZmF1bHQocGFyc2VkICYmIHBhcnNlZC5fY3VzdG9tLCByYWRpdXMpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbn1cbkJ1YmJsZUNvbnRyb2xsZXIuaWQgPSAnYnViYmxlJztcbkJ1YmJsZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJ11cbiAgICB9XG4gIH1cbn07XG5CdWJibGVDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgeDoge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfVxuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xuICBsZXQgcmF0aW9YID0gMTtcbiAgbGV0IHJhdGlvWSA9IDE7XG4gIGxldCBvZmZzZXRYID0gMDtcbiAgbGV0IG9mZnNldFkgPSAwO1xuICBpZiAoY2lyY3VtZmVyZW5jZSA8IFRBVSkge1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGVuZFggPSBNYXRoLmNvcyhlbmRBbmdsZSk7XG4gICAgY29uc3QgZW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBjYWxjTWF4ID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAxIDogTWF0aC5tYXgoYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgY2FsY01pbiA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gLTEgOiBNYXRoLm1pbihhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBtYXhYID0gY2FsY01heCgwLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1heFkgPSBjYWxjTWF4KEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgY29uc3QgbWluWCA9IGNhbGNNaW4oUEksIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWluWSA9IGNhbGNNaW4oUEkgKyBIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xuICAgIHJhdGlvWSA9IChtYXhZIC0gbWluWSkgLyAyO1xuICAgIG9mZnNldFggPSAtKG1heFggKyBtaW5YKSAvIDI7XG4gICAgb2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcbiAgfVxuICByZXR1cm4ge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfTtcbn1cbmNsYXNzIERvdWdobnV0Q29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgbGlua1NjYWxlcygpIHt9XG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFzZXQoKS5kYXRhO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGdldHRlciA9IChpKSA9PiArZGF0YVtpXTtcbiAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgY29uc3Qge2tleSA9ICd2YWx1ZSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgZ2V0dGVyID0gKGkpID0+ICtyZXNvbHZlT2JqZWN0S2V5KGRhdGFbaV0sIGtleSk7XG4gICAgICB9XG4gICAgICBsZXQgaSwgaWxlbjtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaV0gPSBnZXR0ZXIoaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9nZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgfVxuICBfZ2V0Q2lyY3VtZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgfVxuICBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgIGxldCBtaW4gPSBUQVU7XG4gICAgbGV0IG1heCA9IC1UQVU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjb250cm9sbGVyLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gY29udHJvbGxlci5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJvdGF0aW9uKTtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByb3RhdGlvbiArIGNpcmN1bWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IG1pbixcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHtjaGFydEFyZWF9ID0gY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXRNYXhCb3JkZXJXaWR0aCgpICsgdGhpcy5nZXRNYXhPZmZzZXQoYXJjcykgKyB0aGlzLm9wdGlvbnMuc3BhY2luZztcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xuICAgIGNvbnN0IGN1dG91dCA9IE1hdGgubWluKHRvUGVyY2VudGFnZSh0aGlzLm9wdGlvbnMuY3V0b3V0LCBtYXhTaXplKSwgMSk7XG4gICAgY29uc3QgY2hhcnRXZWlnaHQgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpO1xuICAgIGNvbnN0IHtjaXJjdW1mZXJlbmNlLCByb3RhdGlvbn0gPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKTtcbiAgICBjb25zdCB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9ID0gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSAoY2hhcnRBcmVhLndpZHRoIC0gc3BhY2luZykgLyByYXRpb1g7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5oZWlnaHQgLSBzcGFjaW5nKSAvIHJhdGlvWTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdG9EaW1lbnNpb24odGhpcy5vcHRpb25zLnJhZGl1cywgbWF4UmFkaXVzKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG91dGVyUmFkaXVzICogY3V0b3V0LCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0aGlzLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WCAqIG91dGVyUmFkaXVzO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFkgKiBvdXRlclJhZGl1cztcbiAgICBtZXRhLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IE1hdGgubWF4KHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgaWYgKChyZXNldCAmJiBvcHRzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlKSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSB8fCBtZXRhLl9wYXJzZWRbaV0gPT09IG51bGwgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UobWV0YS5fcGFyc2VkW2ldICogY2lyY3VtZmVyZW5jZSAvIFRBVSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG4gICAgY29uc3QgYW5pbWF0ZVNjYWxlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5pbm5lclJhZGl1cztcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLm91dGVyUmFkaXVzO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBsZXQgc3RhcnRBbmdsZSA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogY2VudGVyWSArIHRoaXMub2Zmc2V0WSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXNcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBzdGFydEFuZ2xlICs9IGNpcmN1bWZlcmVuY2U7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWV0YS5fcGFyc2VkW2ldO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhbWV0YURhdGFbaV0uaGlkZGVuKSB7XG4gICAgICAgIHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG4gIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodmFsdWUpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgaWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gVEFVICogKE1hdGguYWJzKHZhbHVlKSAvIHRvdGFsKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuICBnZXRNYXhCb3JkZXJXaWR0aChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xuICAgIGlmICghYXJjcykge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgIGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9wdGlvbnMgPSBjb250cm9sbGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3JkZXJBbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5vZmZzZXQgfHwgMCwgb3B0aW9ucy5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcbiAgICBsZXQgcmluZ1dlaWdodE9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICByaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcbiAgfVxuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG5Eb3VnaG51dENvbnRyb2xsZXIuaWQgPSAnZG91Z2hudXQnO1xuRG91Z2hudXRDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgIGFuaW1hdGVTY2FsZTogZmFsc2VcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICB9LFxuICB9LFxuICBjdXRvdXQ6ICc1MCUnLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6ICcxMDAlJyxcbiAgc3BhY2luZzogMCxcbiAgaW5kZXhBeGlzOiAncicsXG59O1xuRG91Z2hudXRDb250cm9sbGVyLmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGV9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgICAgICAgIGxldCBkYXRhTGFiZWwgPSB0b29sdGlwSXRlbS5sYWJlbDtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9ICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcnJheShkYXRhTGFiZWwpKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcbiAgICAgICAgICAgIGRhdGFMYWJlbFswXSArPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsICs9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YUxhYmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBMaW5lQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cbiAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgb3B0aW9uc1xuICAgIH0sIG1vZGUpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbkxpbmVDb250cm9sbGVyLmlkID0gJ2xpbmUnO1xuTGluZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBzcGFuR2FwczogZmFsc2UsXG59O1xuTGluZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgfSxcbiAgfVxufTtcblxuY2xhc3MgUG9sYXJBcmVhQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLl91cGRhdGVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBnZXRNaW5NYXgoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yO1xuICAgICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChwYXJzZWQgPCByYW5nZS5taW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZCA+IHJhbmdlLm1heCkge1xuICAgICAgICAgIHJhbmdlLm1heCA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICBfdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG4gICAgY29uc3QgZGF0YXNldFN0YXJ0QW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogUEk7XG4gICAgbGV0IGFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSkucikgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICBvdXRlclJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgY291bnRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4odGhpcy5nZXRQYXJzZWQoaW5kZXgpLnIpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cblBvbGFyQXJlYUNvbnRyb2xsZXIuaWQgPSAncG9sYXJBcmVhJztcblBvbGFyQXJlYUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgIH0sXG4gIH0sXG4gIGluZGV4QXhpczogJ3InLFxuICBzdGFydEFuZ2xlOiAwLFxufTtcblBvbGFyQXJlYUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGV9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY2hhcnQuZGF0YS5sYWJlbHNbY29udGV4dC5kYXRhSW5kZXhdICsgJzogJyArIGNvbnRleHQuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc3RhcnRBbmdsZTogMFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XG59XG5QaWVDb250cm9sbGVyLmlkID0gJ3BpZSc7XG5QaWVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBjdXRvdXQ6IDAsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnXG59O1xuXG5jbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxuICAgICAgdmFsdWU6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSlcbiAgICB9O1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IG1ldGEuaVNjYWxlLmdldExhYmVscygpO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgX2xvb3A6IHRydWUsXG4gICAgICAgIF9mdWxsTG9vcDogbGFiZWxzLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB0aGlzLmdldFBhcnNlZChpKS5yKTtcbiAgICAgIGNvbnN0IHggPSByZXNldCA/IHNjYWxlLnhDZW50ZXIgOiBwb2ludFBvc2l0aW9uLng7XG4gICAgICBjb25zdCB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbn1cblJhZGFyQ29udHJvbGxlci5pZCA9ICdyYWRhcic7XG5SYWRhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIGluZGV4QXhpczogJ3InLFxuICBzaG93TGluZTogdHJ1ZSxcbiAgZWxlbWVudHM6IHtcbiAgICBsaW5lOiB7XG4gICAgICBmaWxsOiAnc3RhcnQnXG4gICAgfVxuICB9LFxufTtcblJhZGFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuICBnZXRQcm9wcyhwcm9wcywgZmluYWwpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgcmV0W3Byb3BdID0gYW5pbXNbcHJvcF0gJiYgYW5pbXNbcHJvcF0uYWN0aXZlKCkgPyBhbmltc1twcm9wXS5fdG8gOiB0aGlzW3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbkVsZW1lbnQuZGVmYXVsdHMgPSB7fTtcbkVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcblxuY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgdmFsdWVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAnJyArIHZhbHVlO1xuICB9LFxuICBudW1lcmljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlO1xuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cbiAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgfVxuICAgIGNvbnN0IGxvZ0RlbHRhID0gbG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcbiAgICBjb25zdCBudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcbiAgICBjb25zdCBvcHRpb25zID0ge25vdGF0aW9uLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWwsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbH07XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgfSxcbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbHVlKSkpKTtcbiAgICBpZiAocmVtYWluID09PSAxIHx8IHJlbWFpbiA9PT0gMiB8fCByZW1haW4gPT09IDUpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpIHtcbiAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IDEgJiYgdGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG52YXIgVGlja3MgPSB7Zm9ybWF0dGVyc307XG5cbmRlZmF1bHRzLnNldCgnc2NhbGUnLCB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIG9mZnNldDogZmFsc2UsXG4gIHJldmVyc2U6IGZhbHNlLFxuICBiZWdpbkF0WmVybzogZmFsc2UsXG4gIGJvdW5kczogJ3RpY2tzJyxcbiAgZ3JhY2U6IDAsXG4gIGdyaWQ6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBkcmF3Qm9yZGVyOiB0cnVlLFxuICAgIGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcbiAgICBkcmF3VGlja3M6IHRydWUsXG4gICAgdGlja0xlbmd0aDogOCxcbiAgICB0aWNrV2lkdGg6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmNvbG9yLFxuICAgIG9mZnNldDogZmFsc2UsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wLFxuICAgIGJvcmRlcldpZHRoOiAxXG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgdGV4dDogJycsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiA0LFxuICAgICAgYm90dG9tOiA0XG4gICAgfVxuICB9LFxuICB0aWNrczoge1xuICAgIG1pblJvdGF0aW9uOiAwLFxuICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICBtaXJyb3I6IGZhbHNlLFxuICAgIHRleHRTdHJva2VXaWR0aDogMCxcbiAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgIHBhZGRpbmc6IDMsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICBhdXRvU2tpcFBhZGRpbmc6IDMsXG4gICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgIG1pbm9yOiB7fSxcbiAgICBtYWpvcjoge30sXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGNyb3NzQWxpZ246ICduZWFyJyxcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogZmFsc2UsXG4gICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgfVxufSk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGlja3MnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2JvcmRlckNvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpdGxlJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAndGlja0JvcmRlckRhc2gnLFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICBfZmFsbGJhY2s6ICdzY2FsZScsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZS50aWNrcycsIHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG59KTtcblxuZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgdGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IHRpY2tzTGltaXQpIHtcbiAgICBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBudW1NYWpvckluZGljZXMgLyB0aWNrc0xpbWl0KTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2NhbGUub3B0aW9ucy5vZmZzZXQ7XG4gIGNvbnN0IHRpY2tMZW5ndGggPSBzY2FsZS5fdGlja1NpemUoKTtcbiAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XG4gIGNvbnN0IG1heENoYXJ0ID0gc2NhbGUuX21heExlbmd0aCAvIHRpY2tMZW5ndGg7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKG1heFNjYWxlLCBtYXhDaGFydCkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcbiAgaWYgKCFldmVuTWFqb3JTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xuICB9XG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGlmIChtYWpvckVuZCkge1xuICAgIGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcbiAgICBzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcbiAgfVxuICBuZXh0ID0gc3RhcnQ7XG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG4gIGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcbiAgaWYgKGxlbiA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG5cbmNvbnN0IHJldmVyc2VBbGlnbiA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6IGFsaWduO1xuY29uc3Qgb2Zmc2V0RnJvbUVkZ2UgPSAoc2NhbGUsIGVkZ2UsIG9mZnNldCkgPT4gZWRnZSA9PT0gJ3RvcCcgfHwgZWRnZSA9PT0gJ2xlZnQnID8gc2NhbGVbZWRnZV0gKyBvZmZzZXQgOiBzY2FsZVtlZGdlXSAtIG9mZnNldDtcbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBpbmNyZW1lbnQgPSBhcnIubGVuZ3RoIC8gbnVtSXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS50aWNrcy5sZW5ndGg7XG4gIGNvbnN0IHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gIGNvbnN0IHN0YXJ0ID0gc2NhbGUuX3N0YXJ0UGl4ZWw7XG4gIGNvbnN0IGVuZCA9IHNjYWxlLl9lbmRQaXhlbDtcbiAgY29uc3QgZXBzaWxvbiA9IDFlLTY7XG4gIGxldCBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCk7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kcmF3VGlja3MgPyBvcHRpb25zLnRpY2tMZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBmb250ID0gdG9Gb250KG9wdGlvbnMuZm9udCwgZmFsbGJhY2spO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheShvcHRpb25zLnRleHQpID8gb3B0aW9ucy50ZXh0Lmxlbmd0aCA6IDE7XG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVTY2FsZUNvbnRleHQocGFyZW50LCBzY2FsZSkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBzY2FsZSxcbiAgICB0eXBlOiAnc2NhbGUnXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGlja0NvbnRleHQocGFyZW50LCBpbmRleCwgdGljaykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0aWNrLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICd0aWNrJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIGxldCByZXQgPSBfdG9MZWZ0UmlnaHRDZW50ZXIoYWxpZ24pO1xuICBpZiAoKHJldmVyc2UgJiYgcG9zaXRpb24gIT09ICdyaWdodCcpIHx8ICghcmV2ZXJzZSAmJiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICByZXQgPSByZXZlcnNlQWxpZ24ocmV0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVkgPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVkgPSAoY2hhcnRBcmVhLmJvdHRvbSArIGNoYXJ0QXJlYS50b3ApIC8gMiArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVZID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVYID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMiAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVggPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgcm90YXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICB9XG4gIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG59XG5jbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgdGhpcy50eXBlID0gY2ZnLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICB0aGlzLmNoYXJ0ID0gY2ZnLmNoYXJ0O1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpY2tzID0gW107XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLmF4aXMgPSBvcHRpb25zLmF4aXM7XG4gICAgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMubWF4KTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfVxuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7X3VzZXJNaW4sIF91c2VyTWF4LCBfc3VnZ2VzdGVkTWluLCBfc3VnZ2VzdGVkTWF4fSA9IHRoaXM7XG4gICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1pbiA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgbWluRGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgbWF4RGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNYXgpXG4gICAgfTtcbiAgfVxuICBnZXRNaW5NYXgoY2FuU3RhY2spIHtcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCByYW5nZTtcbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1pbiA9IG1heERlZmluZWQgJiYgbWluID4gbWF4ID8gbWF4IDogbWluO1xuICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgfVxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVybywgZ3JhY2UsIHRpY2tzOiB0aWNrT3B0c30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sIG1hcmdpbnMpO1xuICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG4gICAgaWYgKCF0aGlzLl9kYXRhTGltaXRzQ2FjaGVkKSB7XG4gICAgICB0aGlzLmJlZm9yZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5hZnRlckRhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuX3JhbmdlID0gX2FkZEdyYWNlKHRoaXMsIGdyYWNlLCBiZWdpbkF0WmVybyk7XG4gICAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XG4gICAgICB0aGlzLnRpY2tzID0gYXV0b1NraXAodGhpcywgdGhpcy50aWNrcyk7XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICAgIHRoaXMuYWZ0ZXJBdXRvU2tpcCgpO1xuICAgIH1cbiAgICBpZiAoc2FtcGxpbmdFbmFibGVkKSB7XG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcbiAgICB9XG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpO1xuICAgIHRoaXMuYWZ0ZXJGaXQoKTtcbiAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xuICB9XG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IGNhbGxiYWNrKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCBudW1UaWNrcyA9IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XG4gICAgICB0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcbiAgICAgIG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKVxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRUaXRsZUhlaWdodChvcHRpb25zLnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gdG9EZWdyZWVzKE1hdGgubWluKFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpXG4gICAgICApKTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcbiAgICB9XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge31cbiAgYmVmb3JlRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG1pblNpemUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgY29uc3Qge2NoYXJ0LCBvcHRpb25zOiB7dGlja3M6IHRpY2tPcHRzLCB0aXRsZTogdGl0bGVPcHRzLCBncmlkOiBncmlkT3B0c319ID0gdGhpcztcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5faXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja09wdHMubWlycm9yID8gMCA6IHNpbiAqIHdpZGVzdC53aWR0aCArIGNvcyAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBjb3MgKiB3aWRlc3Qud2lkdGggKyBzaW4gKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LndpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSBtaW5TaXplLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9sZW5ndGggPSBjaGFydC5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tO1xuICAgIH1cbiAgfVxuICBfY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpIHtcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDA7XG4gICAgY29uc3QgbGFiZWxzQmVsb3dUaWNrcyA9IHBvc2l0aW9uICE9PSAndG9wJyAmJiB0aGlzLmF4aXMgPT09ICd4JztcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IGNvcyAqIGZpcnN0LndpZHRoO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHNpbiAqIGxhc3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gc2luICogZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGNvcyAqIGxhc3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XG4gICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KChwYWRkaW5nUmlnaHQgLSBvZmZzZXRSaWdodCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgaWYgKHRoaXMuX21hcmdpbnMpIHtcbiAgICAgIHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1RvcCwgdGhpcy5fbWFyZ2lucy50b3ApO1xuICAgICAgdGhpcy5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1JpZ2h0LCB0aGlzLl9tYXJnaW5zLnJpZ2h0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XG4gICAgfVxuICB9XG4gIGFmdGVyRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3Qge2F4aXMsIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gIH1cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG4gIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykge1xuICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xuICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlsZW4tLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cbiAgX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xuICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoKSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcbiAgICAgIHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gbGFiZWxbal07XG4gICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICB3aWR0aHMsXG4gICAgICBoZWlnaHRzLFxuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge31cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG4gICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gX2ludDE2UmFuZ2UodGhpcy5fYWxpZ25Ub1BpeGVscyA/IF9hbGlnblBpeGVsKHRoaXMuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgfVxuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgfVxuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb259ID0gb3B0aW9ucztcbiAgICBjb25zdCBvZmZzZXQgPSBncmlkLm9mZnNldDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXQgPyAxIDogMCk7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmJvdHRvbSk7XG4gICAgICB0eTEgPSB0aGlzLmJvdHRvbSAtIHRsO1xuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMudG9wKTtcbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0aGlzLnRvcCArIHRsO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMucmlnaHQpO1xuICAgICAgdHgxID0gdGhpcy5yaWdodCAtIHRsO1xuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5sZWZ0KTtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0aGlzLmxlZnQgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyAwLjUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0LCB0aWNrc0xlbmd0aCk7XG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0aWNrc0xlbmd0aCAvIGxpbWl0KSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRpY2tzTGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUodGhpcywgaSwgb2Zmc2V0KTtcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHR4MSxcbiAgICAgICAgdHkxLFxuICAgICAgICB0eDIsXG4gICAgICAgIHR5MixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTIsXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgIGJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgdGlja0NvbG9yLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgeSA9IHRoaXMuYm90dG9tIC0gaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB5ID0gdGhpcy50b3AgKyBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHkgPSAoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHkgPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0gKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKSAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB4ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkudGV4dEFsaWduO1xuICAgIH1cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIHBpeGVsID0gdGhpcy5nZXRQaXhlbEZvclRpY2soaSkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcbiAgICAgIGZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcbiAgICAgIGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGhhbGZDb3VudCA9IGxpbmVDb3VudCAvIDI7XG4gICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3I7XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aDtcbiAgICAgIGxldCB0aWNrVGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB4ID0gcGl4ZWw7XG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGluZUNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ID0gcGl4ZWw7XG4gICAgICAgIHRleHRPZmZzZXQgPSAoMSAtIGxpbmVDb3VudCkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICAgIGxldCBiYWNrZHJvcDtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuICAgICAgICBsZXQgdG9wID0geSArIHRleHRPZmZzZXQgLSBsYWJlbFBhZGRpbmcudG9wO1xuICAgICAgICBsZXQgbGVmdCA9IHggLSBsYWJlbFBhZGRpbmcubGVmdDtcbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJhY2tkcm9wID0ge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGxhYmVsUGFkZGluZy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGxhYmVsUGFkZGluZy5oZWlnaHQsXG4gICAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3IsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmb250LFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB0ZXh0T2Zmc2V0LFxuICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgICAgdHJhbnNsYXRpb246IFt4LCB5XSxcbiAgICAgICAgYmFja2Ryb3AsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuICAgIGxldCBhbGlnbiA9ICdjZW50ZXInO1xuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICBhbGlnbiA9ICdpbm5lcic7XG4gICAgfVxuICAgIHJldHVybiBhbGlnbjtcbiAgfVxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggLT0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogdGhpcy5sZWZ0LCBib3R0b206IGNoYXJ0LmhlaWdodCwgcmlnaHQ6IHRoaXMucmlnaHR9O1xuICAgIH0gaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiB7dG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge2JhY2tncm91bmRDb2xvcn0sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MiwgeTogaXRlbS50eTJ9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoOiBpdGVtLnRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaDogaXRlbS50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCB7Y2hhcnQsIGN0eCwgb3B0aW9uczoge2dyaWR9fSA9IHRoaXM7XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gZ3JpZC5kcmF3Qm9yZGVyID8gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aCA6IDA7XG4gICAgaWYgKCFheGlzV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgIGxldCB4MSwgeDIsIHkxLCB5MjtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLmJvcmRlcldpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd0xhYmVscyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2NvbXB1dGVMYWJlbEFyZWEoKTtcbiAgICBpZiAoYXJlYSkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICBpZiAoaXRlbS5iYWNrZHJvcCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gaXRlbS5iYWNrZHJvcC5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGl0ZW0uYmFja2Ryb3AubGVmdCwgaXRlbS5iYWNrZHJvcC50b3AsIGl0ZW0uYmFja2Ryb3Aud2lkdGgsIGl0ZW0uYmFja2Ryb3AuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGxldCB5ID0gaXRlbS50ZXh0T2Zmc2V0O1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxhYmVsLCAwLCB5LCB0aWNrRm9udCwgaXRlbSk7XG4gICAgfVxuICAgIGlmIChhcmVhKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250ID0gdG9Gb250KHRpdGxlLmZvbnQpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGUucGFkZGluZyk7XG4gICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICBsZXQgb2Zmc2V0ID0gZm9udC5saW5lSGVpZ2h0IC8gMjtcbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nIHx8IHBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcbiAgICAgIGlmIChpc0FycmF5KHRpdGxlLnRleHQpKSB7XG4gICAgICAgIG9mZnNldCArPSBmb250LmxpbmVIZWlnaHQgKiAodGl0bGUudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcudG9wO1xuICAgIH1cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZS50ZXh0LCAwLCAwLCBmb250LCB7XG4gICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbiAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdHogPSBvcHRzLnRpY2tzICYmIG9wdHMudGlja3MueiB8fCAwO1xuICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgejogZ3osXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGd6ICsgMSxcbiAgICAgIGRyYXc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICAgIGlmIChtZXRhW2F4aXNJRF0gPT09IHRoaXMuaWQgJiYgKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG5cbmNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIGl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cbiAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGU7XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIHBhcmVudFNjb3BlID8gZGVmYXVsdHMuZ2V0KHBhcmVudFNjb3BlKSA6IHt9LFxuICAgIGRlZmF1bHRzLmdldChzY29wZSksXG4gICAgaXRlbS5kZWZhdWx0c1xuICBdKTtcbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xuICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgfVxufVxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cblxuY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cbiAgYWRkKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICBhZGRTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG4gIGdldEVsZW1lbnQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICB9XG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG4gIHJlbW92ZUNvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgX2VhY2gobWV0aG9kLCBhcmdzLCB0eXBlZFJlZ2lzdHJ5KSB7XG4gICAgWy4uLmFyZ3NdLmZvckVhY2goYXJnID0+IHtcbiAgICAgIGNvbnN0IHJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGFyZyk7XG4gICAgICBpZiAodHlwZWRSZWdpc3RyeSB8fCByZWcuaXNGb3JUeXBlKGFyZykgfHwgKHJlZyA9PT0gdGhpcy5wbHVnaW5zICYmIGFyZy5pZCkpIHtcbiAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIHJlZywgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goYXJnLCBpdGVtID0+IHtcbiAgICAgICAgICBjb25zdCBpdGVtUmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoaXRlbSk7XG4gICAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydhZnRlcicgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpO1xuICB9XG4gIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWcgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbaV07XG4gICAgICBpZiAocmVnLmlzRm9yVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG4gIF9nZXQoaWQsIHR5cGVkUmVnaXN0cnksIHR5cGUpIHtcbiAgICBjb25zdCBpdGVtID0gdHlwZWRSZWdpc3RyeS5nZXQoaWQpO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG59XG52YXIgcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcblxuY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGE6IHBvaW50cyA9IFtdfSA9IG1ldGE7XG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgX2RhdGFzZXR9ID0gbWV0YTtcbiAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB7c2hvd0xpbmV9ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgc2hvd0xpbmUpIHtcbiAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gcmVnaXN0cnkuZ2V0RWxlbWVudCgnbGluZScpO1xuICAgIH1cbiAgICBzdXBlci5hZGRFbGVtZW50cygpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGxldCBtYXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICAgIH1cbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG59XG5TY2F0dGVyQ29udHJvbGxlci5pZCA9ICdzY2F0dGVyJztcblNjYXR0ZXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIHNob3dMaW5lOiBmYWxzZSxcbiAgZmlsbDogZmFsc2Vcbn07XG5TY2F0dGVyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGludGVyYWN0aW9uOiB7XG4gICAgbW9kZTogJ3BvaW50J1xuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwoaXRlbSkge1xuICAgICAgICAgIHJldHVybiAnKCcgKyBpdGVtLmxhYmVsICsgJywgJyArIGl0ZW0uZm9ybWF0dGVkVmFsdWUgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbnRyb2xsZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQmFyQ29udHJvbGxlcjogQmFyQ29udHJvbGxlcixcbkJ1YmJsZUNvbnRyb2xsZXI6IEJ1YmJsZUNvbnRyb2xsZXIsXG5Eb3VnaG51dENvbnRyb2xsZXI6IERvdWdobnV0Q29udHJvbGxlcixcbkxpbmVDb250cm9sbGVyOiBMaW5lQ29udHJvbGxlcixcblBvbGFyQXJlYUNvbnRyb2xsZXI6IFBvbGFyQXJlYUNvbnRyb2xsZXIsXG5QaWVDb250cm9sbGVyOiBQaWVDb250cm9sbGVyLFxuUmFkYXJDb250cm9sbGVyOiBSYWRhckNvbnRyb2xsZXIsXG5TY2F0dGVyQ29udHJvbGxlcjogU2NhdHRlckNvbnRyb2xsZXJcbn0pO1xuXG5mdW5jdGlvbiBhYnN0cmFjdCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XG59XG5jbGFzcyBEYXRlQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG4gIGluaXQoY2hhcnRPcHRpb25zKSB7fVxuICBmb3JtYXRzKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHBhcnNlKHZhbHVlLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBmb3JtYXQodGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBhZGQodGltZXN0YW1wLCBhbW91bnQsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBkaWZmKGEsIGIsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBzdGFydE9mKHRpbWVzdGFtcCwgdW5pdCwgd2Vla2RheSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGVuZE9mKHRpbWVzdGFtcCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcbiAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcbnZhciBhZGFwdGVycyA9IHtcbiAgX2RhdGU6IERhdGVBZGFwdGVyXG59O1xuXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobWV0YXNldCwgYXhpcywgdmFsdWUsIGludGVyc2VjdCkge1xuICBjb25zdCB7Y29udHJvbGxlciwgZGF0YSwgX3NvcnRlZH0gPSBtZXRhc2V0O1xuICBjb25zdCBpU2NhbGUgPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhLmlTY2FsZTtcbiAgaWYgKGlTY2FsZSAmJiBheGlzID09PSBpU2NhbGUuYXhpcyAmJiBheGlzICE9PSAncicgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgIHJldHVybiBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvOiAwLCBoaTogZGF0YS5sZW5ndGggLSAxfTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFfaXNQb2ludEluQXJlYShlbGVtZW50LCBjaGFydC5jaGFydEFyZWEsIDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jLCB0cnVlKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZX0gPSBlbGVtZW50LmdldFByb3BzKFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGV9ID0gZ2V0QW5nbGVGcm9tUG9pbnQoZWxlbWVudCwge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9KTtcbiAgICBpZiAoX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBjb25zdCBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKTtcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgaW5SYW5nZSA9IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgcG9pbnRJbkFyZWEgPSAhIWluY2x1ZGVJbnZpc2libGUgfHwgY2hhcnQuaXNQb2ludEluQXJlYShjZW50ZXIpO1xuICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcbiAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMgPSBbe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9XTtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gYXhpcyA9PT0gJ3InICYmICFpbnRlcnNlY3RcbiAgICA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgOiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHJhbmdlTWV0aG9kID0gYXhpcyA9PT0gJ3gnID8gJ2luWFJhbmdlJyA6ICdpbllSYW5nZSc7XG4gIGxldCBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkgPT4ge1xuICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICAgIGludGVyc2VjdHNJdGVtID0gaW50ZXJzZWN0c0l0ZW0gfHwgZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG4gIGlmIChpbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cbnZhciBJbnRlcmFjdGlvbiA9IHtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zLFxuICBtb2Rlczoge1xuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgY29uc3QgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSlcbiAgICAgICAgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmZvckVhY2goKG1ldGEpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpdGVtc1swXS5pbmRleDtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG1ldGEuZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXgsIGluZGV4fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG4gICAgZGF0YXNldChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0SW5kZXggPSBpdGVtc1swXS5kYXRhc2V0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmRhdGE7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQ6IGRhdGFbaV0sIGRhdGFzZXRJbmRleCwgaW5kZXg6IGl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcbiAgICB4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd4Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneScsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG4gIHJldHVybiBhcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XG4gICAgY29uc3QgdjEgPSByZXZlcnNlID8gYSA6IGI7XG4gICAgcmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cbiAgICAgIHYwLmluZGV4IC0gdjEuaW5kZXggOlxuICAgICAgdjAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tzKGxheW91dHMpIHtcbiAgY29uc3Qgc3RhY2tzID0ge307XG4gIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKSB7XG4gICAgY29uc3Qge3N0YWNrLCBwb3MsIHN0YWNrV2VpZ2h0fSA9IHdyYXA7XG4gICAgaWYgKCFzdGFjayB8fCAhU1RBVElDX1BPU0lUSU9OUy5pbmNsdWRlcyhwb3MpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgX3N0YWNrID0gc3RhY2tzW3N0YWNrXSB8fCAoc3RhY2tzW3N0YWNrXSA9IHtjb3VudDogMCwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDAsIHNpemU6IDB9KTtcbiAgICBfc3RhY2suY291bnQrKztcbiAgICBfc3RhY2sud2VpZ2h0ICs9IHN0YWNrV2VpZ2h0O1xuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IHdyYXBCb3hlcyhib3hlcyk7XG4gIGNvbnN0IGZ1bGxTaXplID0gc29ydEJ5V2VpZ2h0KGxheW91dEJveGVzLmZpbHRlcih3cmFwID0+IHdyYXAuYm94LmZ1bGxTaXplKSwgdHJ1ZSk7XG4gIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XG4gIGNvbnN0IHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcbiAgY29uc3QgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XG4gIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xuICBjb25zdCBjZW50ZXJIb3Jpem9udGFsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneCcpO1xuICBjb25zdCBjZW50ZXJWZXJ0aWNhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3knKTtcbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xuICBtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG4gIG1heFBhZGRpbmcubGVmdCA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcbiAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuICBtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG59XG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgY2hhcnRBcmVhW3Bvc10gLT0gbGF5b3V0LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge3NpemU6IDAsIGNvdW50OiAxfTtcbiAgICBzdGFjay5zaXplID0gTWF0aC5tYXgoc3RhY2suc2l6ZSwgbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoKTtcbiAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBsYXlvdXQuc2l6ZTtcbiAgfVxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcbiAgcmV0dXJuIGxheW91dC5ob3Jpem9udGFsXG4gICAgPyB7c2FtZTogd2lkdGhDaGFuZ2VkLCBvdGhlcjogaGVpZ2h0Q2hhbmdlZH1cbiAgICA6IHtzYW1lOiBoZWlnaHRDaGFuZ2VkLCBvdGhlcjogd2lkdGhDaGFuZ2VkfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuZnVuY3Rpb24gZ2V0TWFyZ2lucyhob3Jpem9udGFsLCBjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuZnVuY3Rpb24gZml0Qm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0LCBib3gsIHJlZml0LCBjaGFuZ2VkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuICAgIGlmICghYm94LmZ1bGxTaXplKSB7XG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZml0ICYmIGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHx8IGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcbiAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpIHtcbiAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge2NvdW50OiAxLCBwbGFjZWQ6IDAsIHdlaWdodDogMX07XG4gICAgY29uc3Qgd2VpZ2h0ID0gKGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCkgfHwgMTtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY2hhcnRBcmVhLncgKiB3ZWlnaHQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeSA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgdXNlclBhZGRpbmcubGVmdCwgeSwgcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCAtIHVzZXJQYWRkaW5nLmxlZnQsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgY2hhcnRBcmVhLmxlZnQgKyBzdGFjay5wbGFjZWQsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB5O1xuICAgICAgc3RhY2sucGxhY2VkICs9IHdpZHRoO1xuICAgICAgeSA9IGJveC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0QXJlYS5oICogd2VpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBzdGFjay5zaXplIHx8IGJveC53aWR0aDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB4ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCB1c2VyUGFkZGluZy50b3AsIHdpZHRoLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSB1c2VyUGFkZGluZy5ib3R0b20gLSB1c2VyUGFkZGluZy50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB4O1xuICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcbiAgICAgIHggPSBib3gucmlnaHQ7XG4gICAgfVxuICB9XG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gIGF1dG9QYWRkaW5nOiB0cnVlLFxuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH1cbn0pO1xudmFyIGxheW91dHMgPSB7XG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICBpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogMCxcbiAgICAgICAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICAgICAgICBpdGVtLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfTtcbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBvdXRlcldpZHRoOiB3aWR0aCxcbiAgICAgIG91dGVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwYWRkaW5nLFxuICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZpc2libGVWZXJ0aWNhbEJveENvdW50LFxuICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuICAgIH0pO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBwYWRkaW5nKTtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYXhQYWRkaW5nLFxuICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXG4gICAgICBoOiBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB4OiBwYWRkaW5nLmxlZnQsXG4gICAgICB5OiBwYWRkaW5nLnRvcFxuICAgIH0sIHBhZGRpbmcpO1xuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cbiAgICBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSk7XG4gICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydC5jaGFydEFyZWEgPSB7XG4gICAgICBsZWZ0OiBjaGFydEFyZWEubGVmdCxcbiAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcbiAgICAgIHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxuICAgICAgYm90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxuICAgICAgd2lkdGg6IGNoYXJ0QXJlYS53LFxuICAgIH07XG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHt9XG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgfVxufVxuXG5jbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cbn1cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3VjaGVuZDogJ21vdXNldXAnLFxuICBwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcbiAgcG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuICBwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG4gIHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuICBwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG4gIHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuICBjb25zdCByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgY29uc3QgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgc3R5bGUuYm94U2l6aW5nID0gc3R5bGUuYm94U2l6aW5nIHx8ICdib3JkZXItYm94JztcbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FudmFzO1xufVxuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vZGVMaXN0Q29udGFpbnMobm9kZUxpc3QsIGNhbnZhcykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3QpIHtcbiAgICBpZiAobm9kZSA9PT0gY2FudmFzIHx8IG5vZGUuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcbmZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgaWYgKGRwciA9PT0gb2xkRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgIHJldHVybjtcbiAgfVxuICBvbGREZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZm9yRWFjaCgocmVzaXplLCBjaGFydCkgPT4ge1xuICAgIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gZHByKSB7XG4gICAgICByZXNpemUoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCkge1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZXNpemUgPSB0aHJvdHRsZWQoKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGxpc3RlbmVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICh3IDwgY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuICBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gcmVsZWFzZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBvYnNlcnZlcikge1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG4gICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5QW5kTGlzdGVuKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IHByb3h5ID0gdGhyb3R0bGVkKChldmVudCkgPT4ge1xuICAgIGlmIChjaGFydC5jdHggIT09IG51bGwpIHtcbiAgICAgIGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcbiAgICB9XG4gIH0sIGNoYXJ0LCAoYXJncykgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICByZXR1cm4gW2V2ZW50LCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXTtcbiAgfSk7XG4gIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5jbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0ICYmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuICAgIFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdHlsZSA9IGluaXRpYWwuc3R5bGUgfHwge307XG4gICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY2FudmFzLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgIH0pO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSk7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuICAgIGlmICghcHJveHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIGRldGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgcmVzaXplOiByZWxlYXNlT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCByZW1vdmVMaXN0ZW5lcjtcbiAgICBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBwcm94eSk7XG4gICAgcHJveGllc1t0eXBlXSA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RldGVjdFBsYXRmb3JtKGNhbnZhcykge1xuICBpZiAoIV9pc0RvbVN1cHBvcnRlZCgpIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpKSB7XG4gICAgcmV0dXJuIEJhc2ljUGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIERvbVBsYXRmb3JtO1xufVxuXG5jbGFzcyBQbHVnaW5TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5pdCA9IFtdO1xuICB9XG4gIG5vdGlmeShjaGFydCwgaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgaWYgKGhvb2sgPT09ICdiZWZvcmVJbml0Jykge1xuICAgICAgdGhpcy5faW5pdCA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB0cnVlKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ2luc3RhbGwnKTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCkuZmlsdGVyKGZpbHRlcikgOiB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncyk7XG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAndW5pbnN0YWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpIHtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuICAgICAgY29uc3QgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuICAgICAgY29uc3QgcGFyYW1zID0gW2NoYXJ0LCBhcmdzLCBkZXNjcmlwdG9yLm9wdGlvbnNdO1xuICAgICAgaWYgKGNhbGxiYWNrKG1ldGhvZCwgcGFyYW1zLCBwbHVnaW4pID09PSBmYWxzZSAmJiBhcmdzLmNhbmNlbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgX2Rlc2NyaXB0b3JzKGNoYXJ0KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH1cbiAgX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBhbGwpIHtcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlT3JEZWZhdWx0KGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgICBjb25zdCBwbHVnaW5zID0gYWxsUGx1Z2lucyhjb25maWcpO1xuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgfVxuICBfbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KSB7XG4gICAgY29uc3QgcHJldmlvdXNEZXNjcmlwdG9ycyA9IHRoaXMuX29sZENhY2hlIHx8IFtdO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGU7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LnBsdWdpbi5pZCA9PT0geS5wbHVnaW4uaWQpKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKGRlc2NyaXB0b3JzLCBwcmV2aW91c0Rlc2NyaXB0b3JzKSwgY2hhcnQsICdzdGFydCcpO1xuICB9XG59XG5mdW5jdGlvbiBhbGxQbHVnaW5zKGNvbmZpZykge1xuICBjb25zdCBsb2NhbElkcyA9IHt9O1xuICBjb25zdCBwbHVnaW5zID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbHVnaW5zLml0ZW1zKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGx1Z2lucy5wdXNoKHJlZ2lzdHJ5LmdldFBsdWdpbihrZXlzW2ldKSk7XG4gIH1cbiAgY29uc3QgbG9jYWwgPSBjb25maWcucGx1Z2lucyB8fCBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IGxvY2FsW2ldO1xuICAgIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgbG9jYWxJZHNbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB7cGx1Z2lucywgbG9jYWxJZHN9O1xufVxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB7cGx1Z2lucywgbG9jYWxJZHN9LCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCBvcHRzID0gZ2V0T3B0cyhvcHRpb25zW2lkXSwgYWxsKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHBsdWdpbixcbiAgICAgIG9wdGlvbnM6IHBsdWdpbk9wdHMoY2hhcnQuY29uZmlnLCB7cGx1Z2luLCBsb2NhbDogbG9jYWxJZHNbaWRdfSwgb3B0cywgY29udGV4dClcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHtwbHVnaW4sIGxvY2FsfSwgb3B0cywgY29udGV4dCkge1xuICBjb25zdCBrZXlzID0gY29uZmlnLnBsdWdpblNjb3BlS2V5cyhwbHVnaW4pO1xuICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICBpZiAobG9jYWwgJiYgcGx1Z2luLmRlZmF1bHRzKSB7XG4gICAgc2NvcGVzLnB1c2gocGx1Z2luLmRlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgWycnXSwge1xuICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgIGluZGV4YWJsZTogZmFsc2UsXG4gICAgYWxsS2V5czogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gIGNvbnN0IGRhdGFzZXRPcHRpb25zID0gKG9wdGlvbnMuZGF0YXNldHMgfHwge30pW3R5cGVdIHx8IHt9O1xuICByZXR1cm4gZGF0YXNldE9wdGlvbnMuaW5kZXhBeGlzIHx8IG9wdGlvbnMuaW5kZXhBeGlzIHx8IGRhdGFzZXREZWZhdWx0cy5pbmRleEF4aXMgfHwgJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgcmV0dXJuIHNjYWxlT3B0aW9ucy5heGlzIHx8IGF4aXNGcm9tUG9zaXRpb24oc2NhbGVPcHRpb25zLnBvc2l0aW9uKSB8fCBpZC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0RGVmYXVsdHMgPSBvdmVycmlkZXNbY29uZmlnLnR5cGVdIHx8IHtzY2FsZXM6IHt9fTtcbiAgY29uc3QgY29uZmlnU2NhbGVzID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcbiAgY29uc3QgZmlyc3RJRHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZik7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIGZpcnN0SURzW2F4aXNdID0gZmlyc3RJRHNbYXhpc10gfHwgaWQ7XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGZpcnN0SURzW2F4aXNdIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHNjYWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgbWVyZ2VJZihzY2FsZSwgW2RlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSwgZGVmYXVsdHMuc2NhbGVdKTtcbiAgfSk7XG4gIHJldHVybiBzY2FsZXM7XG59XG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcbiAgb3B0aW9ucy5wbHVnaW5zID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcbiAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XG4gIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAga2V5Q2FjaGUuc2V0KGNhY2hlS2V5LCBrZXlzKTtcbiAgICBrZXlzQ2FjaGVkLmFkZChrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKGRhdGFzZXRUeXBlLCB0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsXG4gICAgICAoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LmVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBwbHVnaW5TY29wZUtleXMocGx1Z2luKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHt0eXBlfS1wbHVnaW4tJHtpZH1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYHBsdWdpbnMuJHtpZH1gLFxuICAgICAgICAuLi5wbHVnaW4uYWRkaXRpb25hbE9wdGlvblNjb3BlcyB8fCBbXSxcbiAgICAgIF1dKTtcbiAgfVxuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgY2hhcnRPcHRpb25TY29wZXMoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LFxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IHByZWZpeGVzLmpvaW4oKTtcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghY2FjaGVkKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgY2FjaGVkID0ge1xuICAgICAgcmVzb2x2ZXIsXG4gICAgICBzdWJQcmVmaXhlczogcHJlZml4ZXMuZmlsdGVyKHAgPT4gIXAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaG92ZXInKSlcbiAgICB9O1xuICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkO1xufVxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjYyB8fCBpc0Z1bmN0aW9uKHZhbHVlW2tleV0pLCBmYWxzZSk7XG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgY29uc3Qgc2NyaXB0YWJsZSA9IGlzU2NyaXB0YWJsZShwcm9wKTtcbiAgICBjb25zdCBpbmRleGFibGUgPSBpc0luZGV4YWJsZShwcm9wKTtcbiAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgaWYgKChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpKVxuICAgICAgfHwgKGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIzLjkuMVwiO1xuXG5jb25zdCBLTk9XTl9QT1NJVElPTlMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICdjaGFydEFyZWEnXTtcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uLCBheGlzKSB7XG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IChLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jyk7XG59XG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJSZW5kZXInKTtcbiAgY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25Qcm9ncmVzcyhjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmNvbnN0IGluc3RhbmNlcyA9IHt9O1xuY29uc3QgZ2V0Q2hhcnQgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcyhrZXkpO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYykgPT4gYy5jYW52YXMgPT09IGNhbnZhcykucG9wKCk7XG59O1xuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NsaWNrKSB7XG4gICAgcmV0dXJuIGxhc3RFdmVudDtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmNsYXNzIENoYXJ0IHtcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChjb25maWcucGxhdGZvcm0gfHwgX2RldGVjdFBsYXRmb3JtKGluaXRpYWxDYW52YXMpKSgpO1xuICAgIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG4gICAgdGhpcy5pZCA9IHVpZCgpO1xuICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW107XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLl9wbHVnaW5zID0gbmV3IFBsdWdpblNlcnZpY2UoKTtcbiAgICB0aGlzLiRwcm94aWVzID0ge307XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb1Jlc2l6ZSA9IGRlYm91bmNlKG1vZGUgPT4gdGhpcy51cGRhdGUobW9kZSksIG9wdGlvbnMucmVzaXplRGVsYXkgfHwgMCk7XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiB7YXNwZWN0UmF0aW8sIG1haW50YWluQXNwZWN0UmF0aW99LCB3aWR0aCwgaGVpZ2h0LCBfYXNwZWN0UmF0aW99ID0gdGhpcztcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYXNwZWN0UmF0aW8pKSB7XG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmIChtYWludGFpbkFzcGVjdFJhdGlvICYmIF9hc3BlY3RSYXRpbykge1xuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlSW5pdCcpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGNsZWFyQ2FudmFzKHRoaXMuY2FudmFzLCB0aGlzLmN0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBhbmltYXRvci5zdG9wKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7d2lkdGgsIGhlaWdodH07XG4gICAgfVxuICB9XG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG4gICAgdGhpcy53aWR0aCA9IG5ld1NpemUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgaWYgKCFyZXRpbmFTY2FsZSh0aGlzLCBuZXdSYXRpbywgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNpemUnLCB7c2l6ZTogbmV3U2l6ZX0pO1xuICAgIGNhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFt0aGlzLCBuZXdTaXplXSwgdGhpcyk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICAgIGVhY2goc2NhbGVzT3B0aW9ucywgKGF4aXNPcHRpb25zLCBheGlzSUQpID0+IHtcbiAgICAgIGF4aXNPcHRpb25zLmlkID0gYXhpc0lEO1xuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuICAgIGlmIChzY2FsZU9wdHMpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuICAgICAgICBPYmplY3Qua2V5cyhzY2FsZU9wdHMpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBzY2FsZU9wdHNbaWRdO1xuICAgICAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgICAgIGNvbnN0IGlzUmFkaWFsID0gYXhpcyA9PT0gJ3InO1xuICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGF4aXMgPT09ICd4JztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczogc2NhbGVPcHRpb25zLFxuICAgICAgICAgICAgZHBvc2l0aW9uOiBpc1JhZGlhbCA/ICdjaGFydEFyZWEnIDogaXNIb3Jpem9udGFsID8gJ2JvdHRvbScgOiAnbGVmdCcsXG4gICAgICAgICAgICBkdHlwZTogaXNSYWRpYWwgPyAncmFkaWFsTGluZWFyJyA6IGlzSG9yaXpvbnRhbCA/ICdjYXRlZ29yeScgOiAnbGluZWFyJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBlYWNoKGl0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG4gICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG4gICAgICB1cGRhdGVkW2lkXSA9IHRydWU7XG4gICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgaWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xuICAgICAgICBzY2FsZSA9IHNjYWxlc1tpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY2FsZUNsYXNzID0gcmVnaXN0cnkuZ2V0U2NhbGUoc2NhbGVUeXBlKTtcbiAgICAgICAgc2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHlwZTogc2NhbGVUeXBlLFxuICAgICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgY2hhcnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcbiAgICAgIH1cbiAgICAgIHNjYWxlLmluaXQoc2NhbGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBlYWNoKHVwZGF0ZWQsIChoYXNVcGRhdGVkLCBpZCkgPT4ge1xuICAgICAgaWYgKCFoYXNVcGRhdGVkKSB7XG4gICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMuY29uZmlndXJlKHRoaXMsIHNjYWxlLCBzY2FsZS5vcHRpb25zKTtcbiAgICAgIGxheW91dHMuYWRkQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBjb25zdCBudW1EYXRhID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1NZXRhID0gbWV0YXNldHMubGVuZ3RoO1xuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBudW1EYXRhOyBpIDwgbnVtTWV0YTsgKytpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gbWV0YXNldHMuc2xpY2UoMCkuc29ydChjb21wYXJlMkxldmVsKCdvcmRlcicsICdpbmRleCcpKTtcbiAgfVxuICBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgY29uc3Qge19tZXRhc2V0czogbWV0YXNldHMsIGRhdGE6IHtkYXRhc2V0c319ID0gdGhpcztcbiAgICBpZiAobWV0YXNldHMubGVuZ3RoID4gZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RhY2tzO1xuICAgIH1cbiAgICBtZXRhc2V0cy5mb3JFYWNoKChtZXRhLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGRhdGFzZXRzLmZpbHRlcih4ID0+IHggPT09IG1ldGEuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xuICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuICAgICAgaWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XG4gICAgICBtZXRhLmluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgbWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcbiAgICAgIG1ldGEuaW5kZXggPSBpO1xuICAgICAgbWV0YS5sYWJlbCA9ICcnICsgZGF0YXNldC5sYWJlbDtcbiAgICAgIG1ldGEudmlzaWJsZSA9IHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKTtcbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YUVsZW1lbnRUeXBlKSxcbiAgICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGRhdGFzZXRFbGVtZW50VHlwZSAmJiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFzZXRFbGVtZW50VHlwZSlcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcywgaSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlTWV0YXNldHMoKTtcbiAgICByZXR1cm4gbmV3Q29udHJvbGxlcnM7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbmZpZy51cGRhdGUoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFuaW1zRGlzYWJsZWQgPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhb3B0aW9ucy5hbmltYXRpb247XG4gICAgdGhpcy5fdXBkYXRlU2NhbGVzKCk7XG4gICAgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCk7XG4gICAgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpO1xuICAgIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG4gICAgbGV0IG1pblBhZGRpbmcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3Qge2NvbnRyb2xsZXJ9ID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gIWFuaW1zRGlzYWJsZWQgJiYgbmV3Q29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSA9PT0gLTE7XG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG4gICAgaWYgKCFhbmltc0Rpc2FibGVkKSB7XG4gICAgICBlYWNoKG5ld0NvbnRyb2xsZXJzLCAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRGF0YXNldHMobW9kZSk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlclVwZGF0ZScsIHttb2RlfSk7XG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XG4gICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhfYWN0aXZlLCBfYWN0aXZlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuICAgIHRoaXMuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICB9XG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XG4gICAgaWYgKCFzZXRzRXF1YWwoZXhpc3RpbmdFdmVudHMsIG5ld0V2ZW50cykgfHwgISF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzICE9PSBvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XG4gICAgY29uc3Qge19oaWRkZW5JbmRpY2VzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgfVxuICB9XG4gIF9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB7XG4gICAgY29uc3QgX2RhdGFDaGFuZ2VzID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgaWYgKCFfZGF0YUNoYW5nZXMgfHwgIV9kYXRhQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxuICAgICAgX2RhdGFDaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjWzBdID09PSBpZHgpXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXG4gICAgKTtcbiAgICBjb25zdCBjaGFuZ2VTZXQgPSBtYWtlU2V0KDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YXNldENvdW50OyBpKyspIHtcbiAgICAgIGlmICghc2V0c0VxdWFsKGNoYW5nZVNldCwgbWFrZVNldChpKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShjaGFuZ2VTZXQpXG4gICAgICAubWFwKGMgPT4gYy5zcGxpdCgnLCcpKVxuICAgICAgLm1hcChhID0+ICh7bWV0aG9kOiBhWzFdLCBzdGFydDogK2FbMl0sIGNvdW50OiArYVszXX0pKTtcbiAgfVxuICBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVMYXlvdXQnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG5vQXJlYSA9IGFyZWEud2lkdGggPD0gMCB8fCBhcmVhLmhlaWdodCA8PSAwO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIGVhY2godGhpcy5ib3hlcywgKGJveCkgPT4ge1xuICAgICAgaWYgKG5vQXJlYSAmJiBib3gucG9zaXRpb24gPT09ICdjaGFydEFyZWEnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XG4gICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaXRlbS5faWR4ID0gaW5kZXg7XG4gICAgfSk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckxheW91dCcpO1xuICB9XG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24obW9kZSkgPyBtb2RlKHtkYXRhc2V0SW5kZXg6IGl9KSA6IG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7bW9kZX0pO1xuICB9XG4gIF91cGRhdGVEYXRhc2V0KGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7bWV0YSwgaW5kZXgsIG1vZGUsIGNhbmNlbGFibGU6IHRydWV9O1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWV0YS5jb250cm9sbGVyLl91cGRhdGUobW9kZSk7XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFuaW1hdG9yLmhhcyh0aGlzKSkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgICAgYW5pbWF0b3Iuc3RhcnQodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgb25BbmltYXRpb25zQ29tcGxldGUoe2NoYXJ0OiB0aGlzfSk7XG4gICAgfVxuICB9XG4gIGRyYXcoKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXc7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cbiAgICB0aGlzLl9kcmF3RGF0YXNldHMoKTtcbiAgICBmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRHJhdycpO1xuICB9XG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fc29ydGVkTWV0YXNldHM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzZXRzW2ldO1xuICAgICAgaWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1ldGEudmlzaWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XG4gIH1cbiAgX2RyYXdEYXRhc2V0cygpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c0RyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNEcmF3Jyk7XG4gIH1cbiAgX2RyYXdEYXRhc2V0KG1ldGEpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgICBjb25zdCB1c2VDbGlwID0gIWNsaXAuZGlzYWJsZWQ7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBtZXRhLFxuICAgICAgaW5kZXg6IG1ldGEuaW5kZXgsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgY2xpcEFyZWEoY3R4LCB7XG4gICAgICAgIGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gY2xpcC5sZWZ0LFxuICAgICAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyB0aGlzLndpZHRoIDogYXJlYS5yaWdodCArIGNsaXAucmlnaHQsXG4gICAgICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXG4gICAgICAgIGJvdHRvbTogY2xpcC5ib3R0b20gPT09IGZhbHNlID8gdGhpcy5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIGNsaXAuYm90dG9tXG4gICAgICB9KTtcbiAgICB9XG4gICAgbWV0YS5jb250cm9sbGVyLmRyYXcoKTtcbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgfVxuICBpc1BvaW50SW5BcmVhKHBvaW50KSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gIH1cbiAgZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBtb2RlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbWV0aG9kID0gSW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG4gICAgaWYgKCFtZXRhKSB7XG4gICAgICBtZXRhID0ge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgaGlkZGVuOiBudWxsLFxuICAgICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgICBvcmRlcjogZGF0YXNldCAmJiBkYXRhc2V0Lm9yZGVyIHx8IDAsXG4gICAgICAgIGluZGV4OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgIF9kYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICBfcGFyc2VkOiBbXSxcbiAgICAgICAgX3NvcnRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBtZXRhc2V0cy5wdXNoKG1ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XG4gIH1cbiAgZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkubGVuZ3RoO1xuICB9XG4gIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICFkYXRhc2V0LmhpZGRlbjtcbiAgfVxuICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XG4gIH1cbiAgdG9nZ2xlRGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuICBnZXREYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtb2RlID0gdmlzaWJsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IGFuaW1zID0gbWV0YS5jb250cm9sbGVyLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpO1xuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgYW5pbXMudXBkYXRlKG1ldGEsIHt2aXNpYmxlfSk7XG4gICAgICB0aGlzLnVwZGF0ZSgoY3R4KSA9PiBjdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgfVxuICBfc3RvcCgpIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUodGhpcyk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gdGhpcztcbiAgICB0aGlzLl9zdG9wKCk7XG4gICAgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCk7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnZGVzdHJveScpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgfVxuICB0b0Jhc2U2NEltYWdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKC4uLmFyZ3MpO1xuICB9XG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZSwgeCwgeSkgPT4ge1xuICAgICAgZS5vZmZzZXRYID0geDtcbiAgICAgIGUub2Zmc2V0WSA9IHk7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoZSk7XG4gICAgfTtcbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cbiAgYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGRldGFjaGVkO1xuICAgIGNvbnN0IGF0dGFjaGVkID0gKCkgPT4ge1xuICAgICAgX3JlbW92ZSgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG4gICAgZGV0YWNoZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICB0aGlzLl9yZXNpemUoMCwgMCk7XG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgIGF0dGFjaGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkKCk7XG4gICAgfVxuICB9XG4gIHVuYmluZEV2ZW50cygpIHtcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlSG92ZXJTdHlsZShpdGVtcywgbW9kZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHByZWZpeCA9IGVuYWJsZWQgPyAnc2V0JyA6ICdyZW1vdmUnO1xuICAgIGxldCBtZXRhLCBpdGVtLCBpLCBpbGVuO1xuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuICBfdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpIHtcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LmRhdGFzZXRJbmRleCA9PT0geS5kYXRhc2V0SW5kZXggJiYgeC5pbmRleCA9PT0geS5pbmRleCkpO1xuICAgIGNvbnN0IGRlYWN0aXZhdGVkID0gZGlmZihsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IGFjdGl2YXRlZCA9IHJlcGxheSA/IGFjdGl2ZSA6IGRpZmYoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgcmVwbGF5LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEoZSlcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgYXJncy5pbkNoYXJ0QXJlYSk7XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xuICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaXNDbGljayA9IF9pc0NsaWNrRXZlbnQoZSk7XG4gICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuICAgIGlmIChpbkNoYXJ0QXJlYSkge1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkNsaWNrLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5jb25zdCBpbnZhbGlkYXRlUGx1Z2lucyA9ICgpID0+IGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG5jb25zdCBlbnVtZXJhYmxlID0gdHJ1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYXJ0LCB7XG4gIGRlZmF1bHRzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZGVmYXVsdHNcbiAgfSxcbiAgaW5zdGFuY2VzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogaW5zdGFuY2VzXG4gIH0sXG4gIG92ZXJyaWRlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IG92ZXJyaWRlc1xuICB9LFxuICByZWdpc3RyeToge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IHJlZ2lzdHJ5XG4gIH0sXG4gIHZlcnNpb246IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiB2ZXJzaW9uXG4gIH0sXG4gIGdldENoYXJ0OiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZ2V0Q2hhcnRcbiAgfSxcbiAgcmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3Rlcjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xuICAgICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcbiAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ291dGVyU3RhcnQnLCAnb3V0ZXJFbmQnLCAnaW5uZXJTdGFydCcsICdpbm5lckVuZCddKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzJDEoYXJjLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGFuZ2xlRGVsdGEpIHtcbiAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICBjb25zdCBoYWxmVGhpY2tuZXNzID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gMjtcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogX2xpbWl0VmFsdWUoby5pbm5lclN0YXJ0LCAwLCBpbm5lckxpbWl0KSxcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXG4gIH07XG59XG5mdW5jdGlvbiByVGhldGFUb1hZKHIsIHRoZXRhLCB4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5mdW5jdGlvbiBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmQsIGNpcmN1bGFyKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSICsgc3BhY2luZyArIG9mZnNldCArIHBpeGVsTWFyZ2luIDogMDtcbiAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xuICBpZiAoc3BhY2luZykge1xuICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBhdk5vZ1NwYWNpbmdSYWRpdXMgPSAobm9TcGFjaW5nSW5uZXJSYWRpdXMgKyBub1NwYWNpbmdPdXRlclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyAoYWxwaGEgKiBhdk5vZ1NwYWNpbmdSYWRpdXMpIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcbiAgfVxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMkMShlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyU3RhcnQ7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyRW5kO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcbiAgICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlckVuZEFkanVzdGVkUmFkaXVzLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgICB9XG4gICAgY29uc3QgcDQgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGVuZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA0LngsIHA0LnkpO1xuICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICB9XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cyksIHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSwgdHJ1ZSk7XG4gICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cbiAgICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA4LngsIHA4LnkpO1xuICAgIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlclN0YXJ0LCBzdGFydEFuZ2xlIC0gSEFMRl9QSSwgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGNvbnN0IG91dGVyU3RhcnRYID0gTWF0aC5jb3Mob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyU3RhcnRZID0gTWF0aC5zaW4ob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJTdGFydFgsIG91dGVyU3RhcnRZKTtcbiAgICBjb25zdCBvdXRlckVuZFggPSBNYXRoLmNvcyhvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyRW5kWSA9IE1hdGguc2luKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlckVuZFgsIG91dGVyRW5kWSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuZnVuY3Rpb24gZHJhd0FyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIHN0YXJ0QW5nbGUgKyBUQVUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UgJSBUQVU7XG4gICAgICBpZiAoY2lyY3VtZmVyZW5jZSAlIFRBVSA9PT0gMCkge1xuICAgICAgICBlbmRBbmdsZSArPSBUQVU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5maWxsKCk7XG4gIHJldHVybiBlbmRBbmdsZTtcbn1cbmZ1bmN0aW9uIGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIGVsZW1lbnQsIGlubmVyKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgZnVsbENpcmNsZXN9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzIC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGVsZW1lbnQuaW5uZXJSYWRpdXMgKyBwaXhlbE1hcmdpbjtcbiAgbGV0IGk7XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIHN0YXJ0QW5nbGUgKyBUQVUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKSB7XG4gIGNvbnN0IHtvcHRpb25zfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IHtib3JkZXJXaWR0aCwgYm9yZGVySm9pblN0eWxlfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlubmVyID0gb3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcbiAgaWYgKCFib3JkZXJXaWR0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5uZXIpIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGggKiAyO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAncm91bmQnO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ2JldmVsJztcbiAgfVxuICBpZiAoZWxlbWVudC5mdWxsQ2lyY2xlcykge1xuICAgIGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIGVsZW1lbnQsIGlubmVyKTtcbiAgfVxuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5zdHJva2UoKTtcbn1cbmNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaXJjdW1mZXJlbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gMDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGluUmFuZ2UoY2hhcnRYLCBjaGFydFksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlLCBkaXN0YW5jZX0gPSBnZXRBbmdsZUZyb21Qb2ludChwb2ludCwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZSdcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCByQWRqdXN0ID0gdGhpcy5vcHRpb25zLnNwYWNpbmcgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBfaXNCZXR3ZWVuKGRpc3RhbmNlLCBpbm5lclJhZGl1cyArIHJBZGp1c3QsIG91dGVyUmFkaXVzICsgckFkanVzdCk7XG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3gnLFxuICAgICAgJ3knLFxuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnLFxuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMub2Zmc2V0IHx8IDApIC8gMjtcbiAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgY29uc3QgY2lyY3VsYXIgPSBvcHRpb25zLmNpcmN1bGFyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgbGV0IHJhZGl1c09mZnNldCA9IDA7XG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0IC8gMjtcbiAgICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQpO1xuICAgICAgaWYgKHRoaXMuY2lyY3VtZmVyZW5jZSA+PSBQSSkge1xuICAgICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuICAgIGRyYXdCb3JkZXIoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuQXJjRWxlbWVudC5pZCA9ICdhcmMnO1xuQXJjRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxuICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICBib3JkZXJKb2luU3R5bGU6IHVuZGVmaW5lZCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMixcbiAgb2Zmc2V0OiAwLFxuICBzcGFjaW5nOiAwLFxuICBhbmdsZTogdW5kZWZpbmVkLFxuICBjaXJjdWxhcjogdHJ1ZSxcbn07XG5BcmNFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcidcbn07XG5cbmZ1bmN0aW9uIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc3R5bGUgPSBvcHRpb25zKSB7XG4gIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xuICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaCwgb3B0aW9ucy5ib3JkZXJEYXNoKSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsIG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCk7XG4gIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xuICBjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDb2xvciwgb3B0aW9ucy5ib3JkZXJDb2xvcik7XG59XG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIGdldExpbmVNZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICB9XG4gIHJldHVybiBsaW5lVG87XG59XG5mdW5jdGlvbiBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge3N0YXJ0OiBwYXJhbXNTdGFydCA9IDAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxfSA9IHBhcmFtcztcbiAgY29uc3Qge3N0YXJ0OiBzZWdtZW50U3RhcnQsIGVuZDogc2VnbWVudEVuZH0gPSBzZWdtZW50O1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHBhcmFtc1N0YXJ0LCBzZWdtZW50U3RhcnQpO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xuICBjb25zdCBvdXRzaWRlID0gcGFyYW1zU3RhcnQgPCBzZWdtZW50U3RhcnQgJiYgcGFyYW1zRW5kIDwgc2VnbWVudFN0YXJ0IHx8IHBhcmFtc1N0YXJ0ID4gc2VnbWVudEVuZCAmJiBwYXJhbXNFbmQgPiBzZWdtZW50RW5kO1xuICByZXR1cm4ge1xuICAgIGNvdW50LFxuICAgIHN0YXJ0LFxuICAgIGxvb3A6IHNlZ21lbnQubG9vcCxcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIGxldCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgaSwgcG9pbnQsIHByZXY7XG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuICAgIHByZXYgPSBwb2ludDtcbiAgfVxuICBpZiAobG9vcCkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gIH1cbiAgcmV0dXJuICEhbG9vcDtcbn1cbmZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xuICBjb25zdCBwb2ludEluZGV4ID0gKGluZGV4KSA9PiAoc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgY29uc3QgZHJhd1ggPSAoKSA9PiB7XG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgfVxuICB9O1xuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KGkpXTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1goKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZEludGVycG9sYXRpb247XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cbiAgcmV0dXJuIF9wb2ludEluTGluZTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAobGluZS5wYXRoKHBhdGgsIHN0YXJ0LCBjb3VudCkpIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHNlZ21lbnRNZXRob2QoY3R4LCBsaW5lLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KSkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmNvbnN0IHVzZVBhdGgyRCA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cbmNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnVsbExvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFzZXRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUNvbnRyb2xQb2ludHMoY2hhcnRBcmVhLCBpbmRleEF4aXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICgob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykgJiYgIW9wdGlvbnMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xuICAgICAgY29uc3QgbG9vcCA9IG9wdGlvbnMuc3BhbkdhcHMgPyB0aGlzLl9sb29wIDogdGhpcy5fZnVsbExvb3A7XG4gICAgICBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyh0aGlzLl9wb2ludHMsIG9wdGlvbnMsIGNoYXJ0QXJlYSwgbG9vcCwgaW5kZXhBeGlzKTtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICBkZWxldGUgdGhpcy5fc2VnbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX3BhdGg7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuICBnZXQgc2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzIHx8ICh0aGlzLl9zZWdtZW50cyA9IF9jb21wdXRlU2VnbWVudHModGhpcywgdGhpcy5vcHRpb25zLnNlZ21lbnQpKTtcbiAgfVxuICBmaXJzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCAmJiBwb2ludHNbc2VnbWVudHNbMF0uc3RhcnRdO1xuICB9XG4gIGxhc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IGNvdW50ID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IF9pbnRlcnBvbGF0ZSA9IF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cbiAgcGF0aChjdHgsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgbGV0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb3VudCA9IGNvdW50IHx8ICh0aGlzLnBvaW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuICBkcmF3KGN0eCwgY2hhcnRBcmVhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBkcmF3KGN0eCwgdGhpcywgc3RhcnQsIGNvdW50KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuTGluZUVsZW1lbnQuaWQgPSAnbGluZSc7XG5MaW5lRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgYm9yZGVyRGFzaDogW10sXG4gIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgYm9yZGVyV2lkdGg6IDMsXG4gIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICBmaWxsOiBmYWxzZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxuICBzdGVwcGVkOiBmYWxzZSxcbiAgdGVuc2lvbjogMCxcbn07XG5MaW5lRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcbkxpbmVFbGVtZW50LmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCcsXG59O1xuXG5mdW5jdGlvbiBpblJhbmdlJDEoZWwsIHBvcywgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgY29uc3Qge1theGlzXTogdmFsdWV9ID0gZWwuZ2V0UHJvcHMoW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cbmNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNraXAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdG9wID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4gKChNYXRoLnBvdyhtb3VzZVggLSB4LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHksIDIpKSA8IE1hdGgucG93KG9wdGlvbnMuaGl0UmFkaXVzICsgb3B0aW9ucy5yYWRpdXMsIDIpKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWCwgJ3gnLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWSwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG4gIHNpemUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cbiAgZHJhdyhjdHgsIGFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLnNraXAgfHwgb3B0aW9ucy5yYWRpdXMgPCAwLjEgfHwgIV9pc1BvaW50SW5BcmVhKHRoaXMsIGFyZWEsIHRoaXMuc2l6ZShvcHRpb25zKSAvIDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG5Qb2ludEVsZW1lbnQuaWQgPSAncG9pbnQnO1xuUG9pbnRFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJXaWR0aDogMSxcbiAgaGl0UmFkaXVzOiAxLFxuICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICBob3ZlclJhZGl1czogNCxcbiAgcG9pbnRTdHlsZTogJ2NpcmNsZScsXG4gIHJhZGl1czogMyxcbiAgcm90YXRpb246IDBcbn07XG5Qb2ludEVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge3gsIHksIGJhc2UsIHdpZHRoLCBoZWlnaHR9ID0gYmFyLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xuICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICBoYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICB0b3AgPSB5IC0gaGFsZjtcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgfSBlbHNlIHtcbiAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICByaWdodCA9IHggKyBoYWxmO1xuICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICB9XG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gc2tpcCA/IDAgOiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aChiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBvID0gdG9UUkJMKHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3Qge2VuYWJsZUJvcmRlclJhZGl1c30gPSBiYXIuZ2V0UHJvcHMoWydlbmFibGVCb3JkZXJSYWRpdXMnXSk7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XG4gIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5sZWZ0LCBvLnRvcExlZnQsIDAsIG1heFIpLFxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgIGJvdHRvbVJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIG1heFIpXG4gIH07XG59XG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgY29uc3Qgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb25zdCByYWRpdXMgPSBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XG4gIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG4gIHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSlcblx0XHQmJiAoc2tpcFkgfHwgX2lzQmV0d2Vlbih5LCBib3VuZHMudG9wLCBib3VuZHMuYm90dG9tKSk7XG59XG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgY29uc3QgeSA9IHJlY3QueSAhPT0gcmVmUmVjdC55ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC54ICsgeCxcbiAgICB5OiByZWN0LnkgKyB5LFxuICAgIHc6IHJlY3QudyArIHcsXG4gICAgaDogcmVjdC5oICsgaCxcbiAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gIH07XG59XG5jbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtpbmZsYXRlQW1vdW50LCBvcHRpb25zOiB7Ym9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcn19ID0gdGhpcztcbiAgICBjb25zdCB7aW5uZXIsIG91dGVyfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgfVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50KSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBiYXNlLCBob3Jpem9udGFsfSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgIH07XG4gIH1cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuQmFyRWxlbWVudC5pZCA9ICdiYXInO1xuQmFyRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyU2tpcHBlZDogJ3N0YXJ0JyxcbiAgYm9yZGVyV2lkdGg6IDAsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgaW5mbGF0ZUFtb3VudDogJ2F1dG8nLFxuICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbn07XG5CYXJFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuXG52YXIgZWxlbWVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5BcmNFbGVtZW50OiBBcmNFbGVtZW50LFxuTGluZUVsZW1lbnQ6IExpbmVFbGVtZW50LFxuUG9pbnRFbGVtZW50OiBQb2ludEVsZW1lbnQsXG5CYXJFbGVtZW50OiBCYXJFbGVtZW50XG59KTtcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG4gIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzIC0gMjsgaSsrKSB7XG4gICAgbGV0IGF2Z1ggPSAwO1xuICAgIGxldCBhdmdZID0gMDtcbiAgICBsZXQgajtcbiAgICBjb25zdCBhdmdSYW5nZVN0YXJ0ID0gTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlRW5kID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDIpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VMZW5ndGggPSBhdmdSYW5nZUVuZCAtIGF2Z1JhbmdlU3RhcnQ7XG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG4gICAgbWF4QXJlYSA9IGFyZWEgPSAtMTtcbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IG1heEFyZWFQb2ludDtcbiAgICBhID0gbmV4dEE7XG4gIH1cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgeCA9IChwb2ludC54IC0geE1pbikgLyBkeCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgIHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHBvaW50LngpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGkgLSAxO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuICAgICAgZGVjaW1hdGVkLnB1c2gocG9pbnQpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgICAgbWluSW5kZXggPSBtYXhJbmRleCA9IHN0YXJ0SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge3ZhbHVlOiBkYXRhfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCkge1xuICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpID0+IHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbnZhciBwbHVnaW5fZGVjaW1hdGlvbiA9IHtcbiAgaWQ6ICdkZWNpbWF0aW9uJyxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuICAgIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7X2RhdGEsIGluZGV4QXhpc30gPSBkYXRhc2V0O1xuICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBjb25zdCBkYXRhID0gX2RhdGEgfHwgZGF0YXNldC5kYXRhO1xuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2hhcnQub3B0aW9ucy5wYXJzaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bGxPclVuZGVmKF9kYXRhKSkge1xuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFzZXQuX2RlY2ltYXRlZCA9IGRlY2ltYXRlZDtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKTtcbiAgICBjb25zdCBib3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcbiAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cykge1xuICAgICAgY29uc3Qgc3ViQm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIF9nZXRCb3VuZHMocHJvcGVydHksIGZpcnN0LCBsYXN0LCBsb29wKSB7XG4gIGlmIChsb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgbGV0IGVuZCA9IGxhc3RbcHJvcGVydHldO1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cbmZ1bmN0aW9uIF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpIHtcbiAgZm9yICg7ZW5kID4gc3RhcnQ7IGVuZC0tKSB7XG4gICAgY29uc3QgcG9pbnQgPSBwb2ludHNbZW5kXTtcbiAgICBpZiAoIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICBpZiAoYSAmJiBiKSB7XG4gICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICB9XG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xuICBsZXQgcG9pbnRzID0gW107XG4gIGxldCBfbG9vcCA9IGZhbHNlO1xuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICBfbG9vcCA9IHRydWU7XG4gICAgcG9pbnRzID0gYm91bmRhcnk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSk7XG4gIH1cbiAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xuICAgIHBvaW50cyxcbiAgICBvcHRpb25zOiB7dGVuc2lvbjogMH0sXG4gICAgX2xvb3AsXG4gICAgX2Z1bGxMb29wOiBfbG9vcFxuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlICYmIHNvdXJjZS5maWxsICE9PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG4gIGlmICghcHJvcGFnYXRlKSB7XG4gICAgcmV0dXJuIGZpbGw7XG4gIH1cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnZpc2libGUpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVGaWxsKGxpbmUsIGluZGV4LCBjb3VudCkge1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICByZXR1cm4gaXNOYU4oZmlsbC52YWx1ZSkgPyBmYWxzZSA6IGZpbGw7XG4gIH1cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG4gIGlmIChpc051bWJlckZpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGRlY29kZVRhcmdldEluZGV4KGZpbGxbMF0sIGluZGV4LCB0YXJnZXQsIGNvdW50KTtcbiAgfVxuICByZXR1cm4gWydvcmlnaW4nLCAnc3RhcnQnLCAnZW5kJywgJ3N0YWNrJywgJ3NoYXBlJ10uaW5kZXhPZihmaWxsKSA+PSAwICYmIGZpbGw7XG59XG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcbiAgbGV0IHBpeGVsID0gbnVsbDtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKGZpbGwudmFsdWUpO1xuICB9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQaXhlbCkge1xuICAgIHBpeGVsID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gIH1cbiAgcmV0dXJuIHBpeGVsO1xufVxuZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gIGxldCB2YWx1ZTtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0VmFsdWU7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLm9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBvcHRpb25zLmZpbGw7XG4gIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBmaWxsID0gISFvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgfVxuICBpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnb3JpZ2luJztcbiAgfVxuICByZXR1cm4gZmlsbDtcbn1cblxuZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChfY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKykge1xuICAgICAgYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludHNbal0sIGxpbmVzQmVsb3cpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExpbmVFbGVtZW50KHtwb2ludHMsIG9wdGlvbnM6IHt9fSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xuICBjb25zdCBiZWxvdyA9IFtdO1xuICBjb25zdCBtZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCdsaW5lJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgaWYgKG1ldGEuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFtZXRhLmhpZGRlbikge1xuICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmVsb3c7XG59XG5mdW5jdGlvbiBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50LCBsaW5lc0JlbG93KSB7XG4gIGNvbnN0IHBvc3Rwb25lZCA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzQmVsb3cubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNCZWxvd1tqXTtcbiAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHBvaW50fSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcbiAgICBpZiAoIXBvaW50IHx8IChmaXJzdCAmJiBsYXN0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdCkge1xuICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICBpZiAoIXBvaW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgIGlmIChfaXNCZXR3ZWVuKHBvaW50VmFsdWUsIGZpcnN0VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtmaXJzdCwgbGFzdCwgcG9pbnR9O1xufVxuXG5jbGFzcyBzaW1wbGVBcmMge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy54ID0gb3B0cy54O1xuICAgIHRoaXMueSA9IG9wdHMueTtcbiAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzO1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG4gIGlmIChpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgIHJldHVybiBnZXRMaW5lQnlJbmRleChjaGFydCwgZmlsbCk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICByZXR1cm4gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuICBpZiAoYm91bmRhcnkgaW5zdGFuY2VvZiBzaW1wbGVBcmMpIHtcbiAgICByZXR1cm4gYm91bmRhcnk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUgPSB7fSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IHBpeGVsID0gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKHBpeGVsKSkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcbiAgICAgIHk6IGhvcml6b250YWwgPyBudWxsIDogcGl4ZWxcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCB2YWx1ZSA9IF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnQpO1xuICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBzdGFydCk7XG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueSxcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kcmF3ZmlsbChjdHgsIHNvdXJjZSwgYXJlYSkge1xuICBjb25zdCB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IHtsaW5lLCBzY2FsZSwgYXhpc30gPSBzb3VyY2U7XG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgY29uc3QgY29sb3IgPSBsaW5lT3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XG4gIGlmICh0YXJnZXQgJiYgbGluZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICBkb0ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlLCBheGlzfSk7XG4gICAgdW5jbGlwQXJlYShjdHgpO1xuICB9XG59XG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcbiAgY3R4LnNhdmUoKTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcgJiYgYmVsb3cgIT09IGFib3ZlKSB7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLnRvcCk7XG4gICAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBhYm92ZSwgc2NhbGUsIHByb3BlcnR5fSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS5ib3R0b20pO1xuICB9XG4gIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYmVsb3csIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdFBvaW50ID0gcG9pbnRzW19maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpXTtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGNsaXBZKTtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgIH1cbiAgICBsaW5lTG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwge21vdmU6IGxpbmVMb29wfSk7XG4gICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8obGFzdFBvaW50LngsIGNsaXBZKTtcbiAgICB9XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIGZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuICBmb3IgKGNvbnN0IHtzb3VyY2U6IHNyYywgdGFyZ2V0OiB0Z3QsIHN0YXJ0LCBlbmR9IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0eWxlOiB7YmFja2dyb3VuZENvbG9yID0gY29sb3J9ID0ge319ID0gc3JjO1xuICAgIGNvbnN0IG5vdFNoYXBlID0gdGFyZ2V0ICE9PSB0cnVlO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCB0Z3QsIHttb3ZlOiBsaW5lTG9vcCwgcmV2ZXJzZTogdHJ1ZX0pO1xuICAgICAgbG9vcCA9IGxpbmVMb29wICYmIHRhcmdldExvb3A7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBzdGFydCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBib3VuZHMpIHtcbiAgY29uc3Qge3RvcCwgYm90dG9tfSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydCwgZW5kfSA9IGJvdW5kcyB8fCB7fTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnJlY3Qoc3RhcnQsIHRvcCwgZW5kIC0gc3RhcnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuXG52YXIgaW5kZXggPSB7XG4gIGlkOiAnZmlsbGVyJyxcbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuICAgICAgaWYgKGxpbmUgJiYgbGluZS5vcHRpb25zICYmIGxpbmUgaW5zdGFuY2VvZiBMaW5lRWxlbWVudCkge1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBmaWxsOiBfZGVjb2RlRmlsbChsaW5lLCBpLCBjb3VudCksXG4gICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgYXhpczogbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuaW5kZXhBeGlzLFxuICAgICAgICAgIHNjYWxlOiBtZXRhLnZTY2FsZSxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLmZpbGwgPSBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBvcHRpb25zLnByb3BhZ2F0ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKF9zaG91bGRBcHBseUZpbGwoc291cmNlKSkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0RHJhdyhjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuICAgIGlmICghX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICBkcmF3VGltZTogJ2JlZm9yZURhdGFzZXREcmF3J1xuICB9XG59O1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpID0+IHtcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XG4gIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgIGJveEhlaWdodCA9IE1hdGgubWluKGJveEhlaWdodCwgZm9udFNpemUpO1xuICAgIGJveFdpZHRoID0gbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCB8fCBNYXRoLm1pbihib3hXaWR0aCwgZm9udFNpemUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5jbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucztcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICB9XG4gIGJ1aWxkTGFiZWxzKCkge1xuICAgIGNvbnN0IGxhYmVsT3B0cyA9IHRoaXMub3B0aW9ucy5sYWJlbHMgfHwge307XG4gICAgbGV0IGxlZ2VuZEl0ZW1zID0gY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsT3B0cy5zb3J0KSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLnNvcnQoKGEsIGIpID0+IGxhYmVsT3B0cy5zb3J0KGEsIGIsIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY3R4fSA9IHRoaXM7XG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsT3B0cyA9IG9wdGlvbnMubGFiZWxzO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtib3hXaWR0aCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgd2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5fZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHdpZHRoID0gdGhpcy5fZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gTWF0aC5taW4od2lkdGgsIG9wdGlvbnMubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIG9wdGlvbnMubWF4SGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KTtcbiAgfVxuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQ6IDAsIHRvcCwgcm93LCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG4gIF9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICBsZXQgY3VycmVudENvbFdpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCBjb2wgPSAwO1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ICsgMiAqIHBhZGRpbmcgPiBoZWlnaHRMaW1pdCkge1xuICAgICAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgICAgICBsZWZ0ICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbCsrO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQsIHRvcDogY3VycmVudENvbEhlaWdodCwgY29sLCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTtcbiAgICByZXR1cm4gdG90YWxXaWR0aDtcbiAgfVxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY2xpcEFyZWEoY3R4LCB0aGlzKTtcbiAgICAgIHRoaXMuX2RyYXcoKTtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtjb2xvcjogZm9udENvbG9yLCBwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oJ2xlZnQnKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgW10pKTtcbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveEhlaWdodCAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBoYWxmRm9udFNpemU7XG4gICAgICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZLCBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoICYmIGJveFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHlCb3hUb3AgPSB5ICsgTWF0aC5tYXgoKGZvbnRTaXplIC0gYm94SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICBjb25zdCB4Qm94TGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHgsIGJveFdpZHRoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAobGluZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgY29uc3QgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IGxlZ2VuZEl0ZW0uaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBvdmVycmlkZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3IgfHwgZm9udENvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcbiAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG4gICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBwYWRkaW5nID4gdGhpcy5yaWdodCkge1xuICAgICAgICAgIHkgPSBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgICAgeCA9IGN1cnNvci54ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzW2N1cnNvci5saW5lXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGxpbmVIZWlnaHQgPiB0aGlzLmJvdHRvbSkge1xuICAgICAgICB4ID0gY3Vyc29yLnggPSB4ICsgY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLndpZHRoICsgcGFkZGluZztcbiAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgeSA9IGN1cnNvci55ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcbiAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgeCA9IF90ZXh0WCh0ZXh0QWxpZ24sIHggKyBib3hXaWR0aCArIGhhbGZGb250U2l6ZSwgaXNIb3Jpem9udGFsID8geCArIHdpZHRoIDogdGhpcy5yaWdodCwgb3B0cy5ydGwpO1xuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBjdXJzb3IueCArPSB3aWR0aCArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICB9XG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIGlmICghdGl0bGVPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgoLi4udGhpcy5saW5lV2lkdGhzKTtcbiAgICAgIHkgPSB0aGlzLnRvcCArIHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplO1xuICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIGxlZnQsIHRoaXMucmlnaHQgLSBtYXhXaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZU9wdHMudGV4dCwgeCwgeSwgdGl0bGVGb250KTtcbiAgfVxuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcbiAgfVxuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcbiAgICBpZiAoX2lzQmV0d2Vlbih4LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpXG4gICAgICAmJiBfaXNCZXR3ZWVuKHksIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKVxuICAgICAgICAgICYmIF9pc0JldHdlZW4oeSwgaGl0Qm94LnRvcCwgaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaG92ZXJlZEl0ZW0gPSB0aGlzLl9nZXRMZWdlbmRJdGVtQXQoZS54LCBlLnkpO1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsYmFjayhvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsYmFjayhvcHRzLm9uQ2xpY2ssIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIHBsdWdpbl9sZWdlbmQgPSB7XG4gIGlkOiAnbGVnZW5kJyxcbiAgX2VsZW1lbnQ6IExlZ2VuZCxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kID0gbmV3IExlZ2VuZCh7Y3R4OiBjaGFydC5jdHgsIG9wdGlvbnMsIGNoYXJ0fSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIGxlZ2VuZCk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgYWZ0ZXJVcGRhdGUoY2hhcnQpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgbGVnZW5kLmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICB3ZWlnaHQ6IDEwMDAsXG4gICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG4gICAgICBjb25zdCBjaSA9IGxlZ2VuZC5jaGFydDtcbiAgICAgIGlmIChjaS5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KSkge1xuICAgICAgICBjaS5oaWRlKGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2kuc2hvdyhpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcbiAgICAgICAgY29uc3Qge2xhYmVsczoge3VzZVBvaW50U3R5bGUsIHBvaW50U3R5bGUsIHRleHRBbGlnbiwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICByZXR1cm4gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpLm1hcCgobWV0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHVzZVBvaW50U3R5bGUgPyAwIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRvUGFkZGluZyhzdHlsZS5ib3JkZXJXaWR0aCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgIHRleHQ6ICcnLFxuICAgIH1cbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gICAgbGFiZWxzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFbJ2dlbmVyYXRlTGFiZWxzJywgJ2ZpbHRlcicsICdzb3J0J10uaW5jbHVkZXMobmFtZSksXG4gICAgfVxuICB9LFxufTtcblxuY2xhc3MgVGl0bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLl9wYWRkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSBtYXhXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplO1xuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gIH1cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIDAuNTtcbiAgICAgIH1cbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGhpcy5fZHJhd0FyZ3Mob2Zmc2V0KTtcbiAgICByZW5kZXJUZXh0KGN0eCwgb3B0cy50ZXh0LCAwLCAwLCBmb250T3B0cywge1xuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG52YXIgcGx1Z2luX3RpdGxlID0ge1xuICBpZDogJ3RpdGxlJyxcbiAgX2VsZW1lbnQ6IFRpdGxlLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjcmVhdGVUaXRsZShjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAyMDAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBwbHVnaW5fc3VidGl0bGUgPSB7XG4gIGlkOiAnc3VidGl0bGUnLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjaGFydFxuICAgIH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBtYXAuZ2V0KGNoYXJ0KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAxNTAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIGF2ZXJhZ2UoaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgIHggKz0gcG9zLng7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiB4IC8gY291bnQsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHggPSBldmVudFBvc2l0aW9uLng7XG4gICAgbGV0IHkgPSBldmVudFBvc2l0aW9uLnk7XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVhcmVzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICB4ID0gdHAueDtcbiAgICAgIHkgPSB0cC55O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZS5wdXNoKHRvUHVzaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlO1xufVxuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgb3B0aW9ucykge1xuICBjb25zdCBjdHggPSB0b29sdGlwLmNoYXJ0LmN0eDtcbiAgY29uc3Qge2JvZHksIGZvb3RlciwgdGl0bGV9ID0gdG9vbHRpcDtcbiAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHR9ID0gb3B0aW9ucztcbiAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gIGNvbnN0IGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgY29uc3QgdGl0bGVMaW5lQ291bnQgPSB0aXRsZS5sZW5ndGg7XG4gIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XG4gIGNvbnN0IGJvZHlMaW5lSXRlbUNvdW50ID0gYm9keS5sZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuICBsZXQgd2lkdGhQYWRkaW5nID0gMDtcbiAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG4gIH07XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG4gIHdpZHRoUGFkZGluZyA9IDA7XG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5yZXN0b3JlKCk7XG4gIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeSA8IGhlaWdodCAvIDIpIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH0gZWxzZSBpZiAoeSA+IChjaGFydC5oZWlnaHQgLSBoZWlnaHQgLyAyKSkge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfVxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbikge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3Qge3dpZHRoOiBjaGFydFdpZHRoLCBjaGFydEFyZWE6IHtsZWZ0LCByaWdodH19ID0gY2hhcnQ7XG4gIGxldCB4QWxpZ24gPSAnY2VudGVyJztcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG4gIHJldHVybiB4QWxpZ247XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3QgeUFsaWduID0gc2l6ZS55QWxpZ24gfHwgb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKSB7XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYXJldFNpemUsIGNhcmV0UGFkZGluZywgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSBhbGlnbm1lbnQ7XG4gIGNvbnN0IHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBfbGltaXRWYWx1ZSh4LCAwLCBjaGFydC53aWR0aCAtIHNpemUud2lkdGgpLFxuICAgIHk6IF9saW1pdFZhbHVlKHksIDAsIGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcENvbnRleHQocGFyZW50LCB0b29sdGlwLCB0b29sdGlwSXRlbXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdG9vbHRpcCxcbiAgICB0b29sdGlwSXRlbXMsXG4gICAgdHlwZTogJ3Rvb2x0aXAnXG4gIH0pO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gW107XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQgfHwgY29uZmlnLl9jaGFydDtcbiAgICB0aGlzLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iZWZvcmVCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFmdGVyQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvb3RlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgfVxuICBnZXRUaXRsZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gY2FsbGJhY2tzLmJlZm9yZVRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgY29uc3QgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBjb25zdCBhZnRlclRpdGxlID0gY2FsbGJhY2tzLmFmdGVyVGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XG4gIH1cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhzY29wZWQuYmVmb3JlTGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmxpbmVzLCBzY29wZWQubGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoc2NvcGVkLmFmdGVyTGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgYm9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5hZnRlckJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICB9XG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKHNjb3BlZC5sYWJlbENvbG9yLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKHNjb3BlZC5sYWJlbFBvaW50U3R5bGUuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFRleHRDb2xvcnMucHVzaChzY29wZWQubGFiZWxUZXh0Q29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cbiAgdXBkYXRlKGNoYW5nZWQsIHJlcGxheSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG4gICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcy5jaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgdGhpcy5jaGFydCk7XG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cbiAgZHJhd0NhcmV0KHRvb2x0aXBQb2ludCwgY3R4LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICB5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB4MyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIChjYXJldFNpemUpO1xuICAgICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyB3aWR0aCAtIE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHRoaXMuY2FyZXRYO1xuICAgICAgfVxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cbiAgZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMudGl0bGU7XG4gICAgY29uc3QgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xuICAgIGxldCB0aXRsZUZvbnQsIHRpdGxlU3BhY2luZywgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLnRpdGxlQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQodGl0bGVbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgdGl0bGVGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlU3BhY2luZztcbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLFxuICAgICAgICBwb2ludFN0eWxlOiBsYWJlbFBvaW50U3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgcm90YXRpb246IGxhYmVsUG9pbnRTdHlsZS5yb3RhdGlvbixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgIH07XG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gaXNPYmplY3QobGFiZWxDb2xvcnMuYm9yZGVyV2lkdGgpID8gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCkpIDogKGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoIHx8IDEpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvcnMuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsYWJlbENvbG9ycy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoIC0gYm94UGFkZGluZyk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSBib3hQYWRkaW5nIC0gMik7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxhYmVsQ29sb3JzLmJvcmRlclJhZGl1cyk7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBpbm5lclgsXG4gICAgICAgICAgeTogY29sb3JZICsgMSxcbiAgICAgICAgICB3OiBib3hXaWR0aCAtIDIsXG4gICAgICAgICAgaDogYm94SGVpZ2h0IC0gMixcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGlubmVyWCwgY29sb3JZICsgMSwgYm94V2lkdGggLSAyLCBib3hIZWlnaHQgLSAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG4gIGRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Ym9keX0gPSB0aGlzO1xuICAgIGNvbnN0IHtib2R5U3BhY2luZywgYm9keUFsaWduLCBkaXNwbGF5Q29sb3JzLCBib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgbGV0IGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBsZXQgeExpbmVQYWRkaW5nID0gMDtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICB9O1xuICAgIGNvbnN0IGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uID0gcnRsSGVscGVyLnRleHRBbGlnbihib2R5QWxpZ24pO1xuICAgIGxldCBib2R5SXRlbSwgdGV4dENvbG9yLCBsaW5lcywgaSwgaiwgaWxlbiwgamxlbjtcbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxuICAgICAgOiAwO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICBpZiAoZGlzcGxheUNvbG9ycyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucyk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoYm9keUZvbnQubGluZUhlaWdodCwgYm94SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgfVxuICAgIHhMaW5lUGFkZGluZyA9IDA7XG4gICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGVhY2godGhpcy5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICBwdC55IC09IGJvZHlTcGFjaW5nO1xuICB9XG4gIGRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvb3RlciA9IHRoaXMuZm9vdGVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZvb3Rlci5sZW5ndGg7XG4gICAgbGV0IGZvb3RlckZvbnQsIGk7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLmZvb3RlckFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IGZvb3RlckZvbnQubGluZUhlaWdodCArIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyB0b3BMZWZ0LCB5KTtcbiAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHRvcFJpZ2h0LCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHRvcFJpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBib3R0b21SaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBib3R0b21SaWdodCwgeSArIGhlaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgYm90dG9tTGVmdCwgeSArIGhlaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJvdHRvbUxlZnQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCwgeSArIHRvcExlZnQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyB0b3BMZWZ0LCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICAgIGNvbnN0IGhhc1Rvb2x0aXBDb250ZW50ID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG4gICAgaWYgKGNoYW5nZWQgfHwgcG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gZXZlbnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICBpZiAocmVwbGF5ICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5Ub29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnM7XG52YXIgcGx1Z2luX3Rvb2x0aXAgPSB7XG4gIGlkOiAndG9vbHRpcCcsXG4gIF9lbGVtZW50OiBUb29sdGlwLFxuICBwb3NpdGlvbmVycyxcbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIHJlc2V0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcbiAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLl93aWxsUmVuZGVyKCkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIHRvb2x0aXBcbiAgICAgIH07XG4gICAgICBpZiAoY2hhcnQubm90aWZ5UGx1Z2lucygnYmVmb3JlVG9vbHRpcERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG4gICAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclRvb2x0aXBEcmF3JywgYXJncyk7XG4gICAgfVxuICB9LFxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBiZWZvcmVUaXRsZTogbm9vcCxcbiAgICAgIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgICAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuICAgICAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHNbaXRlbS5kYXRhSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9LFxuICAgICAgYWZ0ZXJUaXRsZTogbm9vcCxcbiAgICAgIGJlZm9yZUJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVMYWJlbDogbm9vcCxcbiAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgcmV0dXJuIHRvb2x0aXBJdGVtLmxhYmVsICsgJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlIHx8IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYWJlbCA9IHRvb2x0aXBJdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG4gICAgICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgICB9LFxuICAgICAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFmdGVyTGFiZWw6IG5vb3AsXG4gICAgICBhZnRlckJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVGb290ZXI6IG5vb3AsXG4gICAgICBmb290ZXI6IG5vb3AsXG4gICAgICBhZnRlckZvb3Rlcjogbm9vcFxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lICE9PSAnaXRlbVNvcnQnICYmIG5hbWUgIT09ICdleHRlcm5hbCcsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJ1xuICAgIH1cbiAgfSxcbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuXG52YXIgcGx1Z2lucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkRlY2ltYXRpb246IHBsdWdpbl9kZWNpbWF0aW9uLFxuRmlsbGVyOiBpbmRleCxcbkxlZ2VuZDogcGx1Z2luX2xlZ2VuZCxcblN1YlRpdGxlOiBwbHVnaW5fc3VidGl0bGUsXG5UaXRsZTogcGx1Z2luX3RpdGxlLFxuVG9vbHRpcDogcGx1Z2luX3Rvb2x0aXBcbn0pO1xuXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSA9PiB7XG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIGluZGV4ID0gbGFiZWxzLnB1c2gocmF3KSAtIDE7XG4gICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7aW5kZXgsIGxhYmVsOiByYXd9KTtcbiAgfSBlbHNlIGlmIChpc05hTihyYXcpKSB7XG4gICAgaW5kZXggPSBudWxsO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XG4gIGNvbnN0IGZpcnN0ID0gbGFiZWxzLmluZGV4T2YocmF3KTtcbiAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKTtcbiAgfVxuICBjb25zdCBsYXN0ID0gbGFiZWxzLmxhc3RJbmRleE9mKHJhdyk7XG4gIHJldHVybiBmaXJzdCAhPT0gbGFzdCA/IGluZGV4IDogZmlyc3Q7XG59XG5jb25zdCB2YWxpZEluZGV4ID0gKGluZGV4LCBtYXgpID0+IGluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gIH1cbiAgaW5pdChzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBhZGRlZCA9IHRoaXMuX2FkZGVkTGFiZWxzO1xuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBmb3IgKGNvbnN0IHtpbmRleCwgbGFiZWx9IG9mIGFkZGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNbaW5kZXhdID09PSBsYWJlbCkge1xuICAgICAgICAgIGxhYmVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIH1cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSwgdGhpcy5fYWRkZWRMYWJlbHMpO1xuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGxhYmVscyA9IChtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChvZmZzZXQgPyAwLjUgOiAwKTtcbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhdGhpcy5fcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gIH1cbn1cbkNhdGVnb3J5U2NhbGUuaWQgPSAnY2F0ZWdvcnknO1xuQ2F0ZWdvcnlTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogQ2F0ZWdvcnlTY2FsZS5wcm90b3R5cGUuZ2V0TGFiZWxGb3JWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG4gIGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgIW1pbkRlZmluZWQgJiYgIW1heERlZmluZWQpIHtcbiAgICByZXR1cm4gW3t2YWx1ZTogcm1pbn0sIHt2YWx1ZTogcm1heH1dO1xuICB9XG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIHNwYWNpbmcgPSBuaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIH1cbiAgaWYgKCFpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcbiAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICB9XG4gIGlmIChib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICBuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgfSBlbHNlIHtcbiAgICBuaWNlTWluID0gcm1pbjtcbiAgICBuaWNlTWF4ID0gcm1heDtcbiAgfVxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcbiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBudW1TcGFjZXM7XG4gICAgbmljZU1pbiA9IG1pbjtcbiAgICBuaWNlTWF4ID0gbWF4O1xuICB9IGVsc2UgaWYgKGNvdW50RGVmaW5lZCkge1xuICAgIG5pY2VNaW4gPSBtaW5EZWZpbmVkID8gbWluIDogbmljZU1pbjtcbiAgICBuaWNlTWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IG5pY2VNYXg7XG4gICAgbnVtU3BhY2VzID0gY291bnQgLSAxO1xuICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gbnVtU3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuICAgIGlmIChhbG1vc3RFcXVhbHMobnVtU3BhY2VzLCBNYXRoLnJvdW5kKG51bVNwYWNlcyksIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBsZXQgaiA9IDA7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgaWYgKGluY2x1ZGVCb3VuZHMgJiYgbmljZU1pbiAhPT0gbWluKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWlufSk7XG4gICAgICBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICBpZiAoYWxtb3N0RXF1YWxzKE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yLCBtaW4sIHJlbGF0aXZlTGFiZWxTaXplKG1pbiwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG4gIGZvciAoOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3J9KTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCAmJiBpbmNsdWRlQm91bmRzICYmIG5pY2VNYXggIT09IG1heCkge1xuICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiByZWxhdGl2ZUxhYmVsU2l6ZSh2YWx1ZSwgbWluU3BhY2luZywge2hvcml6b250YWwsIG1pblJvdGF0aW9ufSkge1xuICBjb25zdCByYWQgPSB0b1JhZGlhbnMobWluUm90YXRpb24pO1xuICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xuICBjb25zdCBsZW5ndGggPSAwLjc1ICogbWluU3BhY2luZyAqICgnJyArIHZhbHVlKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLm1pbihtaW5TcGFjaW5nIC8gcmF0aW8sIGxlbmd0aCk7XG59XG5jbGFzcyBMaW5lYXJTY2FsZUJhc2UgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiArcmF3O1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcbiAgICBpZiAoYmVnaW5BdFplcm8pIHtcbiAgICAgIGNvbnN0IG1pblNpZ24gPSBzaWduKG1pbik7XG4gICAgICBjb25zdCBtYXhTaWduID0gc2lnbihtYXgpO1xuICAgICAgaWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG4gICAgICAgIHNldE1heCgwKTtcbiAgICAgIH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcbiAgICAgICAgc2V0TWluKDApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSAxO1xuICAgICAgaWYgKG1heCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBtaW4gPD0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5hYnMobWF4ICogMC4wNSk7XG4gICAgICB9XG4gICAgICBzZXRNYXgobWF4ICsgb2Zmc2V0KTtcbiAgICAgIGlmICghYmVnaW5BdFplcm8pIHtcbiAgICAgICAgc2V0TWluKG1pbiAtIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQge21heFRpY2tzTGltaXQsIHN0ZXBTaXplfSA9IHRpY2tPcHRzO1xuICAgIGxldCBtYXhUaWNrcztcbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG4gICAgaWYgKG1heFRpY2tzTGltaXQpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4VGlja3M7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgbGV0IG1heFRpY2tzID0gdGhpcy5nZXRUaWNrTGltaXQoKTtcbiAgICBtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcbiAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgIG1heFRpY2tzLFxuICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICBpbmNsdWRlQm91bmRzOiB0aWNrT3B0cy5pbmNsdWRlQm91bmRzICE9PSBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MkMShudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgZGF0YVJhbmdlKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSBlbmQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuXG5jbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpID8gbWF4IDogMTtcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuTGluZWFyU2NhbGUuaWQgPSAnbGluZWFyJztcbkxpbmVhclNjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XG4gIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWwgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpKSk7XG4gIHJldHVybiByZW1haW4gPT09IDE7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgZW5kRXhwID0gTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWF4KSk7XG4gIGNvbnN0IGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGxldCB0aWNrVmFsID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1pbikpKSk7XG4gIGxldCBleHAgPSBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKTtcbiAgbGV0IHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih0aWNrVmFsIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gIGRvIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogdGlja1ZhbCwgbWFqb3I6IGlzTWFqb3IodGlja1ZhbCl9KTtcbiAgICArK3NpZ25pZmljYW5kO1xuICAgIGlmIChzaWduaWZpY2FuZCA9PT0gMTApIHtcbiAgICAgIHNpZ25pZmljYW5kID0gMTtcbiAgICAgICsrZXhwO1xuICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuICAgIH1cbiAgICB0aWNrVmFsID0gTWF0aC5yb3VuZChzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgfSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG4gIGNvbnN0IGxhc3RUaWNrID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdGlja1ZhbCk7XG4gIHRpY2tzLnB1c2goe3ZhbHVlOiBsYXN0VGljaywgbWFqb3I6IGlzTWFqb3IodGlja1ZhbCl9KTtcbiAgcmV0dXJuIHRpY2tzO1xufVxuY2xhc3MgTG9nYXJpdGhtaWNTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGNvbnN0IHZhbHVlID0gTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbcmF3LCBpbmRleF0pO1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpICYmIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgPyBNYXRoLm1heCgwLCBtaW4pIDogbnVsbDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgbWluID0gdGhpcy5taW47XG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgY29uc3QgZXhwID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHYpKSArIG0pO1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgc2V0TWF4KDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xuICAgICAgICBzZXRNYXgoZXhwKG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oZXhwKG1heCwgLTEpKTtcbiAgICB9XG4gICAgaWYgKG1heCA8PSAwKSB7XG4gICAgICBzZXRNYXgoZXhwKG1pbiwgKzEpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiBtaW4gPT09IGV4cCh0aGlzLm1pbiwgMCkpIHtcbiAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBtaW46IHRoaXMuX3VzZXJNaW4sXG4gICAgICBtYXg6IHRoaXMuX3VzZXJNYXhcbiAgICB9O1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgdGhpcyk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcwJ1xuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGxvZzEwKHRoaXMubWF4KSAtIGxvZzEwKHN0YXJ0KTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKTtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbn1cbkxvZ2FyaXRobWljU2NhbGUuaWQgPSAnbG9nYXJpdGhtaWMnO1xuTG9nYXJpdGhtaWNTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcbiAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcbiAgbGFiZWwgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsIDogW2xhYmVsXTtcbiAgcmV0dXJuIHtcbiAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxuICAgIGg6IGxhYmVsLmxlbmd0aCAqIGZvbnQubGluZUhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gIGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG4gICAgICBlbmQ6IHBvcyArIChzaXplIC8gMilcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgZW5kOiBwb3NcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuICBjb25zdCBvcmlnID0ge1xuICAgIGw6IHNjYWxlLmxlZnQgKyBzY2FsZS5fcGFkZGluZy5sZWZ0LFxuICAgIHI6IHNjYWxlLnJpZ2h0IC0gc2NhbGUuX3BhZGRpbmcucmlnaHQsXG4gICAgdDogc2NhbGUudG9wICsgc2NhbGUuX3BhZGRpbmcudG9wLFxuICAgIGI6IHNjYWxlLmJvdHRvbSAtIHNjYWxlLl9wYWRkaW5nLmJvdHRvbVxuICB9O1xuICBjb25zdCBsaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnKTtcbiAgY29uc3QgbGFiZWxTaXplcyA9IFtdO1xuICBjb25zdCBwYWRkaW5nID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBwb2ludExhYmVsT3B0cyA9IHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IHBvaW50TGFiZWxPcHRzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBvcHRzID0gcG9pbnRMYWJlbE9wdHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgcGFkZGluZ1tpXSA9IG9wdHMucGFkZGluZztcbiAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xuICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcbiAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xuICB9XG4gIHNjYWxlLnNldENlbnRlclBvaW50KFxuICAgIG9yaWcubCAtIGxpbWl0cy5sLFxuICAgIGxpbWl0cy5yIC0gb3JpZy5yLFxuICAgIG9yaWcudCAtIGxpbWl0cy50LFxuICAgIGxpbWl0cy5iIC0gb3JpZy5iXG4gICk7XG4gIHNjYWxlLl9wb2ludExhYmVsSXRlbXMgPSBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZyk7XG59XG5mdW5jdGlvbiB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZSwgaExpbWl0cywgdkxpbWl0cykge1xuICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpO1xuICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKGhMaW1pdHMuc3RhcnQgPCBvcmlnLmwpIHtcbiAgICB4ID0gKG9yaWcubCAtIGhMaW1pdHMuc3RhcnQpIC8gc2luO1xuICAgIGxpbWl0cy5sID0gTWF0aC5taW4obGltaXRzLmwsIG9yaWcubCAtIHgpO1xuICB9IGVsc2UgaWYgKGhMaW1pdHMuZW5kID4gb3JpZy5yKSB7XG4gICAgeCA9IChoTGltaXRzLmVuZCAtIG9yaWcucikgLyBzaW47XG4gICAgbGltaXRzLnIgPSBNYXRoLm1heChsaW1pdHMuciwgb3JpZy5yICsgeCk7XG4gIH1cbiAgaWYgKHZMaW1pdHMuc3RhcnQgPCBvcmlnLnQpIHtcbiAgICB5ID0gKG9yaWcudCAtIHZMaW1pdHMuc3RhcnQpIC8gY29zO1xuICAgIGxpbWl0cy50ID0gTWF0aC5taW4obGltaXRzLnQsIG9yaWcudCAtIHkpO1xuICB9IGVsc2UgaWYgKHZMaW1pdHMuZW5kID4gb3JpZy5iKSB7XG4gICAgeSA9ICh2TGltaXRzLmVuZCAtIG9yaWcuYikgLyBjb3M7XG4gICAgbGltaXRzLmIgPSBNYXRoLm1heChsaW1pdHMuYiwgb3JpZy5iICsgeSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgZXh0cmEgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykgLyAyO1xuICBjb25zdCBvdXRlckRpc3RhbmNlID0gc2NhbGUuZHJhd2luZ0FyZWE7XG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IG9wdHMucG9pbnRMYWJlbHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKF9ub3JtYWxpemVBbmdsZShwb2ludExhYmVsUG9zaXRpb24uYW5nbGUgKyBIQUxGX1BJKSkpO1xuICAgIGNvbnN0IHNpemUgPSBsYWJlbFNpemVzW2ldO1xuICAgIGNvbnN0IHkgPSB5Rm9yQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLnksIHNpemUuaCwgYW5nbGUpO1xuICAgIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcbiAgICBjb25zdCBsZWZ0ID0gbGVmdEZvclRleHRBbGlnbihwb2ludExhYmVsUG9zaXRpb24ueCwgc2l6ZS53LCB0ZXh0QWxpZ24pO1xuICAgIGl0ZW1zLnB1c2goe1xuICAgICAgeDogcG9pbnRMYWJlbFBvc2l0aW9uLngsXG4gICAgICB5LFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgbGVmdCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHJpZ2h0OiBsZWZ0ICsgc2l6ZS53LFxuICAgICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICByZXR1cm4gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9XG4gIHJldHVybiAncmlnaHQnO1xufVxuZnVuY3Rpb24gbGVmdEZvclRleHRBbGlnbih4LCB3LCBhbGlnbikge1xuICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHc7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAodyAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgIHkgLT0gKGggLyAyKTtcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgeSAtPSBoO1xuICB9XG4gIHJldHVybiB5O1xufVxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb2ludExhYmVsc319ID0gc2NhbGU7XG4gIGZvciAobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICBjb25zdCB7eCwgeSwgdGV4dEFsaWduLCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICBjb25zdCB7YmFja2Ryb3BDb2xvcn0gPSBvcHRzQXRJbmRleDtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYmFja2Ryb3BDb2xvcikpIHtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0c0F0SW5kZXguYm9yZGVyUmFkaXVzKTtcbiAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xuICAgICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICAgIGNvbnN0IGJhY2tkcm9wVG9wID0gdG9wIC0gcGFkZGluZy50b3A7XG4gICAgICBjb25zdCBiYWNrZHJvcFdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aDtcbiAgICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBiYWNrZHJvcExlZnQsXG4gICAgICAgICAgeTogYmFja2Ryb3BUb3AsXG4gICAgICAgICAgdzogYmFja2Ryb3BXaWR0aCxcbiAgICAgICAgICBoOiBiYWNrZHJvcEhlaWdodCxcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFJlY3QoYmFja2Ryb3BMZWZ0LCBiYWNrZHJvcFRvcCwgYmFja2Ryb3BXaWR0aCwgYmFja2Ryb3BIZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHh9ID0gc2NhbGU7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcbiAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gZ3JpZExpbmVPcHRzO1xuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQ7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cbmNsYXNzIFJhZGlhbExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnhDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpIC8gMik7XG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoIC0gcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgdyAvIDIgKyBwYWRkaW5nLmxlZnQpO1xuICAgIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBoIC8gMiArIHBhZGRpbmcudG9wKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDIpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6IDA7XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpXG4gICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cbiAgZ2V0SW5kZXhBbmdsZShpbmRleCkge1xuICAgIGNvbnN0IGFuZ2xlTXVsdGlwbGllciA9IFRBVSAvICh0aGlzLl9wb2ludExhYmVscy5sZW5ndGggfHwgMSk7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVBbmdsZShpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHRvUmFkaWFucyhzdGFydEFuZ2xlKSk7XG4gIH1cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG4gIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKGRpc3RhbmNlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiB0aGlzLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICB9XG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBvaW50TGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjcmVhdGVQb2ludExhYmVsQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHBvaW50TGFiZWwpO1xuICAgIH1cbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIsIGFkZGl0aW9uYWxBbmdsZSA9IDApIHtcbiAgICBjb25zdCBhbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJICsgYWRkaXRpb25hbEFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnhDZW50ZXIsXG4gICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnlDZW50ZXIsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuICBnZXRCYXNlUG9zaXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXggfHwgMCwgdGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0UG9pbnRMYWJlbFBvc2l0aW9uKGluZGV4KSB7XG4gICAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbaW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgfTtcbiAgfVxuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7YmFja2dyb3VuZENvbG9yLCBncmlkOiB7Y2lyY3VsYXJ9fSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBwYXRoUmFkaXVzTGluZSh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgY2lyY3VsYXIsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGRyYXdHcmlkKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2FuZ2xlTGluZXMsIGdyaWR9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xuICAgIGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGRyYXdQb2ludExhYmVscyh0aGlzLCBsYWJlbENvdW50KTtcbiAgICB9XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCAtIDEpKTtcbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBmb3IgKGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBhbmdsZUxpbmVzLnNldENvbnRleHQodGhpcy5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IG9wdHNBdEluZGV4O1xuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKG9wdHNBdEluZGV4LmJvcmRlckRhc2gpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHRoaXMubWluIDogdGhpcy5tYXgpO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge31cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICBsZXQgb2Zmc2V0LCB3aWR0aDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPT09IDAgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHRpY2tPcHRzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0udmFsdWUpO1xuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aWNrLmxhYmVsKS53aWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVuZGVyVGV4dChjdHgsIHRpY2subGFiZWwsIDAsIC1vZmZzZXQsIHRpY2tGb250LCB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd1RpdGxlKCkge31cbn1cblJhZGlhbExpbmVhclNjYWxlLmlkID0gJ3JhZGlhbExpbmVhcic7XG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcbiAgZGlzcGxheTogdHJ1ZSxcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuICBhbmdsZUxpbmVzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gIH0sXG4gIGdyaWQ6IHtcbiAgICBjaXJjdWxhcjogZmFsc2VcbiAgfSxcbiAgc3RhcnRBbmdsZTogMCxcbiAgdGlja3M6IHtcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gIH0sXG4gIHBvaW50TGFiZWxzOiB7XG4gICAgYmFja2Ryb3BDb2xvcjogdW5kZWZpbmVkLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHNpemU6IDEwXG4gICAgfSxcbiAgICBjYWxsYmFjayhsYWJlbCkge1xuICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH0sXG4gICAgcGFkZGluZzogNSxcbiAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgfVxufTtcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRSb3V0ZXMgPSB7XG4gICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xufTtcblJhZGlhbExpbmVhclNjYWxlLmRlc2NyaXB0b3JzID0ge1xuICBhbmdsZUxpbmVzOiB7XG4gICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgfVxufTtcblxuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcbmNvbnN0IFVOSVRTID0gKE9iamVjdC5rZXlzKElOVEVSVkFMUykpO1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3Qge3BhcnNlciwgcm91bmQsIGlzb1dlZWtkYXl9ID0gc2NhbGUuX3BhcnNlT3B0cztcbiAgbGV0IHZhbHVlID0gaW5wdXQ7XG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG4gIGlmICghaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyb3VuZCkge1xuICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSlcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXG4gICAgICA6IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgcm91bmQpO1xuICB9XG4gIHJldHVybiArdmFsdWU7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWFwID0ge307XG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgaSwgdmFsdWU7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChpbGVuID09PSAwIHx8ICFtYWpvclVuaXQpID8gdGlja3MgOiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpO1xufVxuY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICAgIHRoaXMuX3VuaXQgPSAnZGF5JztcbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMpIHtcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IGFkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcbiAgICBhZGFwdGVyLmluaXQob3B0cyk7XG4gICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3VuZHMgIT09ICd0aWNrcycgfHwgb3B0aW9ucy50aWNrcy5zb3VyY2UgIT09ICdsYWJlbHMnKSB7XG4gICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgdGltZXN0YW1wc1swXTtcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuICAgIHRoaXMuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyh0aGlzLCB0aWNrcy5sZW5ndGgsIHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XG4gICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXRBZnRlckF1dG9za2lwKSB7XG4gICAgICB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKHRpY2sgPT4gK3RpY2sudmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgaW5pdE9mZnNldHModGltZXN0YW1wcykge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICBmaXJzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMF0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gMSAtIGZpcnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSAodGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1sxXSkgLSBmaXJzdCkgLyAyO1xuICAgICAgfVxuICAgICAgbGFzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW5kID0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRpbWVzdGFtcHMubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgbGltaXQpO1xuICAgIGVuZCA9IF9saW1pdFZhbHVlKGVuZCwgMCwgbGltaXQpO1xuICAgIHRoaXMuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xuICB9XG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQodGltZU9wdHMuc3RlcFNpemUsIDEpO1xuICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgIGNvbnN0IGhhc1dlZWtkYXkgPSBpc051bWJlcih3ZWVrZGF5KSB8fCB3ZWVrZGF5ID09PSB0cnVlO1xuICAgIGNvbnN0IHRpY2tzID0ge307XG4gICAgbGV0IGZpcnN0ID0gbWluO1xuICAgIGxldCB0aW1lLCBjb3VudDtcbiAgICBpZiAoaGFzV2Vla2RheSkge1xuICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuICAgIH1cbiAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIGhhc1dlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gb3B0aW9ucy50aWNrcy5zb3VyY2UgPT09ICdkYXRhJyAmJiB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgZm9yICh0aW1lID0gZmlyc3QsIGNvdW50ID0gMDsgdGltZSA8IG1heDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpLCBjb3VudCsrKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG4gICAgaWYgKHRpbWUgPT09IG1heCB8fCBvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyB8fCBjb3VudCA9PT0gMSkge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aWNrcykuc29ydCgoYSwgYikgPT4gYSAtIGIpLm1hcCh4ID0+ICt4KTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuICAgICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBtYWpvclVuaXQgPSB0aGlzLl9tYWpvclVuaXQ7XG4gICAgY29uc3QgbWlub3JGb3JtYXQgPSB1bml0ICYmIGZvcm1hdHNbdW5pdF07XG4gICAgY29uc3QgbWFqb3JGb3JtYXQgPSBtYWpvclVuaXQgJiYgZm9ybWF0c1ttYWpvclVuaXRdO1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgY29uc3QgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuICAgIHJldHVybiBmb3JtYXR0ZXIgPyBjYWxsYmFjayhmb3JtYXR0ZXIsIFtsYWJlbCwgaW5kZXgsIHRpY2tzXSwgdGhpcykgOiBsYWJlbDtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6ICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbiksXG4gICAgICBoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXG4gICAgfTtcbiAgfVxuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcbiAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW2V4YW1wbGVUaW1lXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0TGFiZWxTaXplKGV4YW1wbGVMYWJlbCk7XG4gICAgY29uc3QgY2FwYWNpdHkgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gc2l6ZS53IDogdGhpcy5oZWlnaHQgLyBzaXplLmgpIC0gMTtcbiAgICByZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuICB9XG4gIGdldERhdGFUaW1lc3RhbXBzKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuZGF0YSB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBpZiAodGhpcy5fbm9ybWFsaXplZCAmJiBtZXRhcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChwYXJzZSh0aGlzLCBsYWJlbHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBub3JtYWxpemUodmFsdWVzKSB7XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuVGltZVNjYWxlLmlkID0gJ3RpbWUnO1xuVGltZVNjYWxlLmRlZmF1bHRzID0ge1xuICBib3VuZHM6ICdkYXRhJyxcbiAgYWRhcHRlcnM6IHt9LFxuICB0aW1lOiB7XG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICB1bml0OiBmYWxzZSxcbiAgICByb3VuZDogZmFsc2UsXG4gICAgaXNvV2Vla2RheTogZmFsc2UsXG4gICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBzb3VyY2U6ICdhdXRvJyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICBpdGVtcy5wdXNoKGN1cnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbmV4dCA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgIHByZXYgPSBpdGVtc1tpIC0gMV07XG4gICAgICBjdXJyID0gaXRlbXNbaV07XG4gICAgICBpZiAoTWF0aC5yb3VuZCgobmV4dCArIHByZXYpIC8gMikgIT09IGN1cnIpIHtcbiAgICAgICAgdGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cbiAgX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCB8fCBbXTtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXN0YW1wcyA9IGRhdGEubGVuZ3RoID8gZGF0YSA6IGxhYmVsO1xuICAgIH1cbiAgICB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCBkZWNpbWFsICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblRpbWVTZXJpZXNTY2FsZS5pZCA9ICd0aW1lc2VyaWVzJztcblRpbWVTZXJpZXNTY2FsZS5kZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxudmFyIHNjYWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkNhdGVnb3J5U2NhbGU6IENhdGVnb3J5U2NhbGUsXG5MaW5lYXJTY2FsZTogTGluZWFyU2NhbGUsXG5Mb2dhcml0aG1pY1NjYWxlOiBMb2dhcml0aG1pY1NjYWxlLFxuUmFkaWFsTGluZWFyU2NhbGU6IFJhZGlhbExpbmVhclNjYWxlLFxuVGltZVNjYWxlOiBUaW1lU2NhbGUsXG5UaW1lU2VyaWVzU2NhbGU6IFRpbWVTZXJpZXNTY2FsZVxufSk7XG5cbmNvbnN0IHJlZ2lzdGVyYWJsZXMgPSBbXG4gIGNvbnRyb2xsZXJzLFxuICBlbGVtZW50cyxcbiAgcGx1Z2lucyxcbiAgc2NhbGVzLFxuXTtcblxuZXhwb3J0IHsgQW5pbWF0aW9uLCBBbmltYXRpb25zLCBBcmNFbGVtZW50LCBCYXJDb250cm9sbGVyLCBCYXJFbGVtZW50LCBCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIEJ1YmJsZUNvbnRyb2xsZXIsIENhdGVnb3J5U2NhbGUsIENoYXJ0LCBEYXRhc2V0Q29udHJvbGxlciwgcGx1Z2luX2RlY2ltYXRpb24gYXMgRGVjaW1hdGlvbiwgRG9tUGxhdGZvcm0sIERvdWdobnV0Q29udHJvbGxlciwgRWxlbWVudCwgaW5kZXggYXMgRmlsbGVyLCBJbnRlcmFjdGlvbiwgcGx1Z2luX2xlZ2VuZCBhcyBMZWdlbmQsIExpbmVDb250cm9sbGVyLCBMaW5lRWxlbWVudCwgTGluZWFyU2NhbGUsIExvZ2FyaXRobWljU2NhbGUsIFBpZUNvbnRyb2xsZXIsIFBvaW50RWxlbWVudCwgUG9sYXJBcmVhQ29udHJvbGxlciwgUmFkYXJDb250cm9sbGVyLCBSYWRpYWxMaW5lYXJTY2FsZSwgU2NhbGUsIFNjYXR0ZXJDb250cm9sbGVyLCBwbHVnaW5fc3VidGl0bGUgYXMgU3ViVGl0bGUsIFRpY2tzLCBUaW1lU2NhbGUsIFRpbWVTZXJpZXNTY2FsZSwgcGx1Z2luX3RpdGxlIGFzIFRpdGxlLCBwbHVnaW5fdG9vbHRpcCBhcyBUb29sdGlwLCBhZGFwdGVycyBhcyBfYWRhcHRlcnMsIF9kZXRlY3RQbGF0Zm9ybSwgYW5pbWF0b3IsIGNvbnRyb2xsZXJzLCBlbGVtZW50cywgbGF5b3V0cywgcGx1Z2lucywgcmVnaXN0ZXJhYmxlcywgcmVnaXN0cnksIHNjYWxlcyB9O1xuIiwgImltcG9ydCB7Q2hhcnQsIHJlZ2lzdGVyYWJsZXN9IGZyb20gJy4uL2Rpc3QvY2hhcnQubWpzJztcblxuQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcyk7XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0O1xuIiwgImltcG9ydCBDaGFydCBmcm9tICdjaGFydC5qcy9hdXRvJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjaGFydCh7IGNhY2hlZERhdGEsIG9wdGlvbnMsIHR5cGUgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENoYXJ0KClcblxuICAgICAgICAgICAgdGhpcy4kd2lyZS4kb24oJ3VwZGF0ZUNoYXJ0RGF0YScsICh7IGRhdGEgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNoYXJ0ID0gdGhpcy5nZXRDaGFydCgpXG4gICAgICAgICAgICAgICAgY2hhcnQuZGF0YSA9IGRhdGFcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoJ3Jlc2l6ZScpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBBbHBpbmUuZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBBbHBpbmUuc3RvcmUoJ3RoZW1lJylcblxuICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDaGFydCgpLmRlc3Ryb3koKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRDaGFydCgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHdpbmRvd1xuICAgICAgICAgICAgICAgIC5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJylcbiAgICAgICAgICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQWxwaW5lLnN0b3JlKCd0aGVtZScpICE9PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENoYXJ0KCkuZGVzdHJveSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRDaGFydCgpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0Q2hhcnQ6IGZ1bmN0aW9uIChkYXRhID0gbnVsbCkge1xuICAgICAgICAgICAgQ2hhcnQuZGVmYXVsdHMuYW5pbWF0aW9uLmR1cmF0aW9uID0gMFxuXG4gICAgICAgICAgICBDaGFydC5kZWZhdWx0cy5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRDb21wdXRlZFN0eWxlKFxuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuYmFja2dyb3VuZENvbG9yRWxlbWVudCxcbiAgICAgICAgICAgICkuY29sb3JcblxuICAgICAgICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBnZXRDb21wdXRlZFN0eWxlKFxuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuYm9yZGVyQ29sb3JFbGVtZW50LFxuICAgICAgICAgICAgKS5jb2xvclxuXG4gICAgICAgICAgICBDaGFydC5kZWZhdWx0cy5ib3JkZXJDb2xvciA9IGJvcmRlckNvbG9yXG5cbiAgICAgICAgICAgIENoYXJ0LmRlZmF1bHRzLmNvbG9yID0gZ2V0Q29tcHV0ZWRTdHlsZShcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLnRleHRDb2xvckVsZW1lbnQsXG4gICAgICAgICAgICApLmNvbG9yXG5cbiAgICAgICAgICAgIENoYXJ0LmRlZmF1bHRzLmZvbnQuZmFtaWx5ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZm9udEZhbWlseVxuXG4gICAgICAgICAgICBDaGFydC5kZWZhdWx0cy5wbHVnaW5zLmxlZ2VuZC5sYWJlbHMuYm94V2lkdGggPSAxMlxuICAgICAgICAgICAgQ2hhcnQuZGVmYXVsdHMucGx1Z2lucy5sZWdlbmQucG9zaXRpb24gPSAnYm90dG9tJ1xuXG4gICAgICAgICAgICBjb25zdCBncmlkQ29sb3IgPSBnZXRDb21wdXRlZFN0eWxlKFxuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuZ3JpZENvbG9yRWxlbWVudCxcbiAgICAgICAgICAgICkuY29sb3JcblxuICAgICAgICAgICAgb3B0aW9ucyA/Pz0ge31cbiAgICAgICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPz89IDJcbiAgICAgICAgICAgIG9wdGlvbnMucG9pbnRCYWNrZ3JvdW5kQ29sb3IgPz89IGJvcmRlckNvbG9yXG4gICAgICAgICAgICBvcHRpb25zLnBvaW50SGl0UmFkaXVzID8/PSA0XG4gICAgICAgICAgICBvcHRpb25zLnBvaW50UmFkaXVzID8/PSAyXG4gICAgICAgICAgICBvcHRpb25zLnNjYWxlcyA/Pz0ge31cbiAgICAgICAgICAgIG9wdGlvbnMuc2NhbGVzLnggPz89IHt9XG4gICAgICAgICAgICBvcHRpb25zLnNjYWxlcy54LmdyaWQgPz89IHt9XG4gICAgICAgICAgICBvcHRpb25zLnNjYWxlcy54LmdyaWQuY29sb3IgPSBncmlkQ29sb3JcbiAgICAgICAgICAgIG9wdGlvbnMuc2NhbGVzLnguZ3JpZC5kaXNwbGF5ID8/PSBmYWxzZVxuICAgICAgICAgICAgb3B0aW9ucy5zY2FsZXMueC5ncmlkLmRyYXdCb3JkZXIgPz89IGZhbHNlXG4gICAgICAgICAgICBvcHRpb25zLnNjYWxlcy55ID8/PSB7fVxuICAgICAgICAgICAgb3B0aW9ucy5zY2FsZXMueS5ncmlkID8/PSB7fVxuICAgICAgICAgICAgb3B0aW9ucy5zY2FsZXMueS5ncmlkLmNvbG9yID0gZ3JpZENvbG9yXG4gICAgICAgICAgICBvcHRpb25zLnNjYWxlcy55LmdyaWQuZHJhd0JvcmRlciA/Pz0gZmFsc2VcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFydCh0aGlzLiRyZWZzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSA/PyBjYWNoZWREYXRhLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldENoYXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2hhcnQuZ2V0Q2hhcnQodGhpcy4kcmVmcy5jYW52YXMpXG4gICAgICAgIH0sXG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjtBQU1BLFNBQVMsT0FBTztBQUFDO0FBQ2pCLElBQU0sTUFBTyxXQUFXO0FBQ3RCLE1BQUksS0FBSztBQUNULFNBQU8sV0FBVztBQUNoQixXQUFPO0FBQUEsRUFDVDtBQUNGLEVBQUU7QUFDRixTQUFTLGNBQWMsT0FBTztBQUM1QixTQUFPLFVBQVUsUUFBUSxPQUFPLFVBQVU7QUFDNUM7QUFDQSxTQUFTLFFBQVEsT0FBTztBQUN0QixNQUFJLE1BQU0sV0FBVyxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ3pDLFdBQU87QUFBQSxFQUNUO0FBQ0EsUUFBTSxPQUFPLE9BQU8sVUFBVSxTQUFTLEtBQUssS0FBSztBQUNqRCxNQUFJLEtBQUssTUFBTSxHQUFHLENBQUMsTUFBTSxhQUFhLEtBQUssTUFBTSxFQUFFLE1BQU0sVUFBVTtBQUNqRSxXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsU0FBUyxPQUFP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TUFBTTtBQUFBLEVBQ04sS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsVUFBVTtBQUFBLEVBQ1YsWUFBWTtBQUFBLEVBQ1osU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsWUFBWTtBQUFBLEVBQ1osV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsYUFBYTtBQUFBLEVBQ2IsSUFBSTtBQUFBLEVBQ0osVUFBVTtBQUFBLEVBQ1YsT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1As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WUFBdEIsR0FBc0IsVUFBWTtBQUNsQyxvQkFBUSxPQUFPLEVBQUUsTUFBSyxlQUF0QixHQUFzQixhQUFlO0FBQ3JDLG9CQUFRLFFBQU8sTUFBZixHQUFlLElBQU0sQ0FBQztBQUN0QixvQkFBUSxPQUFPLEdBQUUsU0FBakIsR0FBaUIsT0FBUyxDQUFDO0FBQzNCLGNBQVEsT0FBTyxFQUFFLEtBQUssUUFBUTtBQUM5QixvQkFBUSxPQUFPLEVBQUUsTUFBSyxlQUF0QixHQUFzQixhQUFlO0FBRXJDLGFBQU8sSUFBSSxhQUFNLEtBQUssTUFBTSxRQUFRO0FBQUEsUUFDaEM7QUFBQSxRQUNBLE1BQU0sUUFBUTtBQUFBLFFBQ2Q7QUFBQSxNQUNKLENBQUM7QUFBQSxJQUNMO0FBQUEsSUFFQSxVQUFVLFdBQVk7QUFDbEIsYUFBTyxhQUFNLFNBQVMsS0FBSyxNQUFNLE1BQU07QUFBQSxJQUMzQztBQUFBLEVBQ0o7QUFDSjsiLAogICJuYW1lcyI6IFsiaW5kZXgiLCAic2V0IiwgImNhbGxiYWNrIiwgImFyZ3MiLCAiY29sb3IiLCAiX2Rlc2NyaXB0b3JzIiwgImNoYXJ0IiwgImluZGV4IiwgImRlZmF1bHRzIiwgInJlc29sdmUiLCAiZGVzY3JpcHRvcnMiLCAic2V0IiwgImdldENvbXB1dGVkU3R5bGUiLCAiY2hhcnQiLCAiZHJhdyIsICJmcm9tIiwgInRvIiwgImluZGV4IiwgInNjYWxlcyIsICJlbGVtZW50cyIsICJuYW1lcyIsICJpIiwgInZhbGlkSW5kZXgiLCAiY29sb3IiLCAicmVnaXN0cnkiLCAiaW5SYW5nZSIsICJsYXlvdXRzIiwgInBvc2l0aW9ucyIsICJkZXNjcmlwdG9ycyIsICJwbHVnaW5zIiwgInNldCIsICJhbmltYXRpb25PcHRpb25zIiwgImxpc3RlbmVyIiwgImFscGhhIiwgInNraXAiLCAiZmlsbCIsICJtYXAiLCAiY2FsbGJhY2siLCAicm91bmQiLCAiaW50ZXJwb2xhdGUiXQp9Cg==
