// node_modules/chart.js/dist/chunks/helpers.segment.mjs
function noop() {
}
var uid = function() {
  let id = 0;
  return function() {
    return id++;
  };
}();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source = sources[i];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, { merger: _mergerIf });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
var keyResolvers = {
  "": (v) => v,
  x: (o) => o.x,
  y: (o) => o.y
};
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return { lo, hi };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => table[index2][key] <= value : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = /* @__PURE__ */ new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set2.add(items[i]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(
        Math.min(
          _lookupByKey(_parsed, iScale.axis, min).lo,
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
        ),
        0,
        pointCount - 1
      );
    }
    if (maxDefined) {
      count = _limitValue(
        Math.max(
          _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
        ),
        start,
        pointCount
      ) - start;
    } else {
      count = pointCount - start;
    }
  }
  return { start, count };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
function index_esm(input) {
  return new Color(input);
}
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
};
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
});
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + yOffset, y - xOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "star":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      rad += QUARTER_PI;
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(
    flip ? previous.cp1x : previous.cp2x,
    flip ? previous.cp1y : previous.cp2y,
    flip ? target.cp2x : target.cp1x,
    flip ? target.cp2y : target.cp1y,
    target.x,
    target.y
  );
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = "";
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(
        target,
        prop,
        () => _resolveWithPrefixes(prop, prefixes, scopes, target)
      );
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(
        target,
        prop,
        () => _resolveWithContext(target, prop, receiver)
      );
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(
    Array.from(set2),
    [""],
    rootScopes,
    fallback,
    () => subGetTarget(resolver, prop, value)
  );
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(
        prev,
        point,
        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
        options.tension
      );
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle2 = (element) => window.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle2(el).getPropertyValue(property);
}
var positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return { x, y, box };
}
function getRelativePosition(evt, chart) {
  if ("native" in evt) {
    return evt;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle2(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle2(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle2(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = { x: p1.cp2x, y: p1.cp2y };
  const cp2 = { x: p2.cp1x, y: p2.cp1y };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return { start, end, loop, style: segment.style };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return { start, end };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({ start: start % count, end: (end - 1) % count, loop });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({ start: start % count, end: last % count, loop });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({ start: s % count, end: e % count, loop: l, style: st });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

// node_modules/chart.js/dist/chart.mjs
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
    const from2 = resolve([cfg.from, currentValue, to2]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to2]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({ res, rej });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var numbers = ["x", "y", "borderWidth", "radius", "tension"];
var colors = ["color", "borderColor", "backgroundColor"];
defaults.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
var animationOptions = Object.keys(defaults.animation);
defaults.describe("animation", {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
});
defaults.set("animations", {
  colors: {
    type: "color",
    properties: colors
  },
  numbers: {
    type: "number",
    properties: numbers
  }
});
defaults.describe("animations", {
  _fallback: "animation"
});
defaults.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (v) => v | 0
      }
    }
  }
});
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(
    parent,
    {
      active: false,
      dataset: void 0,
      datasetIndex: index2,
      index: index2,
      mode: "default",
      type: "dataset"
    }
  );
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, { mode });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return { sharedOptions, includeOptions };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(["_removeElements", start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(["_insertElements", start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
};
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return { start, end, reverse, top, bottom };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
BarController.id = "bar";
BarController.defaults = {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
};
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, { $shared: false });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
BubbleController.id = "bubble";
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return { ratioX, ratioY, offsetX, offsetY };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
DoughnutController.id = "doughnut";
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing"
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ": " + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
LineController.id = "line";
LineController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
};
LineController.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
PolarAreaController.id = "polarArea";
PolarAreaController.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};
var PieController = class extends DoughnutController {
};
PieController.id = "pie";
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
RadarController.id = "radar";
RadarController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
var Element = class {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.active = false;
    this.options = void 0;
    this.$animations = void 0;
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
Element.defaults = {};
Element.defaultRoutes = void 0;
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = { formatters };
defaults.set("scale", {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: false,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
defaults.route("scale.ticks", "color", "", "color");
defaults.route("scale.grid", "color", "", "borderColor");
defaults.route("scale.grid", "borderColor", "", "borderColor");
defaults.route("scale.title", "color", "", "color");
defaults.describe("scale", {
  _fallback: false,
  _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
  _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
});
defaults.describe("scales", {
  _fallback: "scale"
});
defaults.describe("scale.ticks", {
  _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
  _indexable: (name) => name !== "backdropPadding"
});
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return { titleX, titleY, maxWidth, rotation };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return { min, max };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(
        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))
      ));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndex.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color: color2,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign: tickTextAlign,
        textBaseline,
        translation: [x, y],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return { textAlign, x };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return { top: 0, left: this.left, bottom: chart.height, right: this.right };
    }
    if (position === "top" || position === "bottom") {
      return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine(
            { x: item.x1, y: item.y1 },
            { x: item.x2, y: item.y2 },
            item
          );
        }
        if (grid.drawTicks) {
          drawLine(
            { x: item.tx1, y: item.ty1 },
            { x: item.tx2, y: item.ty2 },
            {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            }
          );
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { grid } } = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = new Registry();
var ScatterController = class extends DatasetController {
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
ScatterController.id = "scatter";
ScatterController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(item) {
          return "(" + item.label + ", " + item.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PolarAreaController,
  PieController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapter = class {
  constructor(options) {
    this.options = options || {};
  }
  init(chartOptions) {
  }
  formats() {
    return abstract();
  }
  parse(value, format) {
    return abstract();
  }
  format(timestamp, format) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
};
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return { lo: start.lo, hi: end.hi };
      }
    }
  }
  return { lo: 0, hi: data.length - 1 };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({ element, datasetIndex, index: index2 });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
    const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({ element, datasetIndex, index: index2 });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{ element, datasetIndex, index: index2 }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({ element, datasetIndex, index: index2 });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({ element, datasetIndex, index: index2 });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({ element, datasetIndex: meta.index, index: index2 });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({ element: data[i], datasetIndex, index: i });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || { size: 0, count: 1 };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = { left: 0, top: 0, right: 0, bottom: 0 };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(
      layout.width || chartArea.w,
      layout.height || chartArea.h,
      getMargins(layout.horizontal, chartArea)
    );
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults.set("layout", {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ["height", "width"].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return { plugins: plugins2, localIds };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, { plugin, local: localIds[id] }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [""], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y") {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || { scales: {} };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = /* @__PURE__ */ Object.create(null);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(
      datasetType,
      () => [[
        `datasets.${datasetType}`,
        ""
      ]]
    );
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(
      `${datasetType}.transition.${transition}`,
      () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]
    );
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(
      `${datasetType}-${elementType}`,
      () => [[
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]]
    );
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(
      `${type}-plugin-${id}`,
      () => [[
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]]
    );
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      { type },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
    const result = { $shared: true };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "3.9.1";
var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
var Chart = class {
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error(
        "Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused."
      );
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = { width, height };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", { size: newSize });
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(
        Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        })
      );
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", { mode });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(
      _dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(","))
    );
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({ datasetIndex: i }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", { mode });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = { meta, index: index2, mode, cancelable: true };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({ chart: this });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, { visible });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins("destroy");
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
var invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
var enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const { x, y, startAngle, pixelMargin, fullCircles } = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
  const { options } = element;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.stroke();
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(["x", "y"], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
    ctx.restore();
  }
};
ArcElement.id = "arc";
ArcElement.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
};
ArcElement.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, { property, start: value, end: value });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
LineElement.id = "line";
LineElement.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
};
LineElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
};
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
PointElement.id = "point";
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return { left, top, right, bottom };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
BarElement.id = "bar";
BarElement.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
BarElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  LineElement,
  PointElement,
  BarElement
});
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs(
        (pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy)
      );
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", { value: data });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return { start, count };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return { property, start, end };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({ x: first.x, y });
      points.push({ x: last.x, y });
    } else if (x !== null) {
      points.push({ x, y: first.y });
      points.push({ x, y: last.y });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: { tension: 0 },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [index2];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({ points, options: {} });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return { first, last, point };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || { start: 0, end: TAU };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, { line, target, above, below, area, scale, axis });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, { line, target, color: above, scale, property });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, { line, target, color: below, scale, property });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({ width: currentColWidth, height: currentColHeight });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({ width: currentColWidth, height: currentColHeight });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { color: fontColor, padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
};
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return { width, height };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, { chart: this.chart, tooltip: this, replay });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return { x1, x2, x3, y1, y2, y3 };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({ chart, options });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop,
      beforeBody: noop,
      beforeLabel: noop,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop,
      afterBody: noop,
      beforeFooter: noop,
      footer: noop,
      afterFooter: noop
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({ index: index2, label: raw });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({ value });
    }
    return ticks;
  }
  getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
CategoryScale.id = "category";
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{ value: rmin }, { value: rmax }];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(
    _decimalPlaces(spacing),
    _decimalPlaces(niceMin)
  );
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({ value: min });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({ value: max });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({ value: niceMax });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
LinearScale.id = "linear";
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({ value: tickVal, major: isMajor(tickVal) });
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || exp === endExp && significand < endSignificand);
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({ value: lastTick, major: isMajor(tickVal) });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, 1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, 1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
LogarithmicScale.id = "logarithmic";
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(
    orig.l - limits.l,
    limits.r - orig.r,
    orig.t - limits.t,
    limits.b - orig.b
  );
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
    renderText(
      ctx,
      scale._pointLabels[i],
      x,
      y + plFont.lineHeight / 2,
      plFont,
      {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      }
    );
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [value, index2], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(this.getContext(index2 - 1));
          drawRadiusLine(this, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(
          -width / 2 - padding.left,
          -offset - tickFont.size / 2 - padding.top,
          width + padding.width,
          tickFont.size + padding.height
        );
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
RadialLinearScale.id = "radialLinear";
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
var INTERVALS = {
  millisecond: { common: true, size: 1, steps: 1e3 },
  second: { common: true, size: 1e3, steps: 60 },
  minute: { common: true, size: 6e4, steps: 60 },
  hour: { common: true, size: 36e5, steps: 24 },
  day: { common: true, size: 864e5, steps: 30 },
  week: { common: false, size: 6048e5, steps: 4 },
  month: { common: true, size: 2628e6, steps: 12 },
  quarter: { common: false, size: 7884e6, steps: 4 },
  year: { common: true, size: 3154e7 }
};
var UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map3[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return { min, max };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index2, ticks, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index2, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
TimeScale.id = "time";
TimeScale.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: false
    }
  }
};
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        { time: min, pos: 0 },
        { time: max, pos: 1 }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({ time: curr, pos: i / (ilen - 1) });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
TimeSeriesScale.id = "timeseries";
TimeSeriesScale.defaults = TimeScale.defaults;
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/chart.js/auto/auto.mjs
Chart.register(...registerables);
var auto_default = Chart;

// packages/widgets/resources/js/components/stats-overview/card/chart.js
function statsOverviewCardChart({ labels, values }) {
  return {
    chart: null,
    init: function() {
      this.initChart();
    },
    initChart: function() {
      return this.chart = new auto_default(this.$refs.canvas, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              data: values,
              backgroundColor: getComputedStyle(
                this.$refs.backgroundColorElement
              ).color,
              borderColor: getComputedStyle(
                this.$refs.borderColorElement
              ).color,
              borderWidth: 2,
              fill: "start",
              tension: 0.5
            }
          ]
        },
        options: {
          elements: {
            point: {
              radius: 0
            }
          },
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            x: {
              display: false
            },
            y: {
              display: false
            }
          },
          tooltips: {
            enabled: false
          }
        }
      });
    }
  };
}
export {
  statsOverviewCardChart as default
};
/*! Bundled license information:

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * @kurkle/color v0.2.1
   * https://github.com/kurkle/color#readme
   * (c) 2022 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chart.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5tanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2hhcnQubWpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9hdXRvL2F1dG8ubWpzIiwgIi4uLy4uLy4uLy4uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3N0YXRzLW92ZXJ2aWV3L2NhcmQvY2hhcnQuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qIVxuICogQ2hhcnQuanMgdjMuOS4xXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjIgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCB1aWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWQrKztcbiAgfTtcbn0oKSk7XG5mdW5jdGlvbiBpc051bGxPclVuZGVmKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodHlwZS5zbGljZSgwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc2xpY2UoLTYpID09PSAnQXJyYXldJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmNvbnN0IGlzTnVtYmVyRmluaXRlID0gKHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK3ZhbHVlKTtcbmZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cbmNvbnN0IHRvUGVyY2VudGFnZSA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiB2YWx1ZSAvIGRpbWVuc2lvbjtcbmNvbnN0IHRvRGltZW5zaW9uID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBkaW1lbnNpb25cbiAgICA6ICt2YWx1ZTtcbmZ1bmN0aW9uIGNhbGxiYWNrKGZuLCBhcmdzLCB0aGlzQXJnKSB7XG4gIGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZWFjaChsb29wYWJsZSwgZm4sIHRoaXNBcmcsIHJldmVyc2UpIHtcbiAgbGV0IGksIGxlbiwga2V5cztcbiAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XG4gICAgbGVuID0gbG9vcGFibGUubGVuZ3RoO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChsb29wYWJsZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfZWxlbWVudHNFcXVhbChhMCwgYTEpIHtcbiAgbGV0IGksIGlsZW4sIHYwLCB2MTtcbiAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcbiAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvbmUkMShzb3VyY2UpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lJDEpO1xuICB9XG4gIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBjb25zdCBrbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGsgPSAwO1xuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZSQxKHNvdXJjZVtrZXlzW2tdXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuZnVuY3Rpb24gX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lJDEoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbiAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1lcmdlSWYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXJJZihrZXksIHRhcmdldCwgc291cmNlKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xuICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZSQxKHN2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVwcmVjYXRlZChzY29wZSwgdmFsdWUsIHByZXZpb3VzLCBjdXJyZW50KSB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xuXHRcdFx0J1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCInICsgY3VycmVudCArICdcIiBpbnN0ZWFkJyk7XG4gIH1cbn1cbmNvbnN0IGtleVJlc29sdmVycyA9IHtcbiAgJyc6IHYgPT4gdixcbiAgeDogbyA9PiBvLngsXG4gIHk6IG8gPT4gby55XG59O1xuZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5mdW5jdGlvbiBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSB7XG4gIGNvbnN0IGtleXMgPSBfc3BsaXRLZXkoa2V5KTtcbiAgcmV0dXJuIG9iaiA9PiB7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgIGlmIChrID09PSAnJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9iaiAmJiBvYmpba107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59XG5mdW5jdGlvbiBfc3BsaXRLZXkoa2V5KSB7XG4gIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgbGV0IHRtcCA9ICcnO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICB0bXAgKz0gcGFydDtcbiAgICBpZiAodG1wLmVuZHNXaXRoKCdcXFxcJykpIHtcbiAgICAgIHRtcCA9IHRtcC5zbGljZSgwLCAtMSkgKyAnLic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh0bXApO1xuICAgICAgdG1wID0gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5jb25zdCBkZWZpbmVkID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuY29uc3Qgc2V0c0VxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBfaXNDbGlja0V2ZW50KGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdjb250ZXh0bWVudSc7XG59XG5cbmNvbnN0IFBJID0gTWF0aC5QSTtcbmNvbnN0IFRBVSA9IDIgKiBQSTtcbmNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5jb25zdCBJTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbmNvbnN0IFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG5jb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuY29uc3QgUVVBUlRFUl9QSSA9IFBJIC8gNDtcbmNvbnN0IFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcbmZ1bmN0aW9uIG5pY2VOdW0ocmFuZ2UpIHtcbiAgY29uc3Qgcm91bmRlZFJhbmdlID0gTWF0aC5yb3VuZChyYW5nZSk7XG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gIGNvbnN0IGZyYWN0aW9uID0gcmFuZ2UgLyBuaWNlUmFuZ2U7XG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAxOyBpIDwgc3FydDsgaSsrKSB7XG4gICAgaWYgKHZhbHVlICUgaSA9PT0gMCkge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSAvIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoc3FydCA9PT0gKHNxcnQgfCAwKSkge1xuICAgIHJlc3VsdC5wdXNoKHNxcnQpO1xuICB9XG4gIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhIC0gYikucG9wKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc051bWJlcihuKSB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5mdW5jdGlvbiBhbG1vc3RFcXVhbHMoeCwgeSwgZXBzaWxvbikge1xuICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcbn1cbmZ1bmN0aW9uIGFsbW9zdFdob2xlKHgsIGVwc2lsb24pIHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcbn1cbmZ1bmN0aW9uIF9zZXRNaW5BbmRNYXhCeUtleShhcnJheSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGFyZ2V0Lm1pbiA9IE1hdGgubWluKHRhcmdldC5taW4sIHZhbHVlKTtcbiAgICAgIHRhcmdldC5tYXggPSBNYXRoLm1heCh0YXJnZXQubWF4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAqIChQSSAvIDE4MCk7XG59XG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xuICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG5mdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4KSB7XG4gIGlmICghaXNOdW1iZXJGaW5pdGUoeCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSAxO1xuICBsZXQgcCA9IDA7XG4gIHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcbiAgICBlICo9IDEwO1xuICAgIHArKztcbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuICBjb25zdCBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcbiAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKGRpc3RhbmNlRnJvbVlDZW50ZXIsIGRpc3RhbmNlRnJvbVhDZW50ZXIpO1xuICBpZiAoYW5nbGUgPCAoLTAuNSAqIFBJKSkge1xuICAgIGFuZ2xlICs9IFRBVTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuZ2xlLFxuICAgIGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwdDEsIHB0Mikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xufVxuZnVuY3Rpb24gX2FuZ2xlRGlmZihhLCBiKSB7XG4gIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVBbmdsZShhKSB7XG4gIHJldHVybiAoYSAlIFRBVSArIFRBVSkgJSBUQVU7XG59XG5mdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydCwgZW5kLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGUpIHtcbiAgY29uc3QgYSA9IF9ub3JtYWxpemVBbmdsZShhbmdsZSk7XG4gIGNvbnN0IHMgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICBjb25zdCBlID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIGNvbnN0IGFuZ2xlVG9TdGFydCA9IF9ub3JtYWxpemVBbmdsZShzIC0gYSk7XG4gIGNvbnN0IGFuZ2xlVG9FbmQgPSBfbm9ybWFsaXplQW5nbGUoZSAtIGEpO1xuICBjb25zdCBzdGFydFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIHMpO1xuICBjb25zdCBlbmRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBlKTtcbiAgcmV0dXJuIGEgPT09IHMgfHwgYSA9PT0gZSB8fCAoc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlICYmIHMgPT09IGUpXG4gICAgfHwgKGFuZ2xlVG9TdGFydCA+IGFuZ2xlVG9FbmQgJiYgc3RhcnRUb0FuZ2xlIDwgZW5kVG9BbmdsZSk7XG59XG5mdW5jdGlvbiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWUpIHtcbiAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbn1cbmZ1bmN0aW9uIF9pc0JldHdlZW4odmFsdWUsIHN0YXJ0LCBlbmQsIGVwc2lsb24gPSAxZS02KSB7XG4gIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbihzdGFydCwgZW5kKSAtIGVwc2lsb24gJiYgdmFsdWUgPD0gTWF0aC5tYXgoc3RhcnQsIGVuZCkgKyBlcHNpbG9uO1xufVxuXG5mdW5jdGlvbiBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgY21wKSB7XG4gIGNtcCA9IGNtcCB8fCAoKGluZGV4KSA9PiB0YWJsZVtpbmRleF0gPCB2YWx1ZSk7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBtaWQ7XG4gIHdoaWxlIChoaSAtIGxvID4gMSkge1xuICAgIG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChjbXAobWlkKSkge1xuICAgICAgbG8gPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvLCBoaX07XG59XG5jb25zdCBfbG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUsIGxhc3QpID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBsYXN0XG4gICAgPyBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8PSB2YWx1ZVxuICAgIDogaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPCB2YWx1ZSk7XG5jb25zdCBfcmxvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlKSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPj0gdmFsdWUpO1xuZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzLCBtaW4sIG1heCkge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIHZhbHVlc1tzdGFydF0gPCBtaW4pIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiB2YWx1ZXNbZW5kIC0gMV0gPiBtYXgpIHtcbiAgICBlbmQtLTtcbiAgfVxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J107XG5mdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHtcbiAgICAgIGxpc3RlbmVyczogW2xpc3RlbmVyXVxuICAgIH1cbiAgfSk7XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMuZm9yRWFjaCgob2JqZWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBjb25zdCBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG4gIGlmICghc3R1Yikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgZGVsZXRlIGFycmF5W2tleV07XG4gIH0pO1xuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5mdW5jdGlvbiBfYXJyYXlVbmlxdWUoaXRlbXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNldC5hZGQoaXRlbXNbaV0pO1xuICB9XG4gIGlmIChzZXQuc2l6ZSA9PT0gaWxlbikge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuXG5mdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5jb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuZnVuY3Rpb24gdGhyb3R0bGVkKGZuLCB0aGlzQXJnLCB1cGRhdGVGbikge1xuICBjb25zdCB1cGRhdGVBcmdzID0gdXBkYXRlRm4gfHwgKChhcmdzKSA9PiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKSk7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG4gIGxldCBhcmdzID0gW107XG4gIHJldHVybiBmdW5jdGlvbiguLi5yZXN0KSB7XG4gICAgYXJncyA9IHVwZGF0ZUFyZ3MocmVzdCk7XG4gICAgaWYgKCF0aWNraW5nKSB7XG4gICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG59XG5jb25zdCBfdG9MZWZ0UmlnaHRDZW50ZXIgPSAoYWxpZ24pID0+IGFsaWduID09PSAnc3RhcnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuY29uc3QgX2FsaWduU3RhcnRFbmQgPSAoYWxpZ24sIHN0YXJ0LCBlbmQpID0+IGFsaWduID09PSAnc3RhcnQnID8gc3RhcnQgOiBhbGlnbiA9PT0gJ2VuZCcgPyBlbmQgOiAoc3RhcnQgKyBlbmQpIC8gMjtcbmNvbnN0IF90ZXh0WCA9IChhbGlnbiwgbGVmdCwgcmlnaHQsIHJ0bCkgPT4ge1xuICBjb25zdCBjaGVjayA9IHJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IF9saW1pdFZhbHVlKE1hdGgubWluKFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1pbikubG8sXG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksXG4gICAgICAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKE1hdGgubWF4KFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCwgdHJ1ZSkuaGkgKyAxLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyAwIDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWF4KSwgdHJ1ZSkuaGkgKyAxKSxcbiAgICAgIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuZnVuY3Rpb24gX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZSwgX3NjYWxlUmFuZ2VzfSA9IG1ldGE7XG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICB4bWluOiB4U2NhbGUubWluLFxuICAgIHhtYXg6IHhTY2FsZS5tYXgsXG4gICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICB5bWF4OiB5U2NhbGUubWF4XG4gIH07XG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XG4gICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2hhbmdlZCA9IF9zY2FsZVJhbmdlcy54bWluICE9PSB4U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXhcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWF4ICE9PSB5U2NhbGUubWF4O1xuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbmNvbnN0IGF0RWRnZSA9ICh0KSA9PiB0ID09PSAwIHx8IHQgPT09IDE7XG5jb25zdCBlbGFzdGljSW4gPSAodCwgcywgcCkgPT4gLShNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSk7XG5jb25zdCBlbGFzdGljT3V0ID0gKHQsIHMsIHApID0+IE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApICsgMTtcbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogdCA9PiB0LFxuICBlYXNlSW5RdWFkOiB0ID0+IHQgKiB0LFxuICBlYXNlT3V0UXVhZDogdCA9PiAtdCAqICh0IC0gMiksXG4gIGVhc2VJbk91dFF1YWQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSksXG4gIGVhc2VJbkN1YmljOiB0ID0+IHQgKiB0ICogdCxcbiAgZWFzZU91dEN1YmljOiB0ID0+ICh0IC09IDEpICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRDdWJpYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMiksXG4gIGVhc2VJblF1YXJ0OiB0ID0+IHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWFydDogdCA9PiAtKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSksXG4gIGVhc2VJbk91dFF1YXJ0OiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSxcbiAgZWFzZUluUXVpbnQ6IHQgPT4gdCAqIHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWludDogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRRdWludDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpLFxuICBlYXNlSW5TaW5lOiB0ID0+IC1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuICBlYXNlT3V0U2luZTogdCA9PiBNYXRoLnNpbih0ICogSEFMRl9QSSksXG4gIGVhc2VJbk91dFNpbmU6IHQgPT4gLTAuNSAqIChNYXRoLmNvcyhQSSAqIHQpIC0gMSksXG4gIGVhc2VJbkV4cG86IHQgPT4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSksXG4gIGVhc2VPdXRFeHBvOiB0ID0+ICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxLFxuICBlYXNlSW5PdXRFeHBvOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41XG4gICAgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKVxuICAgIDogMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKyAyKSxcbiAgZWFzZUluQ2lyYzogdCA9PiAodCA+PSAxKSA/IHQgOiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSksXG4gIGVhc2VPdXRDaXJjOiB0ID0+IE1hdGguc3FydCgxIC0gKHQgLT0gMSkgKiB0KSxcbiAgZWFzZUluT3V0Q2lyYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSlcbiAgICA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcbiAgZWFzZUluRWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY0luKHQsIDAuMDc1LCAwLjMpLFxuICBlYXNlT3V0RWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY091dCh0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZUluT3V0RWxhc3RpYyh0KSB7XG4gICAgY29uc3QgcyA9IDAuMTEyNTtcbiAgICBjb25zdCBwID0gMC40NTtcbiAgICByZXR1cm4gYXRFZGdlKHQpID8gdCA6XG4gICAgICB0IDwgMC41XG4gICAgICAgID8gMC41ICogZWxhc3RpY0luKHQgKiAyLCBzLCBwKVxuICAgICAgICA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcbiAgfSxcbiAgZWFzZUluQmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG4gIGVhc2VPdXRCYWNrKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gKHQgLT0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9LFxuICBlYXNlSW5PdXRCYWNrKHQpIHtcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcbiAgfSxcbiAgZWFzZUluQm91bmNlOiB0ID0+IDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpLFxuICBlYXNlT3V0Qm91bmNlKHQpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcbiAgZWFzZUluT3V0Qm91bmNlOiB0ID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn07XG5cbi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4yLjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyMiBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gcm91bmQodikge1xuICByZXR1cm4gdiArIDAuNSB8IDA7XG59XG5jb25zdCBsaW0gPSAodiwgbCwgaCkgPT4gTWF0aC5tYXgoTWF0aC5taW4odiwgaCksIGwpO1xuZnVuY3Rpb24gcDJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMi41NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBuMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gYjJuKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2IC8gMi41NSkgLyAxMDAsIDAsIDEpO1xufVxuZnVuY3Rpb24gbjJwKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMTAwKSwgMCwgMTAwKTtcbn1cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuY29uc3QgSFVFX1JFID0gL14oaHNsYT98aHdifGhzdilcXChcXHMqKFstKy5lXFxkXSspKD86ZGVnKT9bXFxzLF0rKFstKy5lXFxkXSspJVtcXHMsXSsoWy0rLmVcXGRdKyklKD86W1xccyxdKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIGhzbDJyZ2JuKGgsIHMsIGwpIHtcbiAgY29uc3QgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDMwKSAlIDEyKSA9PiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcbiAgcmV0dXJuIFtmKDApLCBmKDgpLCBmKDQpXTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2JuKGgsIHMsIHYpIHtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gNjApICUgNikgPT4gdiAtIHYgKiBzICogTWF0aC5tYXgoTWF0aC5taW4oaywgNCAtIGssIDEpLCAwKTtcbiAgcmV0dXJuIFtmKDUpLCBmKDMpLCBmKDEpXTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2JuKGgsIHcsIGIpIHtcbiAgY29uc3QgcmdiID0gaHNsMnJnYm4oaCwgMSwgMC41KTtcbiAgbGV0IGk7XG4gIGlmICh3ICsgYiA+IDEpIHtcbiAgICBpID0gMSAvICh3ICsgYik7XG4gICAgdyAqPSBpO1xuICAgIGIgKj0gaTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcmdiW2ldICo9IDEgLSB3IC0gYjtcbiAgICByZ2JbaV0gKz0gdztcbiAgfVxuICByZXR1cm4gcmdiO1xufVxuZnVuY3Rpb24gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KSB7XG4gIGlmIChyID09PSBtYXgpIHtcbiAgICByZXR1cm4gKChnIC0gYikgLyBkKSArIChnIDwgYiA/IDYgOiAwKTtcbiAgfVxuICBpZiAoZyA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIChiIC0gcikgLyBkICsgMjtcbiAgfVxuICByZXR1cm4gKHIgLSBnKSAvIGQgKyA0O1xufVxuZnVuY3Rpb24gcmdiMmhzbCh2KSB7XG4gIGNvbnN0IHJhbmdlID0gMjU1O1xuICBjb25zdCByID0gdi5yIC8gcmFuZ2U7XG4gIGNvbnN0IGcgPSB2LmcgLyByYW5nZTtcbiAgY29uc3QgYiA9IHYuYiAvIHJhbmdlO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGxldCBoLCBzLCBkO1xuICBpZiAobWF4ICE9PSBtaW4pIHtcbiAgICBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICBoID0gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KTtcbiAgICBoID0gaCAqIDYwICsgMC41O1xuICB9XG4gIHJldHVybiBbaCB8IDAsIHMgfHwgMCwgbF07XG59XG5mdW5jdGlvbiBjYWxsbihmLCBhLCBiLCBjKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShhKVxuICAgICAgPyBmKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgICA6IGYoYSwgYiwgYylcbiAgKS5tYXAobjJiKTtcbn1cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgcywgbCkge1xuICByZXR1cm4gY2FsbG4oaHNsMnJnYm4sIGgsIHMsIGwpO1xufVxuZnVuY3Rpb24gaHdiMnJnYihoLCB3LCBiKSB7XG4gIHJldHVybiBjYWxsbihod2IycmdibiwgaCwgdywgYik7XG59XG5mdW5jdGlvbiBoc3YycmdiKGgsIHMsIHYpIHtcbiAgcmV0dXJuIGNhbGxuKGhzdjJyZ2JuLCBoLCBzLCB2KTtcbn1cbmZ1bmN0aW9uIGh1ZShoKSB7XG4gIHJldHVybiAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG59XG5mdW5jdGlvbiBodWVQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IEhVRV9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgdjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzVdICE9PSB2KSB7XG4gICAgYSA9IG1bNl0gPyBwMmIoK21bNV0pIDogbjJiKCttWzVdKTtcbiAgfVxuICBjb25zdCBoID0gaHVlKCttWzJdKTtcbiAgY29uc3QgcDEgPSArbVszXSAvIDEwMDtcbiAgY29uc3QgcDIgPSArbVs0XSAvIDEwMDtcbiAgaWYgKG1bMV0gPT09ICdod2InKSB7XG4gICAgdiA9IGh3YjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIGlmIChtWzFdID09PSAnaHN2Jykge1xuICAgIHYgPSBoc3YycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSB7XG4gICAgdiA9IGhzbDJyZ2IoaCwgcDEsIHAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHI6IHZbMF0sXG4gICAgZzogdlsxXSxcbiAgICBiOiB2WzJdLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZSh2LCBkZWcpIHtcbiAgdmFyIGggPSByZ2IyaHNsKHYpO1xuICBoWzBdID0gaHVlKGhbMF0gKyBkZWcpO1xuICBoID0gaHNsMnJnYihoKTtcbiAgdi5yID0gaFswXTtcbiAgdi5nID0gaFsxXTtcbiAgdi5iID0gaFsyXTtcbn1cbmZ1bmN0aW9uIGhzbFN0cmluZyh2KSB7XG4gIGlmICghdikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gcmdiMmhzbCh2KTtcbiAgY29uc3QgaCA9IGFbMF07XG4gIGNvbnN0IHMgPSBuMnAoYVsxXSk7XG4gIGNvbnN0IGwgPSBuMnAoYVsyXSk7XG4gIHJldHVybiB2LmEgPCAyNTVcbiAgICA/IGBoc2xhKCR7aH0sICR7c30lLCAke2x9JSwgJHtiMm4odi5hKX0pYFxuICAgIDogYGhzbCgke2h9LCAke3N9JSwgJHtsfSUpYDtcbn1cbmNvbnN0IG1hcCA9IHtcbiAgeDogJ2RhcmsnLFxuICBaOiAnbGlnaHQnLFxuICBZOiAncmUnLFxuICBYOiAnYmx1JyxcbiAgVzogJ2dyJyxcbiAgVjogJ21lZGl1bScsXG4gIFU6ICdzbGF0ZScsXG4gIEE6ICdlZScsXG4gIFQ6ICdvbCcsXG4gIFM6ICdvcicsXG4gIEI6ICdyYScsXG4gIEM6ICdsYXRlZycsXG4gIEQ6ICdpZ2h0cycsXG4gIFI6ICdpbicsXG4gIFE6ICd0dXJxdW9pcycsXG4gIEU6ICdoaScsXG4gIFA6ICdybycsXG4gIE86ICdhbCcsXG4gIE46ICdsZScsXG4gIE06ICdkZScsXG4gIEw6ICd5ZWxsbycsXG4gIEY6ICdlbicsXG4gIEs6ICdjaCcsXG4gIEc6ICdhcmtzJyxcbiAgSDogJ2VhJyxcbiAgSTogJ2lnaHRnJyxcbiAgSjogJ3doJ1xufTtcbmNvbnN0IG5hbWVzJDEgPSB7XG4gIE9pY2VYZTogJ2YwZjhmZicsXG4gIGFudGlxdWV3RXRlOiAnZmFlYmQ3JyxcbiAgYXF1YTogJ2ZmZmYnLFxuICBhcXVhbWFyUmU6ICc3ZmZmZDQnLFxuICBhenVZOiAnZjBmZmZmJyxcbiAgYmVpZ2U6ICdmNWY1ZGMnLFxuICBiaXNxdWU6ICdmZmU0YzQnLFxuICBibGFjazogJzAnLFxuICBibGFuS2VkT21vbmQ6ICdmZmViY2QnLFxuICBYZTogJ2ZmJyxcbiAgWGV2aVRldDogJzhhMmJlMicsXG4gIGJQd246ICdhNTJhMmEnLFxuICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICBjYU10WGU6ICc1ZjllYTAnLFxuICBLYXJ0WXVzZTogJzdmZmYwMCcsXG4gIEtvY1RhdGU6ICdkMjY5MWUnLFxuICBjU086ICdmZjdmNTAnLFxuICBjU25mbG93ZXJYZTogJzY0OTVlZCcsXG4gIGNTbnNpbGs6ICdmZmY4ZGMnLFxuICBjcmltc29uOiAnZGMxNDNjJyxcbiAgY3lhbjogJ2ZmZmYnLFxuICB4WGU6ICc4YicsXG4gIHhjeWFuOiAnOGI4YicsXG4gIHhnVE1uUGQ6ICdiODg2MGInLFxuICB4V2F5OiAnYTlhOWE5JyxcbiAgeGdZRjogJzY0MDAnLFxuICB4Z1l5OiAnYTlhOWE5JyxcbiAgeGtoYWtpOiAnYmRiNzZiJyxcbiAgeG1hZ0Z0YTogJzhiMDA4YicsXG4gIHhUaXZlZ1lGOiAnNTU2YjJmJyxcbiAgeFNhbmdlOiAnZmY4YzAwJyxcbiAgeFNjRWQ6ICc5OTMyY2MnLFxuICB4WWQ6ICc4YjAwMDAnLFxuICB4c09tb246ICdlOTk2N2EnLFxuICB4c0hnWUY6ICc4ZmJjOGYnLFxuICB4VVhlOiAnNDgzZDhiJyxcbiAgeFVXYXk6ICcyZjRmNGYnLFxuICB4VWdZeTogJzJmNGY0ZicsXG4gIHhRZTogJ2NlZDEnLFxuICB4dmlUZXQ6ICc5NDAwZDMnLFxuICBkQXBwUms6ICdmZjE0OTMnLFxuICBkQXBza3lYZTogJ2JmZmYnLFxuICBkaW1XYXk6ICc2OTY5NjknLFxuICBkaW1nWXk6ICc2OTY5NjknLFxuICBkb2RnZXJYZTogJzFlOTBmZicsXG4gIGZpWWJyaWNrOiAnYjIyMjIyJyxcbiAgZmxTT3dFdGU6ICdmZmZhZjAnLFxuICBmb1lzdFdBbjogJzIyOGIyMicsXG4gIGZ1S3NpYTogJ2ZmMDBmZicsXG4gIGdhUnNiU286ICdkY2RjZGMnLFxuICBnaG9zdHdFdGU6ICdmOGY4ZmYnLFxuICBnVGQ6ICdmZmQ3MDAnLFxuICBnVE1uUGQ6ICdkYWE1MjAnLFxuICBXYXk6ICc4MDgwODAnLFxuICBnWUY6ICc4MDAwJyxcbiAgZ1lGTHc6ICdhZGZmMmYnLFxuICBnWXk6ICc4MDgwODAnLFxuICBob25leU13OiAnZjBmZmYwJyxcbiAgaG90cFJrOiAnZmY2OWI0JyxcbiAgUmRpYW5ZZDogJ2NkNWM1YycsXG4gIFJkaWdvOiAnNGIwMDgyJyxcbiAgaXZTeTogJ2ZmZmZmMCcsXG4gIGtoYWtpOiAnZjBlNjhjJyxcbiAgbGF2Rk1yOiAnZTZlNmZhJyxcbiAgbGF2Rk1yWHNoOiAnZmZmMGY1JyxcbiAgbGF3bmdZRjogJzdjZmMwMCcsXG4gIE5tb25jRWZmb246ICdmZmZhY2QnLFxuICBaWGU6ICdhZGQ4ZTYnLFxuICBaY1NPOiAnZjA4MDgwJyxcbiAgWmN5YW46ICdlMGZmZmYnLFxuICBaZ1RNblBkTHc6ICdmYWZhZDInLFxuICBaV2F5OiAnZDNkM2QzJyxcbiAgWmdZRjogJzkwZWU5MCcsXG4gIFpnWXk6ICdkM2QzZDMnLFxuICBacFJrOiAnZmZiNmMxJyxcbiAgWnNPbW9uOiAnZmZhMDdhJyxcbiAgWnNIZ1lGOiAnMjBiMmFhJyxcbiAgWnNreVhlOiAnODdjZWZhJyxcbiAgWlVXYXk6ICc3Nzg4OTknLFxuICBaVWdZeTogJzc3ODg5OScsXG4gIFpzdEFsWGU6ICdiMGM0ZGUnLFxuICBaTHc6ICdmZmZmZTAnLFxuICBsaW1lOiAnZmYwMCcsXG4gIGxpbWVnWUY6ICczMmNkMzInLFxuICBsUkY6ICdmYWYwZTYnLFxuICBtYWdGdGE6ICdmZjAwZmYnLFxuICBtYVBvbjogJzgwMDAwMCcsXG4gIFZhcXVhbWFyUmU6ICc2NmNkYWEnLFxuICBWWGU6ICdjZCcsXG4gIFZTY0VkOiAnYmE1NWQzJyxcbiAgVnB1cnBOOiAnOTM3MGRiJyxcbiAgVnNIZ1lGOiAnM2NiMzcxJyxcbiAgVlVYZTogJzdiNjhlZScsXG4gIFZzcHJSZ2dZRjogJ2ZhOWEnLFxuICBWUWU6ICc0OGQxY2MnLFxuICBWdmlUZXRZZDogJ2M3MTU4NScsXG4gIG1pZG5pZ2h0WGU6ICcxOTE5NzAnLFxuICBtUnRjWWFtOiAnZjVmZmZhJyxcbiAgbWlzdHlQc2U6ICdmZmU0ZTEnLFxuICBtb2NjYXNSOiAnZmZlNGI1JyxcbiAgbmF2YWpvd0V0ZTogJ2ZmZGVhZCcsXG4gIG5hdnk6ICc4MCcsXG4gIFRkbGFjZTogJ2ZkZjVlNicsXG4gIFRpdmU6ICc4MDgwMDAnLFxuICBUaXZlZEJiOiAnNmI4ZTIzJyxcbiAgU2FuZ2U6ICdmZmE1MDAnLFxuICBTYW5nZVlkOiAnZmY0NTAwJyxcbiAgU2NFZDogJ2RhNzBkNicsXG4gIHBPZWdUTW5QZDogJ2VlZThhYScsXG4gIHBPZWdZRjogJzk4ZmI5OCcsXG4gIHBPZVFlOiAnYWZlZWVlJyxcbiAgcE9ldmlUZXRZZDogJ2RiNzA5MycsXG4gIHBhcGF5YXdFcDogJ2ZmZWZkNScsXG4gIHBIS3B1ZmY6ICdmZmRhYjknLFxuICBwZXJ1OiAnY2Q4NTNmJyxcbiAgcFJrOiAnZmZjMGNiJyxcbiAgcGx1bTogJ2RkYTBkZCcsXG4gIHBvd01yWGU6ICdiMGUwZTYnLFxuICBwdXJwTjogJzgwMDA4MCcsXG4gIFliZWNjYXB1cnBOOiAnNjYzMzk5JyxcbiAgWWQ6ICdmZjAwMDAnLFxuICBQc3licm93bjogJ2JjOGY4ZicsXG4gIFB5T1hlOiAnNDE2OWUxJyxcbiAgc2FkZE5iUHduOiAnOGI0NTEzJyxcbiAgc09tb246ICdmYTgwNzInLFxuICBzYW5keWJQd246ICdmNGE0NjAnLFxuICBzSGdZRjogJzJlOGI1NycsXG4gIHNIc2hlbGw6ICdmZmY1ZWUnLFxuICBzaUZuYTogJ2EwNTIyZCcsXG4gIHNpbHZlcjogJ2MwYzBjMCcsXG4gIHNreVhlOiAnODdjZWViJyxcbiAgVVhlOiAnNmE1YWNkJyxcbiAgVVdheTogJzcwODA5MCcsXG4gIFVnWXk6ICc3MDgwOTAnLFxuICBzbm93OiAnZmZmYWZhJyxcbiAgc3ByUmdnWUY6ICdmZjdmJyxcbiAgc3RBbFhlOiAnNDY4MmI0JyxcbiAgdGFuOiAnZDJiNDhjJyxcbiAgdGVPOiAnODA4MCcsXG4gIHRFc3ROOiAnZDhiZmQ4JyxcbiAgdG9tYXRvOiAnZmY2MzQ3JyxcbiAgUWU6ICc0MGUwZDAnLFxuICB2aVRldDogJ2VlODJlZScsXG4gIEpIdDogJ2Y1ZGViMycsXG4gIHdFdGU6ICdmZmZmZmYnLFxuICB3RXRlc21va2U6ICdmNWY1ZjUnLFxuICBMdzogJ2ZmZmYwMCcsXG4gIEx3Z1lGOiAnOWFjZDMyJ1xufTtcbmZ1bmN0aW9uIHVucGFjaygpIHtcbiAgY29uc3QgdW5wYWNrZWQgPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5hbWVzJDEpO1xuICBjb25zdCB0a2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gIGxldCBpLCBqLCBrLCBvaywgbms7XG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgb2sgPSBuayA9IGtleXNbaV07XG4gICAgZm9yIChqID0gMDsgaiA8IHRrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICBrID0gdGtleXNbal07XG4gICAgICBuayA9IG5rLnJlcGxhY2UoaywgbWFwW2tdKTtcbiAgICB9XG4gICAgayA9IHBhcnNlSW50KG5hbWVzJDFbb2tdLCAxNik7XG4gICAgdW5wYWNrZWRbbmtdID0gW2sgPj4gMTYgJiAweEZGLCBrID4+IDggJiAweEZGLCBrICYgMHhGRl07XG4gIH1cbiAgcmV0dXJuIHVucGFja2VkO1xufVxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5jb25zdCBSR0JfUkUgPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIHJnYlBhcnNlKHN0cikge1xuICBjb25zdCBtID0gUkdCX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCByLCBnLCBiO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bN10gIT09IHIpIHtcbiAgICBjb25zdCB2ID0gK21bN107XG4gICAgYSA9IG1bOF0gPyBwMmIodikgOiBsaW0odiAqIDI1NSwgMCwgMjU1KTtcbiAgfVxuICByID0gK21bMV07XG4gIGcgPSArbVszXTtcbiAgYiA9ICttWzVdO1xuICByID0gMjU1ICYgKG1bMl0gPyBwMmIocikgOiBsaW0ociwgMCwgMjU1KSk7XG4gIGcgPSAyNTUgJiAobVs0XSA/IHAyYihnKSA6IGxpbShnLCAwLCAyNTUpKTtcbiAgYiA9IDI1NSAmIChtWzZdID8gcDJiKGIpIDogbGltKGIsIDAsIDI1NSkpO1xuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJnYlN0cmluZyh2KSB7XG4gIHJldHVybiB2ICYmIChcbiAgICB2LmEgPCAyNTVcbiAgICAgID8gYHJnYmEoJHt2LnJ9LCAke3YuZ30sICR7di5ifSwgJHtiMm4odi5hKX0pYFxuICAgICAgOiBgcmdiKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0pYFxuICApO1xufVxuY29uc3QgdG8gPSB2ID0+IHYgPD0gMC4wMDMxMzA4ID8gdiAqIDEyLjkyIDogTWF0aC5wb3codiwgMS4wIC8gMi40KSAqIDEuMDU1IC0gMC4wNTU7XG5jb25zdCBmcm9tID0gdiA9PiB2IDw9IDAuMDQwNDUgPyB2IC8gMTIuOTIgOiBNYXRoLnBvdygodiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUocmdiMSwgcmdiMiwgdCkge1xuICBjb25zdCByID0gZnJvbShiMm4ocmdiMS5yKSk7XG4gIGNvbnN0IGcgPSBmcm9tKGIybihyZ2IxLmcpKTtcbiAgY29uc3QgYiA9IGZyb20oYjJuKHJnYjEuYikpO1xuICByZXR1cm4ge1xuICAgIHI6IG4yYih0byhyICsgdCAqIChmcm9tKGIybihyZ2IyLnIpKSAtIHIpKSksXG4gICAgZzogbjJiKHRvKGcgKyB0ICogKGZyb20oYjJuKHJnYjIuZykpIC0gZykpKSxcbiAgICBiOiBuMmIodG8oYiArIHQgKiAoZnJvbShiMm4ocmdiMi5iKSkgLSBiKSkpLFxuICAgIGE6IHJnYjEuYSArIHQgKiAocmdiMi5hIC0gcmdiMS5hKVxuICB9O1xufVxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluZGV4X2VzbShpbnB1dCkge1xuICByZXR1cm4gbmV3IENvbG9yKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IGluZGV4X2VzbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IGluZGV4X2VzbSh2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cblxuY29uc3Qgb3ZlcnJpZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGdldFNjb3BlJDEobm9kZSwga2V5KSB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgayA9IGtleXNbaV07XG4gICAgbm9kZSA9IG5vZGVba10gfHwgKG5vZGVba10gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgc2NvcGUpLCB2YWx1ZXMpO1xuICB9XG4gIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMpIHtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuYm9yZGVyQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmNvbG9yID0gJyM2NjYnO1xuICAgIHRoaXMuZGF0YXNldHMgPSB7fTtcbiAgICB0aGlzLmRldmljZVBpeGVsUmF0aW8gPSAoY29udGV4dCkgPT4gY29udGV4dC5jaGFydC5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgIHRoaXMuZXZlbnRzID0gW1xuICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAnbW91c2VvdXQnLFxuICAgICAgJ2NsaWNrJyxcbiAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICd0b3VjaG1vdmUnXG4gICAgXTtcbiAgICB0aGlzLmZvbnQgPSB7XG4gICAgICBmYW1pbHk6IFwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixcbiAgICAgIHNpemU6IDEyLFxuICAgICAgc3R5bGU6ICdub3JtYWwnLFxuICAgICAgbGluZUhlaWdodDogMS4yLFxuICAgICAgd2VpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmhvdmVyID0ge307XG4gICAgdGhpcy5ob3ZlckJhY2tncm91bmRDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJCb3JkZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcik7XG4gICAgdGhpcy5ob3ZlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmNvbG9yKTtcbiAgICB0aGlzLmluZGV4QXhpcyA9ICd4JztcbiAgICB0aGlzLmludGVyYWN0aW9uID0ge1xuICAgICAgbW9kZTogJ25lYXJlc3QnLFxuICAgICAgaW50ZXJzZWN0OiB0cnVlLFxuICAgICAgaW5jbHVkZUludmlzaWJsZTogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMubWFpbnRhaW5Bc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy5vbkhvdmVyID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xpY2sgPSBudWxsO1xuICAgIHRoaXMucGFyc2luZyA9IHRydWU7XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgdGhpcy5yZXNwb25zaXZlID0gdHJ1ZTtcbiAgICB0aGlzLnNjYWxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5zaG93TGluZSA9IHRydWU7XG4gICAgdGhpcy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRydWU7XG4gICAgdGhpcy5kZXNjcmliZShfZGVzY3JpcHRvcnMpO1xuICB9XG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICBnZXQoc2NvcGUpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGUkMSh0aGlzLCBzY29wZSk7XG4gIH1cbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQoZGVzY3JpcHRvcnMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgcm91dGUoc2NvcGUsIG5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKSB7XG4gICAgY29uc3Qgc2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgW3ByaXZhdGVOYW1lXToge1xuICAgICAgICB2YWx1ZTogc2NvcGVPYmplY3RbbmFtZV0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXNbcHJpdmF0ZU5hbWVdO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFNjb3BlT2JqZWN0W3RhcmdldE5hbWVdO1xuICAgICAgICAgIGlmIChpc09iamVjdChsb2NhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIGxvY2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KGxvY2FsLCB0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzW3ByaXZhdGVOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbnZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cyh7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdldmVudHMnLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuZnVuY3Rpb24gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuICBsZXQgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuICBpZiAoIXRleHRXaWR0aCkge1xuICAgIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgfVxuICBpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuICAgIGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LCBhcnJheU9mVGhpbmdzLCBjYWNoZSkge1xuICBjYWNoZSA9IGNhY2hlIHx8IHt9O1xuICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICBsZXQgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuICAgIGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG4gICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgIGNhY2hlLmZvbnQgPSBmb250O1xuICB9XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udDtcbiAgbGV0IGxvbmdlc3QgPSAwO1xuICBjb25zdCBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XG4gIGxldCBpLCBqLCBqbGVuLCB0aGluZywgbmVzdGVkVGhpbmc7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG4gICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgaWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbiAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICBpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG4gICAgICBkZWxldGUgZGF0YVtnY1tpXV07XG4gICAgfVxuICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIHdpZHRoKSB7XG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpIHtcbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHguc2F2ZSgpO1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgeCwgeSkge1xuICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCBudWxsKTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIHcpIHtcbiAgbGV0IHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cywgd2lkdGg7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgc3dpdGNoIChzdHlsZSkge1xuICBkZWZhdWx0OlxuICAgIGlmICh3KSB7XG4gICAgICBjdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgcmFkaXVzLCAwLCAwLCBUQVUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0cmlhbmdsZSc6XG4gICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgY3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgIGN0eC5hcmMoeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgY3R4LmFyYyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWN0JzpcbiAgICBpZiAoIXJvdGF0aW9uKSB7XG4gICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiBzaXplO1xuICAgICAgY3R4LnJlY3QoeCAtIHdpZHRoLCB5IC0gc2l6ZSwgMiAqIHdpZHRoLCAyICogc2l6ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ3JlY3RSb3QnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgY2FzZSAnY3Jvc3MnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnc3Rhcic6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnbGluZSc6XG4gICAgeE9mZnNldCA9IHcgPyB3IC8gMiA6IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnZGFzaCc6XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgYnJlYWs7XG4gIH1cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNQb2ludEluQXJlYShwb2ludCwgYXJlYSwgbWFyZ2luKSB7XG4gIG1hcmdpbiA9IG1hcmdpbiB8fCAwLjU7XG4gIHJldHVybiAhYXJlYSB8fCAocG9pbnQgJiYgcG9pbnQueCA+IGFyZWEubGVmdCAtIG1hcmdpbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIG1hcmdpbiAmJlxuXHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW4pO1xufVxuZnVuY3Rpb24gY2xpcEFyZWEoY3R4LCBhcmVhKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB1bmNsaXBBcmVhKGN0eCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRMaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwLCBtb2RlKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeCA6IHByZXZpb3VzLmNwMngsXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXkgOiBwcmV2aW91cy5jcDJ5LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeSA6IHRhcmdldC5jcDF5LFxuICAgIHRhcmdldC54LFxuICAgIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclRleHQoY3R4LCB0ZXh0LCB4LCB5LCBmb250LCBvcHRzID0ge30pIHtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KHRleHQpID8gdGV4dCA6IFt0ZXh0XTtcbiAgY29uc3Qgc3Ryb2tlID0gb3B0cy5zdHJva2VXaWR0aCA+IDAgJiYgb3B0cy5zdHJva2VDb2xvciAhPT0gJyc7XG4gIGxldCBpLCBsaW5lO1xuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cyk7XG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgfVxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcbiAgICB5ICs9IGZvbnQubGluZUhlaWdodDtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpIHtcbiAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcbiAgICBjdHgudHJhbnNsYXRlKG9wdHMudHJhbnNsYXRpb25bMF0sIG9wdHMudHJhbnNsYXRpb25bMV0pO1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ247XG4gIH1cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0cy5kZWNvcmF0aW9uV2lkdGggfHwgMjtcbiAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGNvbnN0IHt4LCB5LCB3LCBoLCByYWRpdXN9ID0gcmVjdDtcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLnRvcExlZnQsIHkgKyByYWRpdXMudG9wTGVmdCwgcmFkaXVzLnRvcExlZnQsIC1IQUxGX1BJLCBQSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCk7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cy50b3BMZWZ0LCB5KTtcbn1cblxuY29uc3QgTElORV9IRUlHSFQgPSBuZXcgUmVnRXhwKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcbmNvbnN0IEZPTlRfU1RZTEUgPSBuZXcgUmVnRXhwKC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvKTtcbmZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZSwgc2l6ZSkge1xuICBjb25zdCBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKExJTkVfSEVJR0hUKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XG4gICAgcmV0dXJuIHNpemUgKiAxLjI7XG4gIH1cbiAgdmFsdWUgPSArbWF0Y2hlc1syXTtcbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XG4gIGNhc2UgJ3B4JzpcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNhc2UgJyUnOlxuICAgIHZhbHVlIC89IDEwMDtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gc2l6ZSAqIHZhbHVlO1xufVxuY29uc3QgbnVtYmVyT3JaZXJvID0gdiA9PiArdiB8fCAwO1xuZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHByb3BzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qga2V5cyA9IG9ialByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSlcbiAgICA/IG9ialByb3BzXG4gICAgICA/IHByb3AgPT4gdmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSlcbiAgICAgIDogcHJvcCA9PiB2YWx1ZVtwcm9wXVxuICAgIDogKCkgPT4gdmFsdWU7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0b1RSQkwodmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCB7dG9wOiAneScsIHJpZ2h0OiAneCcsIGJvdHRvbTogJ3knLCBsZWZ0OiAneCd9KTtcbn1cbmZ1bmN0aW9uIHRvVFJCTENvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCddKTtcbn1cbmZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZSkge1xuICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpO1xuICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gdG9Gb250KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IGRlZmF1bHRzLmZvbnQ7XG4gIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gIH1cbiAgbGV0IHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zdHlsZSwgZmFsbGJhY2suc3R5bGUpO1xuICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcbiAgICBzdHlsZSA9ICcnO1xuICB9XG4gIGNvbnN0IGZvbnQgPSB7XG4gICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgc2l6ZSxcbiAgICBzdHlsZSxcbiAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgIHN0cmluZzogJydcbiAgfTtcbiAgZm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG4gIHJldHVybiBmb250O1xufVxuZnVuY3Rpb24gcmVzb2x2ZShpbnB1dHMsIGNvbnRleHQsIGluZGV4LCBpbmZvKSB7XG4gIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSBpbnB1dHNbaV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmZvICYmICFjYWNoZWFibGUpIHtcbiAgICAgICAgaW5mby5jYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGRHcmFjZShtaW5tYXgsIGdyYWNlLCBiZWdpbkF0WmVybykge1xuICBjb25zdCB7bWluLCBtYXh9ID0gbWlubWF4O1xuICBjb25zdCBjaGFuZ2UgPSB0b0RpbWVuc2lvbihncmFjZSwgKG1heCAtIG1pbikgLyAyKTtcbiAgY29uc3Qga2VlcFplcm8gPSAodmFsdWUsIGFkZCkgPT4gYmVnaW5BdFplcm8gJiYgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUgKyBhZGQ7XG4gIHJldHVybiB7XG4gICAgbWluOiBrZWVwWmVybyhtaW4sIC1NYXRoLmFicyhjaGFuZ2UpKSxcbiAgICBtYXg6IGtlZXBaZXJvKG1heCwgY2hhbmdlKVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChwYXJlbnRDb250ZXh0LCBjb250ZXh0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyA9IFsnJ10sIHJvb3RTY29wZXMgPSBzY29wZXMsIGZhbGxiYWNrLCBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF0pIHtcbiAgaWYgKCFkZWZpbmVkKGZhbGxiYWNrKSkge1xuICAgIGZhbGxiYWNrID0gX3Jlc29sdmUoJ19mYWxsYmFjaycsIHNjb3Blcyk7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSB7XG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdPYmplY3QnLFxuICAgIF9jYWNoZWFibGU6IHRydWUsXG4gICAgX3Njb3Blczogc2NvcGVzLFxuICAgIF9yb290U2NvcGVzOiByb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGUpID0+IF9jcmVhdGVSZXNvbHZlcihbc2NvcGUsIC4uLnNjb3Blc10sIHByZWZpeGVzLCByb290U2NvcGVzLCBmYWxsYmFjayksXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzO1xuICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuX3Njb3Blc1swXSwgcHJvcCk7XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHNjb3Blc1swXSk7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KS5pbmNsdWRlcyhwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7XG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0KHByb3h5LCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfYXR0YWNoQ29udGV4dChwcm94eS5vdmVycmlkZShzY29wZSksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgcHJveHlbcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5fZGVzY3JpcHRvcnMuYWxsS2V5c1xuICAgICAgICA/IFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKSA/IHtlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9IDogdW5kZWZpbmVkXG4gICAgICAgIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhwcm94eSwgZGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfSkge1xuICBjb25zdCB7X3NjcmlwdGFibGUgPSBkZWZhdWx0cy5zY3JpcHRhYmxlLCBfaW5kZXhhYmxlID0gZGVmYXVsdHMuaW5kZXhhYmxlLCBfYWxsS2V5cyA9IGRlZmF1bHRzLmFsbEtleXN9ID0gcHJveHk7XG4gIHJldHVybiB7XG4gICAgYWxsS2V5czogX2FsbEtleXMsXG4gICAgc2NyaXB0YWJsZTogX3NjcmlwdGFibGUsXG4gICAgaW5kZXhhYmxlOiBfaW5kZXhhYmxlLFxuICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpID0+IF9zY3JpcHRhYmxlLFxuICAgIGlzSW5kZXhhYmxlOiBpc0Z1bmN0aW9uKF9pbmRleGFibGUpID8gX2luZGV4YWJsZSA6ICgpID0+IF9pbmRleGFibGVcbiAgfTtcbn1cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4LCBuYW1lKSA9PiBwcmVmaXggPyBwcmVmaXggKyBfY2FwaXRhbGl6ZShuYW1lKSA6IG5hbWU7XG5jb25zdCBuZWVkc1N1YlJlc29sdmVyID0gKHByb3AsIHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcbmZ1bmN0aW9uIF9jYWNoZWQodGFyZ2V0LCBwcm9wLCByZXNvbHZlKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSkge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gIH1cbiAgY29uc3QgdmFsdWUgPSByZXNvbHZlKCk7XG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGxldCB2YWx1ZSA9IF9wcm94eVtwcm9wXTtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpICYmIGRlc2NyaXB0b3JzLmlzU2NyaXB0YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIHZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGRlc2NyaXB0b3JzLmlzSW5kZXhhYmxlKTtcbiAgfVxuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfc3RhY2t9ID0gdGFyZ2V0O1xuICBpZiAoX3N0YWNrLmhhcyhwcm9wKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaW9uIGRldGVjdGVkOiAnICsgQXJyYXkuZnJvbShfc3RhY2spLmpvaW4oJy0+JykgKyAnLT4nICsgcHJvcCk7XG4gIH1cbiAgX3N0YWNrLmFkZChwcm9wKTtcbiAgdmFsdWUgPSB2YWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSBjcmVhdGVTdWJSZXNvbHZlcihfcHJveHkuX3Njb3BlcywgX3Byb3h5LCBwcm9wLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBpc0luZGV4YWJsZSkge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgaWYgKGRlZmluZWQoX2NvbnRleHQuaW5kZXgpICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhmYWxsYmFjaywgcHJvcCwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5jb25zdCBnZXRTY29wZSA9IChrZXksIHBhcmVudCkgPT4ga2V5ID09PSB0cnVlID8gcGFyZW50XG4gIDogdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyByZXNvbHZlT2JqZWN0S2V5KHBhcmVudCwga2V5KSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGFkZFNjb3BlcyhzZXQsIHBhcmVudFNjb3Blcywga2V5LCBwYXJlbnRGYWxsYmFjaywgdmFsdWUpIHtcbiAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50U2NvcGVzKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBnZXRTY29wZShrZXksIHBhcmVudCk7XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBzZXQuYWRkKHNjb3BlKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHNjb3BlLl9mYWxsYmFjaywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIGRlZmluZWQocGFyZW50RmFsbGJhY2spICYmIGtleSAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVTdWJSZXNvbHZlcihwYXJlbnRTY29wZXMsIHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3AsIHZhbHVlKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IHByb3ApIHtcbiAgICBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBmYWxsYmFjaywga2V5LCB2YWx1ZSk7XG4gICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2NyZWF0ZVJlc29sdmVyKEFycmF5LmZyb20oc2V0KSwgWycnXSwgcm9vdFNjb3BlcywgZmFsbGJhY2ssXG4gICAgKCkgPT4gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSkge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHByb3h5KSB7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlKHJlYWRLZXkocHJlZml4LCBwcm9wKSwgc2NvcGVzKTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5LCBzY29wZXMpIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5mdW5jdGlvbiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge2tleSA9ICdyJ30gPSB0aGlzLl9wYXJzaW5nO1xuICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICBwYXJzZWRbaV0gPSB7XG4gICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmNvbnN0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcbmNvbnN0IGdldFBvaW50ID0gKHBvaW50cywgaSkgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXMpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuZnVuY3Rpb24gc3BsaW5lQ3VydmUoZmlyc3RQb2ludCwgbWlkZGxlUG9pbnQsIGFmdGVyUG9pbnQsIHQpIHtcbiAgY29uc3QgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcbiAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgY29uc3QgZDAxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGN1cnJlbnQsIHByZXZpb3VzKTtcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xuICBsZXQgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG4gIGxldCBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG4gIHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuICBjb25zdCBmYSA9IHQgKiBzMDE7XG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcbiAgcmV0dXJuIHtcbiAgICBwcmV2aW91czoge1xuICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH0sXG4gICAgbmV4dDoge1xuICAgICAgeDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSykge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQgfHwgIXBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcbiAgICBzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcbiAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG4gICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICAgIG1LW2kgKyAxXSA9IGJldGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgfVxufVxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgZGVsdGFLID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSyA9IEFycmF5KHBvaW50c0xlbik7XG4gIGxldCBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgOiAoc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pKSA/IDBcbiAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuICBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspO1xuICBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzKTtcbn1cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSkge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGluQXJlYSwgaW5BcmVhUHJldjtcbiAgbGV0IGluQXJlYU5leHQgPSBfaXNQb2ludEluQXJlYShwb2ludHNbMF0sIGFyZWEpO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluQXJlYVByZXYgPSBpbkFyZWE7XG4gICAgaW5BcmVhID0gaW5BcmVhTmV4dDtcbiAgICBpbkFyZWFOZXh0ID0gaSA8IGlsZW4gLSAxICYmIF9pc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0sIGFyZWEpO1xuICAgIGlmICghaW5BcmVhKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgaWYgKGluQXJlYVByZXYpIHtcbiAgICAgIHBvaW50LmNwMXggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMXkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gICAgaWYgKGluQXJlYU5leHQpIHtcbiAgICAgIHBvaW50LmNwMnggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMnkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHBvaW50cywgb3B0aW9ucywgYXJlYSwgbG9vcCwgaW5kZXhBeGlzKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgY29udHJvbFBvaW50cztcbiAgaWYgKG9wdGlvbnMuc3BhbkdhcHMpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwdCkgPT4gIXB0LnNraXApO1xuICB9XG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2FwQmV6aWVyUG9pbnRzKSB7XG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2lzRG9tU3VwcG9ydGVkKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM7XG4gIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHByb3BlcnR5KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cbmNvbnN0IHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5mdW5jdGlvbiBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGVzLCBzdHlsZSwgc3VmZml4KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4LCB5LCB0YXJnZXQpID0+ICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgIXRhcmdldC5zaGFkb3dSb290KTtcbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKGUsIGNhbnZhcykge1xuICBjb25zdCB0b3VjaGVzID0gZS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSB0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID8gdG91Y2hlc1swXSA6IGU7XG4gIGNvbnN0IHtvZmZzZXRYLCBvZmZzZXRZfSA9IHNvdXJjZTtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZXZ0LCBjaGFydCkge1xuICBpZiAoJ25hdGl2ZScgaW4gZXZ0KSB7XG4gICAgcmV0dXJuIGV2dDtcbiAgfVxuICBjb25zdCB7Y2FudmFzLCBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpb30gPSBjaGFydDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IGJvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnO1xuICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICBjb25zdCB7eCwgeSwgYm94fSA9IGdldENhbnZhc1Bvc2l0aW9uKGV2dCwgY2FudmFzKTtcbiAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNoYXJ0O1xuICBpZiAoYm9yZGVyQm94KSB7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKHggLSB4T2Zmc2V0KSAvIHdpZHRoICogY2FudmFzLndpZHRoIC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pLFxuICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5lclNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGxldCBtYXhXaWR0aCwgbWF4SGVpZ2h0O1xuICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgY29uc3QgY29udGFpbmVyQm9yZGVyID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAncGFkZGluZycpO1xuICAgICAgd2lkdGggPSByZWN0LndpZHRoIC0gY29udGFpbmVyUGFkZGluZy53aWR0aCAtIGNvbnRhaW5lckJvcmRlci53aWR0aDtcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUGFkZGluZy5oZWlnaHQgLSBjb250YWluZXJCb3JkZXIuaGVpZ2h0O1xuICAgICAgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heFdpZHRoLCBjb250YWluZXIsICdjbGllbnRXaWR0aCcpO1xuICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhIZWlnaHQsIGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtYXhXaWR0aDogbWF4V2lkdGggfHwgSU5GSU5JVFksXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfHwgSU5GSU5JVFlcbiAgfTtcbn1cbmNvbnN0IHJvdW5kMSA9IHYgPT4gTWF0aC5yb3VuZCh2ICogMTApIC8gMTA7XG5mdW5jdGlvbiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgbWFyZ2lucyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ21hcmdpbicpO1xuICBjb25zdCBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4V2lkdGgsIGNhbnZhcywgJ2NsaWVudFdpZHRoJykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4SGVpZ2h0LCBjYW52YXMsICdjbGllbnRIZWlnaHQnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGdldENvbnRhaW5lclNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjb250YWluZXJTaXplO1xuICBpZiAoc3R5bGUuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnKSB7XG4gICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIG1hcmdpbnMud2lkdGgpO1xuICBoZWlnaHQgPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQgLSBtYXJnaW5zLmhlaWdodCk7XG4gIHdpZHRoID0gcm91bmQxKE1hdGgubWluKHdpZHRoLCBtYXhXaWR0aCwgY29udGFpbmVyU2l6ZS5tYXhXaWR0aCkpO1xuICBoZWlnaHQgPSByb3VuZDEoTWF0aC5taW4oaGVpZ2h0LCBtYXhIZWlnaHQsIGNvbnRhaW5lclNpemUubWF4SGVpZ2h0KSk7XG4gIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgaGVpZ2h0ID0gcm91bmQxKHdpZHRoIC8gMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIHJldGluYVNjYWxlKGNoYXJ0LCBmb3JjZVJhdGlvLCBmb3JjZVN0eWxlKSB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XG4gIGNvbnN0IGRldmljZUhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVdpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCAqIHBpeGVsUmF0aW8pO1xuICBjaGFydC5oZWlnaHQgPSBkZXZpY2VIZWlnaHQgLyBwaXhlbFJhdGlvO1xuICBjaGFydC53aWR0aCA9IGRldmljZVdpZHRoIC8gcGl4ZWxSYXRpbztcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBpZiAoY2FudmFzLnN0eWxlICYmIChmb3JjZVN0eWxlIHx8ICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSkpIHtcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2hhcnQuaGVpZ2h0fXB4YDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjaGFydC53aWR0aH1weGA7XG4gIH1cbiAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvXG4gICAgICB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkZXZpY2VIZWlnaHRcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICBjaGFydC5jdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59KCkpO1xuZnVuY3Rpb24gcmVhZFVzZWRTaXplKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gIHJldHVybiBtYXRjaGVzID8gK21hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF9wb2ludEluTGluZShwMSwgcDIsIHQsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogcDEueSArIHQgKiAocDIueSAtIHAxLnkpXG4gIH07XG59XG5mdW5jdGlvbiBfc3RlcHBlZEludGVycG9sYXRpb24ocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IG1vZGUgPT09ICdtaWRkbGUnID8gdCA8IDAuNSA/IHAxLnkgOiBwMi55XG4gICAgOiBtb2RlID09PSAnYWZ0ZXInID8gdCA8IDEgPyBwMS55IDogcDIueVxuICAgIDogdCA+IDAgPyBwMi55IDogcDEueVxuICB9O1xufVxuZnVuY3Rpb24gX2JlemllckludGVycG9sYXRpb24ocDEsIHAyLCB0LCBtb2RlKSB7XG4gIGNvbnN0IGNwMSA9IHt4OiBwMS5jcDJ4LCB5OiBwMS5jcDJ5fTtcbiAgY29uc3QgY3AyID0ge3g6IHAyLmNwMXgsIHk6IHAyLmNwMXl9O1xuICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xuICBjb25zdCBiID0gX3BvaW50SW5MaW5lKGNwMSwgY3AyLCB0KTtcbiAgY29uc3QgYyA9IF9wb2ludEluTGluZShjcDIsIHAyLCB0KTtcbiAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcbiAgY29uc3QgZSA9IF9wb2ludEluTGluZShiLCBjLCB0KTtcbiAgcmV0dXJuIF9wb2ludEluTGluZShkLCBlLCB0KTtcbn1cblxuY29uc3QgaW50bENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgY2FjaGVLZXkgPSBsb2NhbGUgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgbGV0IGZvcm1hdHRlciA9IGludGxDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWZvcm1hdHRlcikge1xuICAgIGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpO1xuICAgIGludGxDYWNoZS5zZXQoY2FjaGVLZXksIGZvcm1hdHRlcik7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHRlcjtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW0sIGxvY2FsZSwgb3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG5cbmNvbnN0IGdldFJpZ2h0VG9MZWZ0QWRhcHRlciA9IGZ1bmN0aW9uKHJlY3RYLCB3aWR0aCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgICB3aWR0aCA9IHc7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCAtIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBpdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4IC0gaXRlbVdpZHRoO1xuICAgIH0sXG4gIH07XG59O1xuY29uc3QgZ2V0TGVmdFRvUmlnaHRBZGFwdGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4ICsgdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIF9pdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0UnRsQWRhcHRlcihydGwsIHJlY3RYLCB3aWR0aCkge1xuICByZXR1cm4gcnRsID8gZ2V0UmlnaHRUb0xlZnRBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIoKTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIGRpcmVjdGlvbikge1xuICBsZXQgc3R5bGUsIG9yaWdpbmFsO1xuICBpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgc3R5bGUgPSBjdHguY2FudmFzLnN0eWxlO1xuICAgIG9yaWdpbmFsID0gW1xuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKSxcbiAgICBdO1xuICAgIHN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24sICdpbXBvcnRhbnQnKTtcbiAgICBjdHgucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcmlnaW5hbCkge1xuICBpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBjdHgucHJldlRleHREaXJlY3Rpb247XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZuKHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHJldHVybiB7XG4gICAgICBiZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxuICAgICAgY29tcGFyZTogX2FuZ2xlRGlmZixcbiAgICAgIG5vcm1hbGl6ZTogX25vcm1hbGl6ZUFuZ2xlLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiZXR3ZWVuOiBfaXNCZXR3ZWVuLFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbiAgICBub3JtYWxpemU6IHggPT4geFxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgbG9vcDogbG9vcCAmJiAoZW5kIC0gc3RhcnQgKyAxKSAlIGNvdW50ID09PSAwLFxuICAgIHN0eWxlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCB7YmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCB7c3RhcnQsIGVuZCwgbG9vcH0gPSBzZWdtZW50O1xuICBsZXQgaSwgaWxlbjtcbiAgaWYgKGxvb3ApIHtcbiAgICBzdGFydCArPSBjb3VudDtcbiAgICBlbmQgKz0gY291bnQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydC0tO1xuICAgICAgZW5kLS07XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGVuZCAlPSBjb3VudDtcbiAgfVxuICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICBlbmQgKz0gY291bnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZTogc2VnbWVudC5zdHlsZX07XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGlmICghYm91bmRzKSB7XG4gICAgcmV0dXJuIFtzZWdtZW50XTtcbiAgfVxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7Y29tcGFyZSwgYmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gIGxldCBzdWJTdGFydCA9IG51bGw7XG4gIGxldCB2YWx1ZSwgcG9pbnQsIHByZXZWYWx1ZTtcbiAgY29uc3Qgc3RhcnRJc0JlZm9yZSA9ICgpID0+IGJldHdlZW4oc3RhcnRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSkgJiYgY29tcGFyZShzdGFydEJvdW5kLCBwcmV2VmFsdWUpICE9PSAwO1xuICBjb25zdCBlbmRJc0JlZm9yZSA9ICgpID0+IGNvbXBhcmUoZW5kQm91bmQsIHZhbHVlKSA9PT0gMCB8fCBiZXR3ZWVuKGVuZEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKTtcbiAgY29uc3Qgc2hvdWxkU3RhcnQgPSAoKSA9PiBpbnNpZGUgfHwgc3RhcnRJc0JlZm9yZSgpO1xuICBjb25zdCBzaG91bGRTdG9wID0gKCkgPT4gIWluc2lkZSB8fCBlbmRJc0JlZm9yZSgpO1xuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZShwb2ludFtwcm9wZXJ0eV0pO1xuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW5zaWRlID0gYmV0d2Vlbih2YWx1ZSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpO1xuICAgIGlmIChzdWJTdGFydCA9PT0gbnVsbCAmJiBzaG91bGRTdGFydCgpKSB7XG4gICAgICBzdWJTdGFydCA9IGNvbXBhcmUodmFsdWUsIHN0YXJ0Qm91bmQpID09PSAwID8gaSA6IHByZXY7XG4gICAgfVxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCAmJiBzaG91bGRTdG9wKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kOiBpLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgfVxuICAgIHByZXYgPSBpO1xuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGlmIChzdWJTdGFydCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9ib3VuZFNlZ21lbnRzKGxpbmUsIGJvdW5kcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3ViID0gX2JvdW5kU2VnbWVudChzZWdtZW50c1tpXSwgbGluZS5wb2ludHMsIGJvdW5kcyk7XG4gICAgaWYgKHN1Yi5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKC4uLnN1Yik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGNvdW50IC0gMTtcbiAgaWYgKGxvb3AgJiYgIXNwYW5HYXBzKSB7XG4gICAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgIXBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICBzdGFydCAlPSBjb3VudDtcbiAgaWYgKGxvb3ApIHtcbiAgICBlbmQgKz0gc3RhcnQ7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xuICAgIGVuZC0tO1xuICB9XG4gIGVuZCAlPSBjb3VudDtcbiAgcmV0dXJuIHtzdGFydCwgZW5kfTtcbn1cbmZ1bmN0aW9uIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBsb29wKSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBsYXN0ID0gc3RhcnQ7XG4gIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0XTtcbiAgbGV0IGVuZDtcbiAgZm9yIChlbmQgPSBzdGFydCArIDE7IGVuZCA8PSBtYXg7ICsrZW5kKSB7XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2VuZCAlIGNvdW50XTtcbiAgICBpZiAoY3VyLnNraXAgfHwgY3VyLnN0b3ApIHtcbiAgICAgIGlmICghcHJldi5za2lwKSB7XG4gICAgICAgIGxvb3AgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IChlbmQgLSAxKSAlIGNvdW50LCBsb29wfSk7XG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZDtcbiAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXI7XG4gIH1cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogbGFzdCAlIGNvdW50LCBsb29wfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgbG9vcCA9ICEhbGluZS5fbG9vcDtcbiAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKTtcbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW3tzdGFydCwgZW5kLCBsb29wfV0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IG1heCA9IGVuZCA8IHN0YXJ0ID8gZW5kICsgY291bnQgOiBlbmQ7XG4gIGNvbnN0IGNvbXBsZXRlTG9vcCA9ICEhbGluZS5fZnVsbExvb3AgJiYgc3RhcnQgPT09IDAgJiYgZW5kID09PSBjb3VudCAtIDE7XG4gIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBjb21wbGV0ZUxvb3ApLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgaWYgKCFzZWdtZW50T3B0aW9ucyB8fCAhc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dCB8fCAhcG9pbnRzKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRzO1xuICB9XG4gIHJldHVybiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IHtfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsIG9wdGlvbnM6IHtzcGFuR2Fwc319ID0gbGluZTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG4gIGZ1bmN0aW9uIGFkZFN0eWxlKHMsIGUsIGwsIHN0KSB7XG4gICAgY29uc3QgZGlyID0gc3BhbkdhcHMgPyAtMSA6IDE7XG4gICAgaWYgKHMgPT09IGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcyArPSBjb3VudDtcbiAgICB3aGlsZSAocG9pbnRzW3MgJSBjb3VudF0uc2tpcCkge1xuICAgICAgcyAtPSBkaXI7XG4gICAgfVxuICAgIHdoaWxlIChwb2ludHNbZSAlIGNvdW50XS5za2lwKSB7XG4gICAgICBlICs9IGRpcjtcbiAgICB9XG4gICAgaWYgKHMgJSBjb3VudCAhPT0gZSAlIGNvdW50KSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHMgJSBjb3VudCwgZW5kOiBlICUgY291bnQsIGxvb3A6IGwsIHN0eWxlOiBzdH0pO1xuICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc3RhcnQgPSBzcGFuR2FwcyA/IHN0YXJ0IDogc2VnbWVudC5zdGFydDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydCAlIGNvdW50XTtcbiAgICBsZXQgc3R5bGU7XG4gICAgZm9yIChpID0gc3RhcnQgKyAxOyBpIDw9IHNlZ21lbnQuZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgICBzdHlsZSA9IHJlYWRTdHlsZShzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0KGNyZWF0ZUNvbnRleHQoY2hhcnRDb250ZXh0LCB7XG4gICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgcDA6IHByZXYsXG4gICAgICAgIHAxOiBwdCxcbiAgICAgICAgcDBEYXRhSW5kZXg6IChpIC0gMSkgJSBjb3VudCxcbiAgICAgICAgcDFEYXRhSW5kZXg6IGkgJSBjb3VudCxcbiAgICAgICAgZGF0YXNldEluZGV4XG4gICAgICB9KSkpO1xuICAgICAgaWYgKHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSkge1xuICAgICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByZXYgPSBwdDtcbiAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCBpIC0gMSkge1xuICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5mdW5jdGlvbiBzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkge1xuICByZXR1cm4gcHJldlN0eWxlICYmIEpTT04uc3RyaW5naWZ5KHN0eWxlKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlKTtcbn1cblxuZXhwb3J0IHsgX2lzUG9pbnRJbkFyZWEgYXMgJCwgX2ZhY3Rvcml6ZSBhcyBBLCBmaW5pdGVPckRlZmF1bHQgYXMgQiwgY2FsbGJhY2sgYXMgQywgX2FkZEdyYWNlIGFzIEQsIF9saW1pdFZhbHVlIGFzIEUsIHRvRGVncmVlcyBhcyBGLCBfbWVhc3VyZVRleHQgYXMgRywgSEFMRl9QSSBhcyBILCBfaW50MTZSYW5nZSBhcyBJLCBfYWxpZ25QaXhlbCBhcyBKLCB0b1BhZGRpbmcgYXMgSywgY2xpcEFyZWEgYXMgTCwgcmVuZGVyVGV4dCBhcyBNLCB1bmNsaXBBcmVhIGFzIE4sIHRvRm9udCBhcyBPLCBQSSBhcyBQLCBlYWNoIGFzIFEsIF90b0xlZnRSaWdodENlbnRlciBhcyBSLCBfYWxpZ25TdGFydEVuZCBhcyBTLCBUQVUgYXMgVCwgb3ZlcnJpZGVzIGFzIFUsIG1lcmdlIGFzIFYsIF9jYXBpdGFsaXplIGFzIFcsIGdldFJlbGF0aXZlUG9zaXRpb24gYXMgWCwgX3Jsb29rdXBCeUtleSBhcyBZLCBfbG9va3VwQnlLZXkgYXMgWiwgX2FycmF5VW5pcXVlIGFzIF8sIHJlc29sdmUgYXMgYSwgdG9MaW5lSGVpZ2h0IGFzIGEkLCBnZXRBbmdsZUZyb21Qb2ludCBhcyBhMCwgZ2V0TWF4aW11bVNpemUgYXMgYTEsIF9nZXRQYXJlbnROb2RlIGFzIGEyLCByZWFkVXNlZFNpemUgYXMgYTMsIHRocm90dGxlZCBhcyBhNCwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyBhcyBhNSwgX2lzRG9tU3VwcG9ydGVkIGFzIGE2LCBkZXNjcmlwdG9ycyBhcyBhNywgaXNGdW5jdGlvbiBhcyBhOCwgX2F0dGFjaENvbnRleHQgYXMgYTksIGdldFJ0bEFkYXB0ZXIgYXMgYUEsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiBhcyBhQiwgX3RleHRYIGFzIGFDLCByZXN0b3JlVGV4dERpcmVjdGlvbiBhcyBhRCwgZHJhd1BvaW50TGVnZW5kIGFzIGFFLCBub29wIGFzIGFGLCBkaXN0YW5jZUJldHdlZW5Qb2ludHMgYXMgYUcsIF9zZXRNaW5BbmRNYXhCeUtleSBhcyBhSCwgbmljZU51bSBhcyBhSSwgYWxtb3N0V2hvbGUgYXMgYUosIGFsbW9zdEVxdWFscyBhcyBhSywgX2RlY2ltYWxQbGFjZXMgYXMgYUwsIF9sb25nZXN0VGV4dCBhcyBhTSwgX2ZpbHRlckJldHdlZW4gYXMgYU4sIF9sb29rdXAgYXMgYU8sIGlzUGF0dGVybk9yR3JhZGllbnQgYXMgYVAsIGdldEhvdmVyQ29sb3IgYXMgYVEsIGNsb25lJDEgYXMgYVIsIF9tZXJnZXIgYXMgYVMsIF9tZXJnZXJJZiBhcyBhVCwgX2RlcHJlY2F0ZWQgYXMgYVUsIF9zcGxpdEtleSBhcyBhViwgdG9Gb250U3RyaW5nIGFzIGFXLCBzcGxpbmVDdXJ2ZSBhcyBhWCwgc3BsaW5lQ3VydmVNb25vdG9uZSBhcyBhWSwgZ2V0U3R5bGUgYXMgYVosIGZvbnRTdHJpbmcgYXMgYV8sIF9jcmVhdGVSZXNvbHZlciBhcyBhYSwgX2Rlc2NyaXB0b3JzIGFzIGFiLCBtZXJnZUlmIGFzIGFjLCB1aWQgYXMgYWQsIGRlYm91bmNlIGFzIGFlLCByZXRpbmFTY2FsZSBhcyBhZiwgY2xlYXJDYW52YXMgYXMgYWcsIHNldHNFcXVhbCBhcyBhaCwgX2VsZW1lbnRzRXF1YWwgYXMgYWksIF9pc0NsaWNrRXZlbnQgYXMgYWosIF9pc0JldHdlZW4gYXMgYWssIF9yZWFkVmFsdWVUb1Byb3BzIGFzIGFsLCBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyBhcyBhbSwgX2NvbXB1dGVTZWdtZW50cyBhcyBhbiwgX2JvdW5kU2VnbWVudHMgYXMgYW8sIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiBhcyBhcCwgX2JlemllckludGVycG9sYXRpb24gYXMgYXEsIF9wb2ludEluTGluZSBhcyBhciwgX3N0ZXBwZWRMaW5lVG8gYXMgYXMsIF9iZXppZXJDdXJ2ZVRvIGFzIGF0LCBkcmF3UG9pbnQgYXMgYXUsIGFkZFJvdW5kZWRSZWN0UGF0aCBhcyBhdiwgdG9UUkJMIGFzIGF3LCB0b1RSQkxDb3JuZXJzIGFzIGF4LCBfYm91bmRTZWdtZW50IGFzIGF5LCBfbm9ybWFsaXplQW5nbGUgYXMgYXosIGlzQXJyYXkgYXMgYiwgUElUQVUgYXMgYjAsIElORklOSVRZIGFzIGIxLCBSQURfUEVSX0RFRyBhcyBiMiwgUVVBUlRFUl9QSSBhcyBiMywgVFdPX1RISVJEU19QSSBhcyBiNCwgX2FuZ2xlRGlmZiBhcyBiNSwgY29sb3IgYXMgYywgZGVmYXVsdHMgYXMgZCwgZWZmZWN0cyBhcyBlLCByZXNvbHZlT2JqZWN0S2V5IGFzIGYsIGlzTnVtYmVyRmluaXRlIGFzIGcsIGNyZWF0ZUNvbnRleHQgYXMgaCwgaXNPYmplY3QgYXMgaSwgZGVmaW5lZCBhcyBqLCBpc051bGxPclVuZGVmIGFzIGssIGxpc3RlbkFycmF5RXZlbnRzIGFzIGwsIHRvUGVyY2VudGFnZSBhcyBtLCB0b0RpbWVuc2lvbiBhcyBuLCBmb3JtYXROdW1iZXIgYXMgbywgX2FuZ2xlQmV0d2VlbiBhcyBwLCBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyBhcyBxLCByZXF1ZXN0QW5pbUZyYW1lIGFzIHIsIHNpZ24gYXMgcywgdG9SYWRpYW5zIGFzIHQsIHVubGlzdGVuQXJyYXlFdmVudHMgYXMgdSwgdmFsdWVPckRlZmF1bHQgYXMgdiwgX3NjYWxlUmFuZ2VzQ2hhbmdlZCBhcyB3LCBpc051bWJlciBhcyB4LCBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUgYXMgeSwgbG9nMTAgYXMgeiB9O1xuIiwgIi8qIVxuICogQ2hhcnQuanMgdjMuOS4xXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjIgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgciBhcyByZXF1ZXN0QW5pbUZyYW1lLCBhIGFzIHJlc29sdmUsIGUgYXMgZWZmZWN0cywgYyBhcyBjb2xvciwgZCBhcyBkZWZhdWx0cywgaSBhcyBpc09iamVjdCwgYiBhcyBpc0FycmF5LCB2IGFzIHZhbHVlT3JEZWZhdWx0LCB1IGFzIHVubGlzdGVuQXJyYXlFdmVudHMsIGwgYXMgbGlzdGVuQXJyYXlFdmVudHMsIGYgYXMgcmVzb2x2ZU9iamVjdEtleSwgZyBhcyBpc051bWJlckZpbml0ZSwgaCBhcyBjcmVhdGVDb250ZXh0LCBqIGFzIGRlZmluZWQsIHMgYXMgc2lnbiwgayBhcyBpc051bGxPclVuZGVmLCBfIGFzIF9hcnJheVVuaXF1ZSwgdCBhcyB0b1JhZGlhbnMsIG0gYXMgdG9QZXJjZW50YWdlLCBuIGFzIHRvRGltZW5zaW9uLCBUIGFzIFRBVSwgbyBhcyBmb3JtYXROdW1iZXIsIHAgYXMgX2FuZ2xlQmV0d2VlbiwgSCBhcyBIQUxGX1BJLCBQIGFzIFBJLCBxIGFzIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCB3IGFzIF9zY2FsZVJhbmdlc0NoYW5nZWQsIHggYXMgaXNOdW1iZXIsIHkgYXMgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLCB6IGFzIGxvZzEwLCBBIGFzIF9mYWN0b3JpemUsIEIgYXMgZmluaXRlT3JEZWZhdWx0LCBDIGFzIGNhbGxiYWNrLCBEIGFzIF9hZGRHcmFjZSwgRSBhcyBfbGltaXRWYWx1ZSwgRiBhcyB0b0RlZ3JlZXMsIEcgYXMgX21lYXN1cmVUZXh0LCBJIGFzIF9pbnQxNlJhbmdlLCBKIGFzIF9hbGlnblBpeGVsLCBLIGFzIHRvUGFkZGluZywgTCBhcyBjbGlwQXJlYSwgTSBhcyByZW5kZXJUZXh0LCBOIGFzIHVuY2xpcEFyZWEsIE8gYXMgdG9Gb250LCBRIGFzIGVhY2gsIFIgYXMgX3RvTGVmdFJpZ2h0Q2VudGVyLCBTIGFzIF9hbGlnblN0YXJ0RW5kLCBVIGFzIG92ZXJyaWRlcywgViBhcyBtZXJnZSwgVyBhcyBfY2FwaXRhbGl6ZSwgWCBhcyBnZXRSZWxhdGl2ZVBvc2l0aW9uLCBZIGFzIF9ybG9va3VwQnlLZXksIFogYXMgX2xvb2t1cEJ5S2V5LCAkIGFzIF9pc1BvaW50SW5BcmVhLCBhMCBhcyBnZXRBbmdsZUZyb21Qb2ludCwgYTEgYXMgZ2V0TWF4aW11bVNpemUsIGEyIGFzIF9nZXRQYXJlbnROb2RlLCBhMyBhcyByZWFkVXNlZFNpemUsIGE0IGFzIHRocm90dGxlZCwgYTUgYXMgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgYTYgYXMgX2lzRG9tU3VwcG9ydGVkLCBhNyBhcyBkZXNjcmlwdG9ycywgYTggYXMgaXNGdW5jdGlvbiwgYTkgYXMgX2F0dGFjaENvbnRleHQsIGFhIGFzIF9jcmVhdGVSZXNvbHZlciwgYWIgYXMgX2Rlc2NyaXB0b3JzLCBhYyBhcyBtZXJnZUlmLCBhZCBhcyB1aWQsIGFlIGFzIGRlYm91bmNlLCBhZiBhcyByZXRpbmFTY2FsZSwgYWcgYXMgY2xlYXJDYW52YXMsIGFoIGFzIHNldHNFcXVhbCwgYWkgYXMgX2VsZW1lbnRzRXF1YWwsIGFqIGFzIF9pc0NsaWNrRXZlbnQsIGFrIGFzIF9pc0JldHdlZW4sIGFsIGFzIF9yZWFkVmFsdWVUb1Byb3BzLCBhbSBhcyBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cywgYW4gYXMgX2NvbXB1dGVTZWdtZW50cywgYW8gYXMgX2JvdW5kU2VnbWVudHMsIGFwIGFzIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiwgYXEgYXMgX2JlemllckludGVycG9sYXRpb24sIGFyIGFzIF9wb2ludEluTGluZSwgYXMgYXMgX3N0ZXBwZWRMaW5lVG8sIGF0IGFzIF9iZXppZXJDdXJ2ZVRvLCBhdSBhcyBkcmF3UG9pbnQsIGF2IGFzIGFkZFJvdW5kZWRSZWN0UGF0aCwgYXcgYXMgdG9UUkJMLCBheCBhcyB0b1RSQkxDb3JuZXJzLCBheSBhcyBfYm91bmRTZWdtZW50LCBheiBhcyBfbm9ybWFsaXplQW5nbGUsIGFBIGFzIGdldFJ0bEFkYXB0ZXIsIGFCIGFzIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgYUMgYXMgX3RleHRYLCBhRCBhcyByZXN0b3JlVGV4dERpcmVjdGlvbiwgYUUgYXMgZHJhd1BvaW50TGVnZW5kLCBhRiBhcyBub29wLCBhRyBhcyBkaXN0YW5jZUJldHdlZW5Qb2ludHMsIGFIIGFzIF9zZXRNaW5BbmRNYXhCeUtleSwgYUkgYXMgbmljZU51bSwgYUogYXMgYWxtb3N0V2hvbGUsIGFLIGFzIGFsbW9zdEVxdWFscywgYUwgYXMgX2RlY2ltYWxQbGFjZXMsIGFNIGFzIF9sb25nZXN0VGV4dCwgYU4gYXMgX2ZpbHRlckJldHdlZW4sIGFPIGFzIF9sb29rdXAgfSBmcm9tICcuL2NodW5rcy9oZWxwZXJzLnNlZ21lbnQubWpzJztcbmV4cG9ydCB7IGQgYXMgZGVmYXVsdHMgfSBmcm9tICcuL2NodW5rcy9oZWxwZXJzLnNlZ21lbnQubWpzJztcblxuY2xhc3MgQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG4gICAgY2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oe1xuICAgICAgY2hhcnQsXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgbnVtU3RlcHMsXG4gICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICB9KSk7XG4gIH1cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xuICAgIGxldCByZW1haW5pbmcgPSAwO1xuICAgIHRoaXMuX2NoYXJ0cy5mb3JFYWNoKChhbmltcywgY2hhcnQpID0+IHtcbiAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZHJhdyA9IGZhbHNlO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uX3RvdGFsID4gYW5pbXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdwcm9ncmVzcycpO1xuICAgICAgfVxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgYW5pbXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAnY29tcGxldGUnKTtcbiAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IGRhdGU7XG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0QW5pbXMoY2hhcnQpIHtcbiAgICBjb25zdCBjaGFydHMgPSB0aGlzLl9jaGFydHM7XG4gICAgbGV0IGFuaW1zID0gY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgYW5pbXMgPSB7XG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYXJ0cy5zZXQoY2hhcnQsIGFuaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1zO1xuICB9XG4gIGxpc3RlbihjaGFydCwgZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYik7XG4gIH1cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cbiAgaGFzKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xuICB9XG4gIHN0YXJ0KGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1zLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGFuaW1zLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgY3VyLl9kdXJhdGlvbiksIDApO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBydW5uaW5nKGNoYXJ0KSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhbmltcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xuICB9XG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxudmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7XG5cbmNvbnN0IHRyYW5zcGFyZW50ID0gJ3RyYW5zcGFyZW50JztcbmNvbnN0IGludGVycG9sYXRvcnMgPSB7XG4gIGJvb2xlYW4oZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmYWN0b3IgPiAwLjUgPyB0byA6IGZyb207XG4gIH0sXG4gIGNvbG9yKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICBjb25zdCBjMCA9IGNvbG9yKGZyb20gfHwgdHJhbnNwYXJlbnQpO1xuICAgIGNvbnN0IGMxID0gYzAudmFsaWQgJiYgY29sb3IodG8gfHwgdHJhbnNwYXJlbnQpO1xuICAgIHJldHVybiBjMSAmJiBjMS52YWxpZFxuICAgICAgPyBjMS5taXgoYzAsIGZhY3RvcikuaGV4U3RyaW5nKClcbiAgICAgIDogdG87XG4gIH0sXG4gIG51bWJlcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgfVxufTtcbmNsYXNzIEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0bykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgICB0byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICBjb25zdCBmcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2ZuID0gY2ZnLmZuIHx8IGludGVycG9sYXRvcnNbY2ZnLnR5cGUgfHwgdHlwZW9mIGZyb21dO1xuICAgIHRoaXMuX2Vhc2luZyA9IGVmZmVjdHNbY2ZnLmVhc2luZ10gfHwgZWZmZWN0cy5saW5lYXI7XG4gICAgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAoY2ZnLmRlbGF5IHx8IDApKTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcihjZmcuZHVyYXRpb24pO1xuICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9wcm9wID0gcHJvcDtcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcbiAgICB0aGlzLl90byA9IHRvO1xuICAgIHRoaXMuX3Byb21pc2VzID0gdW5kZWZpbmVkO1xuICB9XG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG4gIHVwZGF0ZShjZmcsIHRvLCBkYXRlKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXTtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBjb25zdCByZW1haW4gPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICB0aGlzLl9zdGFydCA9IGRhdGU7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgocmVtYWluLCBjZmcuZHVyYXRpb24pKTtcbiAgICAgIHRoaXMuX3RvdGFsICs9IGVsYXBzZWQ7XG4gICAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgIHRoaXMuX3RvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgfVxuICB9XG4gIHRpY2soZGF0ZSkge1xuICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICBjb25zdCBwcm9wID0gdGhpcy5fcHJvcDtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5fZnJvbTtcbiAgICBjb25zdCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICBjb25zdCB0byA9IHRoaXMuX3RvO1xuICAgIGxldCBmYWN0b3I7XG4gICAgdGhpcy5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsYXBzZWQgPCAwKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSBmcm9tO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmYWN0b3IgPSAoZWxhcHNlZCAvIGR1cmF0aW9uKSAlIDI7XG4gICAgZmFjdG9yID0gbG9vcCAmJiBmYWN0b3IgPiAxID8gMiAtIGZhY3RvciA6IGZhY3RvcjtcbiAgICBmYWN0b3IgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xuICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRoaXMuX2ZuKGZyb20sIHRvLCBmYWN0b3IpO1xuICB9XG4gIHdhaXQoKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCAodGhpcy5fcHJvbWlzZXMgPSBbXSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcHJvbWlzZXMucHVzaCh7cmVzLCByZWp9KTtcbiAgICB9KTtcbiAgfVxuICBfbm90aWZ5KHJlc29sdmVkKSB7XG4gICAgY29uc3QgbWV0aG9kID0gcmVzb2x2ZWQgPyAncmVzJyA6ICdyZWonO1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV1bbWV0aG9kXSgpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcbmNvbnN0IGNvbG9ycyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYmFja2dyb3VuZENvbG9yJ107XG5kZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgZGVsYXk6IHVuZGVmaW5lZCxcbiAgZHVyYXRpb246IDEwMDAsXG4gIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gIGZuOiB1bmRlZmluZWQsXG4gIGZyb206IHVuZGVmaW5lZCxcbiAgbG9vcDogdW5kZWZpbmVkLFxuICB0bzogdW5kZWZpbmVkLFxuICB0eXBlOiB1bmRlZmluZWQsXG59KTtcbmNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5hbmltYXRpb24pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbicsIHtcbiAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgX2luZGV4YWJsZTogZmFsc2UsXG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ29uUHJvZ3Jlc3MnICYmIG5hbWUgIT09ICdvbkNvbXBsZXRlJyAmJiBuYW1lICE9PSAnZm4nLFxufSk7XG5kZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbnMnLCB7XG4gIGNvbG9yczoge1xuICAgIHR5cGU6ICdjb2xvcicsXG4gICAgcHJvcGVydGllczogY29sb3JzXG4gIH0sXG4gIG51bWJlcnM6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBwcm9wZXJ0aWVzOiBudW1iZXJzXG4gIH0sXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb25zJywge1xuICBfZmFsbGJhY2s6ICdhbmltYXRpb24nLFxufSk7XG5kZWZhdWx0cy5zZXQoJ3RyYW5zaXRpb25zJywge1xuICBhY3RpdmU6IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDBcbiAgICB9XG4gIH0sXG4gIHJlc2l6ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDBcbiAgICB9XG4gIH0sXG4gIHNob3c6IHtcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG4gIGhpZGU6IHtcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgdG86ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZm46IHYgPT4gdiB8IDBcbiAgICAgIH0sXG4gICAgfVxuICB9XG59KTtcbmNsYXNzIEFuaW1hdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG4gIH1cbiAgY29uZmlndXJlKGNvbmZpZykge1xuICAgIGlmICghaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xuICAgICAgaWYgKCFpc09iamVjdChjZmcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBhbmltYXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcbiAgICAgIH1cbiAgICAgIChpc0FycmF5KGNmZy5wcm9wZXJ0aWVzKSAmJiBjZmcucHJvcGVydGllcyB8fCBba2V5XSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAocHJvcCA9PT0ga2V5IHx8ICFhbmltYXRlZFByb3BzLmhhcyhwcm9wKSkge1xuICAgICAgICAgIGFuaW1hdGVkUHJvcHMuc2V0KHByb3AsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IHZhbHVlcy5vcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICBpZiAobmV3T3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICBhd2FpdEFsbCh0YXJnZXQub3B0aW9ucy4kYW5pbWF0aW9ucywgbmV3T3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIH0sICgpID0+IHtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBfY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBydW5uaW5nID0gdGFyZ2V0LiRhbmltYXRpb25zIHx8ICh0YXJnZXQuJGFuaW1hdGlvbnMgPSB7fSk7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAocHJvcC5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLnRoaXMuX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbcHJvcF07XG4gICAgICBsZXQgYW5pbWF0aW9uID0gcnVubmluZ1twcm9wXTtcbiAgICAgIGNvbnN0IGNmZyA9IGFuaW1hdGVkUHJvcHMuZ2V0KHByb3ApO1xuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBpZiAoY2ZnICYmIGFuaW1hdGlvbi5hY3RpdmUoKSkge1xuICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGUoY2ZnLCB2YWx1ZSwgZGF0ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNmZyB8fCAhY2ZnLmR1cmF0aW9uKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJ1bm5pbmdbcHJvcF0gPSBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGNmZywgdGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHZhbHVlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKTtcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGFuaW1hdG9yLmFkZCh0aGlzLl9jaGFydCwgYW5pbWF0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGF3YWl0QWxsKGFuaW1hdGlvbnMsIHByb3BlcnRpZXMpIHtcbiAgY29uc3QgcnVubmluZyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFuaW0gPSBhbmltYXRpb25zW2tleXNbaV1dO1xuICAgIGlmIChhbmltICYmIGFuaW0uYWN0aXZlKCkpIHtcbiAgICAgIHJ1bm5pbmcucHVzaChhbmltLndhaXQoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucykge1xuICBpZiAoIW5ld09wdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucztcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyRzaGFyZWQ6IGZhbHNlLCAkYW5pbWF0aW9uczoge319KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJldmVyc2UgPSBvcHRzLnJldmVyc2U7XG4gIGNvbnN0IG1pbiA9IG9wdHMubWluID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICBjb25zdCBtYXggPSBvcHRzLm1heCA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcmV2ZXJzZSA/IG1heCA6IG1pbixcbiAgICBlbmQ6IHJldmVyc2UgPyBtaW4gOiBtYXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGlwKHhTY2FsZSwgeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgaWYgKGFsbG93ZWRPdmVyZmxvdyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeCA9IHNjYWxlQ2xpcCh4U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIGNvbnN0IHkgPSBzY2FsZUNsaXAoeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICByZXR1cm4ge1xuICAgIHRvcDogeS5lbmQsXG4gICAgcmlnaHQ6IHguZW5kLFxuICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICBsZWZ0OiB4LnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcbiAgbGV0IHQsIHIsIGIsIGw7XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB0ID0gdmFsdWUudG9wO1xuICAgIHIgPSB2YWx1ZS5yaWdodDtcbiAgICBiID0gdmFsdWUuYm90dG9tO1xuICAgIGwgPSB2YWx1ZS5sZWZ0O1xuICB9IGVsc2Uge1xuICAgIHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogcixcbiAgICBib3R0b206IGIsXG4gICAgbGVmdDogbCxcbiAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgZmlsdGVyVmlzaWJsZSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXlzLnB1c2gobWV0YXNldHNbaV0uaW5kZXgpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc051bWJlckZpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBhZGF0YSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gIGxldCBpLCBpbGVuLCBrZXk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgYWRhdGFbaV0gPSB7XG4gICAgICB4OiBrZXksXG4gICAgICB5OiBkYXRhW2tleV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhZGF0YTtcbn1cbmZ1bmN0aW9uIGlzU3RhY2tlZChzY2FsZSwgbWV0YSkge1xuICBjb25zdCBzdGFja2VkID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICByZXR1cm4gc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBnZXRTdGFja0tleShpbmRleFNjYWxlLCB2YWx1ZVNjYWxlLCBtZXRhKSB7XG4gIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbkRlZmluZWQgPyBtaW4gOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tLZXksIGluZGV4VmFsdWUpIHtcbiAgY29uc3Qgc3ViU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldIHx8IChzdGFja3Nbc3RhY2tLZXldID0ge30pO1xuICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xuICBmb3IgKGNvbnN0IG1ldGEgb2YgdlNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpLnJldmVyc2UoKSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3RhY2tbbWV0YS5pbmRleF07XG4gICAgaWYgKChwb3NpdGl2ZSAmJiB2YWx1ZSA+IDApIHx8ICghcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSkge1xuICAgICAgcmV0dXJuIG1ldGEuaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlU3RhY2tzKGNvbnRyb2xsZXIsIHBhcnNlZCkge1xuICBjb25zdCB7Y2hhcnQsIF9jYWNoZWRNZXRhOiBtZXRhfSA9IGNvbnRyb2xsZXI7XG4gIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgaW5kZXg6IGRhdGFzZXRJbmRleH0gPSBtZXRhO1xuICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICBjb25zdCBrZXkgPSBnZXRTdGFja0tleShpU2NhbGUsIHZTY2FsZSwgbWV0YSk7XG4gIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICBsZXQgc3RhY2s7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICBjb25zdCB7W2lBeGlzXTogaW5kZXgsIFt2QXhpc106IHZhbHVlfSA9IGl0ZW07XG4gICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgIHN0YWNrID0gaXRlbVN0YWNrc1t2QXhpc10gPSBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywga2V5LCBpbmRleCk7XG4gICAgc3RhY2tbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgc3RhY2suX2JvdHRvbSA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgZmFsc2UsIG1ldGEudHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICBjb25zdCBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZXMpLmZpbHRlcihrZXkgPT4gc2NhbGVzW2tleV0uYXhpcyA9PT0gYXhpcykuc2hpZnQoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFzZXRDb250ZXh0KHBhcmVudCwgaW5kZXgpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LFxuICAgIHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBkYXRhc2V0OiB1bmRlZmluZWQsXG4gICAgICBkYXRhc2V0SW5kZXg6IGluZGV4LFxuICAgICAgaW5kZXgsXG4gICAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgICB0eXBlOiAnZGF0YXNldCdcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcbiAgICByYXc6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50LFxuICAgIGluZGV4LFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICB0eXBlOiAnZGF0YSdcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICBjb25zdCBkYXRhc2V0SW5kZXggPSBtZXRhLmNvbnRyb2xsZXIuaW5kZXg7XG4gIGNvbnN0IGF4aXMgPSBtZXRhLnZTY2FsZSAmJiBtZXRhLnZTY2FsZS5heGlzO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaXRlbXMgPSBpdGVtcyB8fCBtZXRhLl9wYXJzZWQ7XG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gcGFyc2VkLl9zdGFja3M7XG4gICAgaWYgKCFzdGFja3MgfHwgc3RhY2tzW2F4aXNdID09PSB1bmRlZmluZWQgfHwgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF07XG4gIH1cbn1cbmNvbnN0IGlzRGlyZWN0VXBkYXRlTW9kZSA9IChtb2RlKSA9PiBtb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpID0+IHNoYXJlZCA/IGNhY2hlZCA6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlZCk7XG5jb25zdCBjcmVhdGVTdGFjayA9IChjYW5TdGFjaywgbWV0YSwgY2hhcnQpID0+IGNhblN0YWNrICYmICFtZXRhLmhpZGRlbiAmJiBtZXRhLl9zdGFja2VkXG4gICYmIHtrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksIHZhbHVlczogbnVsbH07XG5jbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgdGhpcy5fdHlwZSA9IHRoaXMuX2NhY2hlZE1ldGEudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaGFyZWRPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgIG1ldGEueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgIG1ldGEudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChfZGF0YSAhPT0gZGF0YSkge1xuICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgIHVubGlzdGVuQXJyYXlFdmVudHMoX2RhdGEsIHRoaXMpO1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgIGNvbnN0IG9sZFN0YWNrZWQgPSBtZXRhLl9zdGFja2VkO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0U2NvcGVLZXlzKHRoaXMuX3R5cGUpO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cywgdHJ1ZSk7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuX3BhcnNpbmcgPSB0aGlzLm9wdGlvbnMucGFyc2luZztcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICB9XG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YTogbWV0YSwgX2RhdGE6IGRhdGF9ID0gdGhpcztcbiAgICBjb25zdCB7aVNjYWxlLCBfc3RhY2tlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiA9ICgpID0+IGN1cltpQXhpc10gPT09IG51bGwgfHwgKHByZXYgJiYgY3VyW2lBeGlzXSA8IHByZXZbaUF4aXNdKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpICsgc3RhcnRdID0gY3VyID0gcGFyc2VkW2ldO1xuICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgaWYgKGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2KCkpIHtcbiAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXRhLl9zb3J0ZWQgPSBzb3J0ZWQ7XG4gICAgfVxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgW2lBeGlzXTogc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpbmRleF0sIGluZGV4KSxcbiAgICAgICAgW3ZBeGlzXTogdlNjYWxlLnBhcnNlKGRhdGFbaW5kZXhdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKGl0ZW1bMF0sIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKGl0ZW1bMV0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHhBeGlzS2V5KSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB5QXhpc0tleSksIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRQYXJzZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkW2luZGV4XTtcbiAgfVxuICBnZXREYXRhRWxlbWVudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICB9XG4gIGFwcGx5U3RhY2soc2NhbGUsIHBhcnNlZCwgbW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBjb25zdCBzdGFjayA9IHtcbiAgICAgIGtleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSxcbiAgICAgIHZhbHVlczogcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc11cbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNOdW1iZXJGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBpU2NhbGUgPyAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pIDogJycsXG4gICAgICB2YWx1ZTogdlNjYWxlID8gJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKSA6ICcnXG4gICAgfTtcbiAgfVxuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHt9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFjdGl2ZSA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fZHJhd1N0YXJ0IHx8IDA7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9kcmF3Q291bnQgfHwgKGVsZW1lbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBjb25zdCBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRoaXMub3B0aW9ucy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcDtcbiAgICBsZXQgaTtcbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7ICsraSkge1xuICAgICAgYWN0aXZlW2ldLmRyYXcoY3R4LCBhcmVhKTtcbiAgICB9XG4gIH1cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIHJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIG1vZGUpO1xuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBtb2RlLCBpbmRleCk7XG4gIH1cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMuJHNoYXJlZCA9IHNoYXJpbmc7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG4gIF9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKSB7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyA9IHRoaXMuX3NoYXJlZE9wdGlvbnM7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB8fCAoc2hhcmVkT3B0aW9ucyAhPT0gcHJldmlvdXNseVNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIHJldHVybiB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9O1xuICB9XG4gIHVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHByb3BlcnRpZXMsIG1vZGUpIHtcbiAgICBpZiAoaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSkudXBkYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCBtb2RlLCBhY3RpdmUpIHtcbiAgICBlbGVtZW50LmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRTdHlsZShpbmRleCwgYWN0aXZlKTtcbiAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSwgYWN0aXZlKS51cGRhdGUoZWxlbWVudCwge1xuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCBmYWxzZSk7XG4gIH1cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuICBfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBfc2V0RGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgZm9yIChjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSBvZiB0aGlzLl9zeW5jTGlzdCkge1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG4gICAgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSwgcmVzZXROZXdFbGVtZW50cyk7XG4gICAgfSBlbHNlIGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xuICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudHMobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgfVxuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBtb3ZlID0gKGFycikgPT4ge1xuICAgICAgYXJyLmxlbmd0aCArPSBjb3VudDtcbiAgICAgIGZvciAoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IGVuZDsgaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycltpIC0gY291bnRdO1xuICAgICAgfVxuICAgIH07XG4gICAgbW92ZShkYXRhKTtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcbiAgICBpZiAocmVzZXROZXdFbGVtZW50cykge1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhkYXRhLCBzdGFydCwgY291bnQsICdyZXNldCcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9XG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgX3N5bmMoYXJncykge1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICB0aGlzLl9zeW5jTGlzdC5wdXNoKGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSA9IGFyZ3M7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuY2hhcnQuX2RhdGFDaGFuZ2VzLnB1c2goW3RoaXMuaW5kZXgsIC4uLmFyZ3NdKTtcbiAgfVxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuICBfb25EYXRhU2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIDAsIDFdKTtcbiAgfVxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG5EYXRhc2V0Q29udHJvbGxlci5kZWZhdWx0cyA9IHt9O1xuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIHR5cGUpIHtcbiAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IHZpc2libGVNZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpO1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodmlzaWJsZU1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIG1ldGEudHlwZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgIH1cbiAgICBwcmV2ID0gY3VycjtcbiAgfTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICByYXRpbyA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgfVxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICBsZXQgYmFyRW5kID0gbWF4O1xuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtW3ZTY2FsZS5heGlzXSA9IHZTY2FsZS5wYXJzZShlbnRyeSwgaSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRCYXIoY3VzdG9tKSB7XG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KSB7XG4gIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCByZXMgPSB7fTtcbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWRnZSA9PT0gdHJ1ZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHt0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGxlZnQ6IHRydWV9O1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYiwgYSk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGEsIGIpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cbmZ1bmN0aW9uIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywge2luZmxhdGVBbW91bnR9LCByYXRpbykge1xuICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bydcbiAgICA/IHJhdGlvID09PSAxID8gMC4zMyA6IDBcbiAgICA6IGluZmxhdGVBbW91bnQ7XG59XG5jbGFzcyBCYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbSwgb2JqO1xuICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb2JqID0gZGF0YVtpXTtcbiAgICAgIGl0ZW0gPSB7fTtcbiAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkob2JqLCBpQXhpc0tleSksIGkpO1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgdkF4aXNLZXkpLCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgaWYgKGN1c3RvbSAmJiBzY2FsZSA9PT0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUpIHtcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXG4gICAgICA/ICdbJyArIGN1c3RvbS5zdGFydCArICcsICcgKyBjdXN0b20uZW5kICsgJ10nXG4gICAgICA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhtZXRhLmRhdGEsIDAsIG1ldGEuZGF0YS5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHZTY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXG4gICAgICAgIHg6IGhvcml6b250YWwgPyB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcixcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICB3aWR0aDogaG9yaXpvbnRhbCA/IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSkgOiBpcGl4ZWxzLnNpemVcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCB7aVNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YXNldHMgPSBpU2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModGhpcy5fdHlwZSlcbiAgICAgIC5maWx0ZXIobWV0YSA9PiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKTtcbiAgICBjb25zdCBzdGFja2VkID0gaVNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICBjb25zdCBzdGFja3MgPSBbXTtcbiAgICBjb25zdCBza2lwTnVsbCA9IChtZXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGRhdGFJbmRleCk7XG4gICAgICBjb25zdCB2YWwgPSBwYXJzZWQgJiYgcGFyc2VkW21ldGEudlNjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBtZXRhIG9mIG1ldGFzZXRzKSB7XG4gICAgICBpZiAoZGF0YUluZGV4ICE9PSB1bmRlZmluZWQgJiYgc2tpcE51bGwobWV0YSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhY2tlZCA9PT0gZmFsc2UgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhLmluZGV4ID09PSBsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cbiAgX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKHVuZGVmaW5lZCwgaW5kZXgpLmxlbmd0aDtcbiAgfVxuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTtcbiAgICByZXR1cm4gKGluZGV4ID09PSAtMSlcbiAgICAgID8gc3RhY2tzLmxlbmd0aCAtIDFcbiAgICAgIDogaW5kZXg7XG4gIH1cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBpeGVscy5wdXNoKGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpW2lTY2FsZS5heGlzXSwgaSkpO1xuICAgIH1cbiAgICBjb25zdCBiYXJUaGlja25lc3MgPSBvcHRzLmJhclRoaWNrbmVzcztcbiAgICBjb25zdCBtaW4gPSBiYXJUaGlja25lc3MgfHwgY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XG4gICAgICBzdGFydCA9IGxlbmd0aCAtIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcbiAgICBsZXQgYmFzZSA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0VmFsdWUpO1xuICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcbiAgICBpZiAoTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcbiAgICAgIHNpemUgPSBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkgKiBtaW5CYXJMZW5ndGg7XG4gICAgICBpZiAodmFsdWUgPT09IGFjdHVhbEJhc2UpIHtcbiAgICAgICAgYmFzZSAtPSBzaXplIC8gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDApO1xuICAgICAgY29uc3QgZW5kUGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDEpO1xuICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgYmFzZSA9IE1hdGgubWF4KE1hdGgubWluKGJhc2UsIG1heCksIG1pbik7XG4gICAgICBoZWFkID0gYmFzZSArIHNpemU7XG4gICAgfVxuICAgIGlmIChiYXNlID09PSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShhY3R1YWxCYXNlKSkge1xuICAgICAgY29uc3QgaGFsZkdyaWQgPSBzaWduKHNpemUpICogdlNjYWxlLmdldExpbmVXaWR0aEZvclZhbHVlKGFjdHVhbEJhc2UpIC8gMjtcbiAgICAgIGJhc2UgKz0gaGFsZkdyaWQ7XG4gICAgICBzaXplIC09IGhhbGZHcmlkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG4gIF9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpbmRleCwgcnVsZXIpIHtcbiAgICBjb25zdCBzY2FsZSA9IHJ1bGVyLnNjYWxlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2tpcE51bGwgPSBvcHRpb25zLnNraXBOdWxsO1xuICAgIGNvbnN0IG1heEJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSk7XG4gICAgbGV0IGNlbnRlciwgc2l6ZTtcbiAgICBpZiAocnVsZXIuZ3JvdXBlZCkge1xuICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHNraXBOdWxsID8gdGhpcy5fZ2V0U3RhY2tDb3VudChpbmRleCkgOiBydWxlci5zdGFja0NvdW50O1xuICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnXG4gICAgICAgID8gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpXG4gICAgICAgIDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCk7XG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG4gICAgICBoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcbiAgICAgIGNlbnRlcixcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcmVjdHMgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgaWxlbiA9IHJlY3RzLmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwpIHtcbiAgICAgICAgcmVjdHNbaV0uZHJhdyh0aGlzLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuQmFyQ29udHJvbGxlci5pZCA9ICdiYXInO1xuQmFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYmFyJyxcbiAgY2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG4gIGJhclBlcmNlbnRhZ2U6IDAuOSxcbiAgZ3JvdXBlZDogdHJ1ZSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXVxuICAgIH1cbiAgfVxufTtcbkJhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgb2Zmc2V0OiB0cnVlLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbVsyXSwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW0gJiYgaXRlbS5yICYmICtpdGVtLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG4gICAgY29uc3QgciA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbWV0YS5sYWJlbCxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAociA/ICcsICcgKyByIDogJycpICsgJyknXG4gICAgfTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSByZXNldCA/IGlTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10pO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFt2QXhpc10pO1xuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpO1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuQnViYmxlQ29udHJvbGxlci5pZCA9ICdidWJibGUnO1xuQnViYmxlQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgIH1cbiAgfVxufTtcbkJ1YmJsZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gIGxldCByYXRpb1ggPSAxO1xuICBsZXQgcmF0aW9ZID0gMTtcbiAgbGV0IG9mZnNldFggPSAwO1xuICBsZXQgb2Zmc2V0WSA9IDA7XG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge31cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2V0dGVyID0gKGkpID0+ICtkYXRhW2ldO1xuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBnZXR0ZXIgPSAoaSkgPT4gK3Jlc29sdmVPYmplY3RLZXkoZGF0YVtpXSwga2V5KTtcbiAgICAgIH1cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IChjaGFydEFyZWEud2lkdGggLSBzcGFjaW5nKSAvIHJhdGlvWDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0b0RpbWVuc2lvbih0aGlzLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYICogb3V0ZXJSYWRpdXM7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcbiAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgc3RhcnRBbmdsZSArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbkRvdWdobnV0Q29udHJvbGxlci5pZCA9ICdkb3VnaG51dCc7XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ2NpcmN1bWZlcmVuY2UnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICd4JywgJ3knLCAnb2Zmc2V0JywgJ2JvcmRlcldpZHRoJywgJ3NwYWNpbmcnXVxuICAgIH0sXG4gIH0sXG4gIGN1dG91dDogJzUwJScsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnLFxuICBzcGFjaW5nOiAwLFxuICBpbmRleEF4aXM6ICdyJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgICAgbGV0IGRhdGFMYWJlbCA9IHRvb2x0aXBJdGVtLmxhYmVsO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgIGlmIChpc0FycmF5KGRhdGFMYWJlbCkpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5zbGljZSgpO1xuICAgICAgICAgICAgZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgKz0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhTGFiZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBkYXRhOiBwb2ludHMgPSBbXSwgX2RhdGFzZXR9ID0gbWV0YTtcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5kYXRhc2V0LnVwZGF0ZUNvbnRyb2xQb2ludHModGhpcy5jaGFydC5jaGFydEFyZWEsIG1ldGEuaVNjYWxlLmF4aXMpO1xuICAgIHN1cGVyLmRyYXcoKTtcbiAgfVxufVxuTGluZUNvbnRyb2xsZXIuaWQgPSAnbGluZSc7XG5MaW5lQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgc2hvd0xpbmU6IHRydWUsXG4gIHNwYW5HYXBzOiBmYWxzZSxcbn07XG5MaW5lQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICB9LFxuICB9XG59O1xuXG5jbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XS5yLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIGdldE1pbk1heCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpLnI7XG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgaWYgKHBhcnNlZCA8IHJhbmdlLm1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChvdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcbiAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcbiAgICBsZXQgYW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBkZWZhdWx0QW5nbGUgPSAzNjAgLyB0aGlzLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIGFuZ2xlICs9IHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgbGV0IG91dGVyUmFkaXVzID0gY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgPyBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKS5yKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKVxuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpc05hTih0aGlzLmdldFBhcnNlZChpbmRleCkucikgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgX2NvbXB1dGVBbmdsZShpbmRleCwgbW9kZSwgZGVmYXVsdEFuZ2xlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpXG4gICAgICA/IHRvUmFkaWFucyh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpLmFuZ2xlIHx8IGRlZmF1bHRBbmdsZSlcbiAgICAgIDogMDtcbiAgfVxufVxuUG9sYXJBcmVhQ29udHJvbGxlci5pZCA9ICdwb2xhckFyZWEnO1xuUG9sYXJBcmVhQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddXG4gICAgfSxcbiAgfSxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHN0YXJ0QW5nbGU6IDAsXG59O1xuUG9sYXJBcmVhQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jaGFydC5kYXRhLmxhYmVsc1tjb250ZXh0LmRhdGFJbmRleF0gKyAnOiAnICsgY29udGV4dC5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICB9LFxuICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzdGFydEFuZ2xlOiAwXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcbn1cblBpZUNvbnRyb2xsZXIuaWQgPSAncGllJztcblBpZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGN1dG91dDogMCxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiAnMTAwJSdcbn07XG5cbmNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHZTY2FsZS5nZXRMYWJlbHMoKVtpbmRleF0sXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxuICAgIH07XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuUmFkYXJDb250cm9sbGVyLmlkID0gJ3JhZGFyJztcblJhZGFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBlbGVtZW50czoge1xuICAgIGxpbmU6IHtcbiAgICAgIGZpbGw6ICdzdGFydCdcbiAgICB9XG4gIH0sXG59O1xuUmFkYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy54KSAmJiBpc051bWJlcih0aGlzLnkpO1xuICB9XG4gIGdldFByb3BzKHByb3BzLCBmaW5hbCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBpZiAoIWZpbmFsIHx8ICFhbmltcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuRWxlbWVudC5kZWZhdWx0cyA9IHt9O1xuRWxlbWVudC5kZWZhdWx0Um91dGVzID0gdW5kZWZpbmVkO1xuXG5jb25zdCBmb3JtYXR0ZXJzID0ge1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG4gIH0sXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBub3RhdGlvbjtcbiAgICBsZXQgZGVsdGEgPSB0aWNrVmFsdWU7XG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICBpZiAobWF4VGljayA8IDFlLTQgfHwgbWF4VGljayA+IDFlKzE1KSB7XG4gICAgICAgIG5vdGF0aW9uID0gJ3NjaWVudGlmaWMnO1xuICAgICAgfVxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG4gICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbigtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpLCAyMCksIDApO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodGlja1ZhbHVlLCBsb2NhbGUsIG9wdGlvbnMpO1xuICB9LFxuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpO1xuICAgIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICBsZXQgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0udmFsdWUgLSB0aWNrc1sxXS52YWx1ZSA6IHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWU7XG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cbnZhciBUaWNrcyA9IHtmb3JtYXR0ZXJzfTtcblxuZGVmYXVsdHMuc2V0KCdzY2FsZScsIHtcbiAgZGlzcGxheTogdHJ1ZSxcbiAgb2Zmc2V0OiBmYWxzZSxcbiAgcmV2ZXJzZTogZmFsc2UsXG4gIGJlZ2luQXRaZXJvOiBmYWxzZSxcbiAgYm91bmRzOiAndGlja3MnLFxuICBncmFjZTogMCxcbiAgZ3JpZDoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGRyYXdCb3JkZXI6IHRydWUsXG4gICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICB0aWNrTGVuZ3RoOiA4LFxuICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgIHRpY2tDb2xvcjogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMuY29sb3IsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG4gICAgYm9yZGVyV2lkdGg6IDFcbiAgfSxcbiAgdGl0bGU6IHtcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICB0ZXh0OiAnJyxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDQsXG4gICAgICBib3R0b206IDRcbiAgICB9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgbWluUm90YXRpb246IDAsXG4gICAgbWF4Um90YXRpb246IDUwLFxuICAgIG1pcnJvcjogZmFsc2UsXG4gICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgIHRleHRTdHJva2VDb2xvcjogJycsXG4gICAgcGFkZGluZzogMyxcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGF1dG9Ta2lwOiB0cnVlLFxuICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICBsYWJlbE9mZnNldDogMCxcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgbWlub3I6IHt9LFxuICAgIG1ham9yOiB7fSxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgY3Jvc3NBbGlnbjogJ25lYXInLFxuICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICBiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KScsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICB9XG59KTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2NvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnYm9yZGVyQ29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGl0bGUnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnYmVmb3JlJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYWZ0ZXInKSAmJiBuYW1lICE9PSAnY2FsbGJhY2snICYmIG5hbWUgIT09ICdwYXJzZXInLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZXMnLCB7XG4gIF9mYWxsYmFjazogJ3NjYWxlJyxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnICYmIG5hbWUgIT09ICdjYWxsYmFjaycsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyxcbn0pO1xuXG5mdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcbiAgY29uc3QgdGlja09wdHMgPSBzY2FsZS5vcHRpb25zLnRpY2tzO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcbiAgY29uc3QgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XG4gIGNvbnN0IHNwYWNpbmcgPSB0aWNrcy5sZW5ndGggLyB0aWNrc0xpbWl0O1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cbiAgY29uc3QgZmFjdG9ycyA9IF9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gZmFjdG9yc1tpXTtcbiAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xuICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xufVxuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBsZXQgaTtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG4gIG5leHQgPSBzdGFydDtcbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGRpZmYgPSBhcnJbMF0sIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XG5jb25zdCBvZmZzZXRGcm9tRWRnZSA9IChzY2FsZSwgZWRnZSwgb2Zmc2V0KSA9PiBlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICByZXN1bHQucHVzaChhcnJbTWF0aC5mbG9vcihpKV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICBjb25zdCBlcHNpbG9uID0gMWUtNjtcbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9mZnNldEdyaWRMaW5lcykge1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gKGxpbmVWYWx1ZSAtIHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4IC0gMSkpIC8gMjtcbiAgICB9XG4gICAgbGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XG4gICAgaWYgKGxpbmVWYWx1ZSA8IHN0YXJ0IC0gZXBzaWxvbiB8fCBsaW5lVmFsdWUgPiBlbmQgKyBlcHNpbG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lVmFsdWU7XG59XG5mdW5jdGlvbiBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCkge1xuICBlYWNoKGNhY2hlcywgKGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZ2MgPSBjYWNoZS5nYztcbiAgICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gICAgbGV0IGk7XG4gICAgaWYgKGdjTGVuID4gbGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xuICAgICAgICBkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XG4gICAgICB9XG4gICAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb250LCBmYWxsYmFjayk7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcbiAgcmV0dXJuIChsaW5lcyAqIGZvbnQubGluZUhlaWdodCkgKyBwYWRkaW5nLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRpY2ssXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3RpY2snXG4gIH0pO1xufVxuZnVuY3Rpb24gdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpIHtcbiAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xuICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0aXRsZUFyZ3Moc2NhbGUsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKSB7XG4gIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGNoYXJ0fSA9IHNjYWxlO1xuICBjb25zdCB7Y2hhcnRBcmVhLCBzY2FsZXN9ID0gY2hhcnQ7XG4gIGxldCByb3RhdGlvbiA9IDA7XG4gIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWSA9IChjaGFydEFyZWEuYm90dG9tICsgY2hhcnRBcmVhLnRvcCkgLyAyICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVggPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gIH1cbiAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbn1cbmNsYXNzIFNjYWxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICByZXR1cm4gcmF3O1xuICB9XG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG4gIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgIHJldHVybiB7bWluLCBtYXh9O1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWluID0gbWF4RGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtYXggOiBtaW47XG4gICAgbWF4ID0gbWluRGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtaW4gOiBtYXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICB0b3A6IHRoaXMucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgfTtcbiAgfVxuICBnZXRUaWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrcztcbiAgfVxuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICB9XG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG4gICAgdGhpcy50aWNrcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IHRoaXMud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKTtcbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XG4gICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcbiAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgfVxuICAgIGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRoaXMudGlja3MpO1xuICAgIH1cbiAgICB0aGlzLmJlZm9yZUZpdCgpO1xuICAgIHRoaXMuZml0KCk7XG4gICAgdGhpcy5hZnRlckZpdCgpO1xuICAgIHRoaXMuYWZ0ZXJVcGRhdGUoKTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgbGV0IHJldmVyc2VQaXhlbHMgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZTtcbiAgICBsZXQgc3RhcnRQaXhlbCwgZW5kUGl4ZWw7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLmxlZnQ7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLnRvcDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5ib3R0b207XG4gICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IHJldmVyc2VQaXhlbHM7XG4gICAgdGhpcy5fbGVuZ3RoID0gZW5kUGl4ZWwgLSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgfVxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gIH1cbiAgYWZ0ZXJTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgX2NhbGxIb29rcyhuYW1lKSB7XG4gICAgdGhpcy5jaGFydC5ub3RpZnlQbHVnaW5zKG5hbWUsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnNbbmFtZV0sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cbiAgYmVmb3JlQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZUJ1aWxkVGlja3MnKTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuICBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gY2FsbGJhY2sodGlja09wdHMuY2FsbGJhY2ssIFt0aWNrLnZhbHVlLCBpLCB0aWNrc10sIHRoaXMpO1xuICAgIH1cbiAgfVxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuICAgIGNvbnN0IG1heFJvdGF0aW9uID0gdGlja09wdHMubWF4Um90YXRpb247XG4gICAgbGV0IGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICBsZXQgdGlja1dpZHRoLCBtYXhIZWlnaHQsIG1heExhYmVsRGlhZ29uYWw7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhdGlja09wdHMuZGlzcGxheSB8fCBtaW5Sb3RhdGlvbiA+PSBtYXhSb3RhdGlvbiB8fCBudW1UaWNrcyA8PSAxIHx8ICF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuICAgIGNvbnN0IG1heFdpZHRoID0gX2xpbWl0VmFsdWUodGhpcy5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgIHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gdGhpcy5tYXhXaWR0aCAvIG51bVRpY2tzIDogbWF4V2lkdGggLyAobnVtVGlja3MgLSAxKTtcbiAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuICB9XG4gIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7fVxuICBiZWZvcmVGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBjb25zdCB7Y2hhcnQsIG9wdGlvbnM6IHt0aWNrczogdGlja09wdHMsIHRpdGxlOiB0aXRsZU9wdHMsIGdyaWQ6IGdyaWRPcHRzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9pc1Zpc2libGUoKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG4gIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgIGNvbnN0IHt0aWNrczoge2FsaWduLCBwYWRkaW5nfSwgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICBjb25zdCBsYWJlbHNCZWxvd1RpY2tzID0gcG9zaXRpb24gIT09ICd0b3AnICYmIHRoaXMuYXhpcyA9PT0gJ3gnO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nVG9wID0gMDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgcGFkZGluZztcbiAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCB7YXhpcywgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IGF4aXMgPT09ICd4JztcbiAgfVxuICBpc0Z1bGxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gIH1cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgICB0aGlzLmdlbmVyYXRlVGlja0xhYmVscyh0aWNrcyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodGlja3NbaV0ubGFiZWwpKSB7XG4gICAgICAgIHRpY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaWxlbi0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgfVxuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG4gICAgaWYgKCFsYWJlbFNpemVzKSB7XG4gICAgICBjb25zdCBzYW1wbGVTaXplID0gdGhpcy5vcHRpb25zLnRpY2tzLnNhbXBsZVNpemU7XG4gICAgICBsZXQgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgaWYgKHNhbXBsZVNpemUgPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdGlja3MgPSBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsU2l6ZXM7XG4gIH1cbiAgX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCBsZW5ndGgpIHtcbiAgICBjb25zdCB7Y3R4LCBfbG9uZ2VzdFRleHRDYWNoZTogY2FjaGVzfSA9IHRoaXM7XG4gICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICAgIGxldCB3aWRlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBoaWdoZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaSwgaiwgamxlbiwgbGFiZWwsIHRpY2tGb250LCBmb250U3RyaW5nLCBjYWNoZSwgbGluZUhlaWdodCwgd2lkdGgsIGhlaWdodCwgbmVzdGVkTGFiZWw7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuICAgICAgICBoZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbmVzdGVkTGFiZWwgPSBsYWJlbFtqXTtcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG4gICAgY29uc3Qgd2lkZXN0ID0gd2lkdGhzLmluZGV4T2Yod2lkZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCBoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IHZhbHVlQXQgPSAoaWR4KSA9PiAoe3dpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLCBoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fVxuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpIHtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZVBpeGVscykge1xuICAgICAgZGVjaW1hbCA9IDEgLSBkZWNpbWFsO1xuICAgIH1cbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBfaW50MTZSYW5nZSh0aGlzLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwodGhpcy5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG4gIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZVBpeGVscyA/IDEgLSBkZWNpbWFsIDogZGVjaW1hbDtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgcmV0dXJuIG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG4gICAgICBtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuICAgICAgMDtcbiAgfVxuICBnZXRDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzIHx8IFtdO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRpY2suJGNvbnRleHQgfHxcblx0XHRcdFx0KHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XG4gIH1cbiAgX3RpY2tTaXplKCkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHJvdCA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKHJvdCkpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdCkpO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcbiAgICBjb25zdCBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG4gICAgICA6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG4gIH1cbiAgX2lzVmlzaWJsZSgpIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5vcHRpb25zLmRpc3BsYXk7XG4gICAgaWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuICEhZGlzcGxheTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG4gIF9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtncmlkLCBwb3NpdGlvbn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyT3B0cy5kcmF3Qm9yZGVyID8gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aCA6IDA7XG4gICAgY29uc3QgYXhpc0hhbGZXaWR0aCA9IGF4aXNXaWR0aCAvIDI7XG4gICAgY29uc3QgYWxpZ25Cb3JkZXJWYWx1ZSA9IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICByZXR1cm4gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCBheGlzV2lkdGgpO1xuICAgIH07XG4gICAgbGV0IGJvcmRlclZhbHVlLCBpLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XG4gICAgbGV0IHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTI7XG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XG4gICAgICB0eDEgPSB0aGlzLnJpZ2h0IC0gdGw7XG4gICAgICB0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdHkxICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0eDEgLSB0bDtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IG9wdHNBdEluZGV4LmxpbmVXaWR0aDtcbiAgICAgIGNvbnN0IGxpbmVDb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCBib3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuICAgICAgaWYgKGxpbmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdHgxLFxuICAgICAgICB0eTEsXG4gICAgICAgIHR4MixcbiAgICAgICAgdHkyLFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MixcbiAgICAgICAgd2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB7YWxpZ24sIGNyb3NzQWxpZ24sIHBhZGRpbmcsIG1pcnJvcn0gPSBvcHRpb25UaWNrcztcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIGxhYmVsID0gdGljay5sYWJlbDtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IHRpY2tUZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHggPSBwaXhlbDtcbiAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgIHRleHRPZmZzZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgbGV0IGJhY2tkcm9wO1xuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsYWJlbFNpemVzLmhlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG4gICAgICAgIGxldCB0b3AgPSB5ICsgdGV4dE9mZnNldCAtIGxhYmVsUGFkZGluZy50b3A7XG4gICAgICAgIGxldCBsZWZ0ID0geCAtIGxhYmVsUGFkZGluZy5sZWZ0O1xuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcbiAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIHRleHRBbGlnbjogdGlja1RleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICB0cmFuc2xhdGlvbjogW3gsIHldLFxuICAgICAgICBiYWNrZHJvcCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG4gICAgaWYgKHRpY2tzLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnZW5kJykge1xuICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgIGFsaWduID0gJ2lubmVyJztcbiAgICB9XG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG4gIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczoge2Nyb3NzQWxpZ24sIG1pcnJvciwgcGFkZGluZ319ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3Qgd2lkZXN0ID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgbGV0IHRleHRBbGlnbjtcbiAgICBsZXQgeDtcbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggKz0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4ID0gdGhpcy5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gd2lkZXN0IC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggPSB0aGlzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiB7dGV4dEFsaWduLCB4fTtcbiAgfVxuICBfY29tcHV0ZUxhYmVsQXJlYSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpY2tzLm1pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogY2hhcnQud2lkdGh9O1xuICAgIH1cbiAgfVxuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGdldExpbmVXaWR0aEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWdyaWQuZGlzcGxheSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCBpbmRleCA9IHRpY2tzLmZpbmRJbmRleCh0ID0+IHQudmFsdWUgPT09IHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3Qgb3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIHJldHVybiBvcHRzLmxpbmVXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZHJhd0dyaWQoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ3JpZExpbmVJdGVtcyB8fCAodGhpcy5fZ3JpZExpbmVJdGVtcyA9IHRoaXMuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpID0+IHtcbiAgICAgIGlmICghc3R5bGUud2lkdGggfHwgIXN0eWxlLmNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGdyaWQuZHJhd09uQ2hhcnRBcmVhKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS54MSwgeTogaXRlbS55MX0sXG4gICAgICAgICAgICB7eDogaXRlbS54MiwgeTogaXRlbS55Mn0sXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IHtjaGFydCwgY3R4LCBvcHRpb25zOiB7Z3JpZH19ID0gdGhpcztcbiAgICBjb25zdCBib3JkZXJPcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBncmlkLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoO1xuICAgIGNvbnN0IGJvcmRlclZhbHVlID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmxlZnQsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeDIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHkxID0geTIgPSBib3JkZXJWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeTEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy50b3AsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeTIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlck9wdHMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyT3B0cy5ib3JkZXJDb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGlmICghb3B0aW9uVGlja3MuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xhYmVsSXRlbXMgfHwgKHRoaXMuX2xhYmVsSXRlbXMgPSB0aGlzLl9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCB0aWNrRm9udCA9IGl0ZW0uZm9udDtcbiAgICAgIGNvbnN0IGxhYmVsID0gaXRlbS5sYWJlbDtcbiAgICAgIGlmIChpdGVtLmJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBpdGVtLmJhY2tkcm9wLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaXRlbS5iYWNrZHJvcC5sZWZ0LCBpdGVtLmJhY2tkcm9wLnRvcCwgaXRlbS5iYWNrZHJvcC53aWR0aCwgaXRlbS5iYWNrZHJvcC5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgbGV0IHkgPSBpdGVtLnRleHRPZmZzZXQ7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGFiZWwsIDAsIHksIHRpY2tGb250LCBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb3NpdGlvbiwgdGl0bGUsIHJldmVyc2V9fSA9IHRoaXM7XG4gICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb24gPT09ICdjZW50ZXInIHx8IGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcuYm90dG9tO1xuICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IGZvbnQubGluZUhlaWdodCAqICh0aXRsZS50ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy50b3A7XG4gICAgfVxuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRpdGxlQXJncyh0aGlzLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbik7XG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICB9XG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gU2NhbGUucHJvdG90eXBlLmRyYXcpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiB0eixcbiAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICAgIHRoaXMuZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogZ3ogKyAxLFxuICAgICAgZHJhdzogKCkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiB0eixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfV07XG4gIH1cbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5jaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXhpc0lEID0gdGhpcy5heGlzICsgJ0F4aXNJRCc7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpbmRleCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICByZXR1cm4gdG9Gb250KG9wdHMuZm9udCk7XG4gIH1cbiAgX21heERpZ2l0cygpIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICByZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQpIC8gZm9udFNpemU7XG4gIH1cbn1cblxuY2xhc3MgVHlwZWRSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNjb3BlLCBvdmVycmlkZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLml0ZW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBpc0ZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0eXBlLnByb3RvdHlwZSk7XG4gIH1cbiAgcmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICAgIGxldCBwYXJlbnRTY29wZTtcbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XG4gICAgICBwYXJlbnRTY29wZSA9IHRoaXMucmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogJyArIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG4gICAgaXRlbXNbaWRdID0gaXRlbTtcbiAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgIGRlZmF1bHRzLm92ZXJyaWRlKGl0ZW0uaWQsIGl0ZW0ub3ZlcnJpZGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG4gIGdldChpZCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zW2lkXTtcbiAgfVxuICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIGRlbGV0ZSBpdGVtc1tpZF07XG4gICAgfVxuICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICBjb25zdCBpdGVtRGVmYXVsdHMgPSBtZXJnZShPYmplY3QuY3JlYXRlKG51bGwpLCBbXG4gICAgcGFyZW50U2NvcGUgPyBkZWZhdWx0cy5nZXQocGFyZW50U2NvcGUpIDoge30sXG4gICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICBpdGVtLmRlZmF1bHRzXG4gIF0pO1xuICBkZWZhdWx0cy5zZXQoc2NvcGUsIGl0ZW1EZWZhdWx0cyk7XG4gIGlmIChpdGVtLmRlZmF1bHRSb3V0ZXMpIHtcbiAgICByb3V0ZURlZmF1bHRzKHNjb3BlLCBpdGVtLmRlZmF1bHRSb3V0ZXMpO1xuICB9XG4gIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoc2NvcGUsIGl0ZW0uZGVzY3JpcHRvcnMpO1xuICB9XG59XG5mdW5jdGlvbiByb3V0ZURlZmF1bHRzKHNjb3BlLCByb3V0ZXMpIHtcbiAgT2JqZWN0LmtleXMocm91dGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eVBhcnRzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gcHJvcGVydHlQYXJ0cy5wb3AoKTtcbiAgICBjb25zdCBzb3VyY2VTY29wZSA9IFtzY29wZV0uY29uY2F0KHByb3BlcnR5UGFydHMpLmpvaW4oJy4nKTtcbiAgICBjb25zdCBwYXJ0cyA9IHJvdXRlc1twcm9wZXJ0eV0uc3BsaXQoJy4nKTtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gcGFydHMucG9wKCk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGUgPSBwYXJ0cy5qb2luKCcuJyk7XG4gICAgZGVmYXVsdHMucm91dGUoc291cmNlU2NvcGUsIHNvdXJjZU5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0lDaGFydENvbXBvbmVudChwcm90bykge1xuICByZXR1cm4gJ2lkJyBpbiBwcm90byAmJiAnZGVmYXVsdHMnIGluIHByb3RvO1xufVxuXG5jbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuICBhZGQoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncyk7XG4gIH1cbiAgcmVtb3ZlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncyk7XG4gIH1cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgYWRkRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG4gIGFkZFNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgZ2V0Q29udHJvbGxlcihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuY29udHJvbGxlcnMsICdjb250cm9sbGVyJyk7XG4gIH1cbiAgZ2V0RWxlbWVudChpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuZWxlbWVudHMsICdlbGVtZW50Jyk7XG4gIH1cbiAgZ2V0UGx1Z2luKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5wbHVnaW5zLCAncGx1Z2luJyk7XG4gIH1cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cbiAgcmVtb3ZlQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIHJlbW92ZVBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG4gIHJlbW92ZVNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuICBfZWFjaChtZXRob2QsIGFyZ3MsIHR5cGVkUmVnaXN0cnkpIHtcbiAgICBbLi4uYXJnc10uZm9yRWFjaChhcmcgPT4ge1xuICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCAocmVnID09PSB0aGlzLnBsdWdpbnMgJiYgYXJnLmlkKSkge1xuICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFjaChhcmcsIGl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgaXRlbVJlZywgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsYmFjayhjb21wb25lbnRbJ2JlZm9yZScgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpO1xuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsYmFjayhjb21wb25lbnRbJ2FmdGVyJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gIH1cbiAgX2dldFJlZ2lzdHJ5Rm9yVHlwZSh0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tpXTtcbiAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBsdWdpbnM7XG4gIH1cbiAgX2dldChpZCwgdHlwZWRSZWdpc3RyeSwgdHlwZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0eXBlZFJlZ2lzdHJ5LmdldChpZCk7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBpZCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyB0eXBlICsgJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbn1cbnZhciByZWdpc3RyeSA9IG5ldyBSZWdpc3RyeSgpO1xuXG5jbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YTogcG9pbnRzID0gW119ID0gbWV0YTtcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtzaG93TGluZX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiBzaG93TGluZSkge1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSByZWdpc3RyeS5nZXRFbGVtZW50KCdsaW5lJyk7XG4gICAgfVxuICAgIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgbGV0IG1heCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbn1cblNjYXR0ZXJDb250cm9sbGVyLmlkID0gJ3NjYXR0ZXInO1xuU2NhdHRlckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgc2hvd0xpbmU6IGZhbHNlLFxuICBmaWxsOiBmYWxzZVxufTtcblNjYXR0ZXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBtb2RlOiAncG9pbnQnXG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuICcoJyArIGl0ZW0ubGFiZWwgKyAnLCAnICsgaXRlbS5mb3JtYXR0ZWRWYWx1ZSArICcpJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgeDoge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29udHJvbGxlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5CYXJDb250cm9sbGVyOiBCYXJDb250cm9sbGVyLFxuQnViYmxlQ29udHJvbGxlcjogQnViYmxlQ29udHJvbGxlcixcbkRvdWdobnV0Q29udHJvbGxlcjogRG91Z2hudXRDb250cm9sbGVyLFxuTGluZUNvbnRyb2xsZXI6IExpbmVDb250cm9sbGVyLFxuUG9sYXJBcmVhQ29udHJvbGxlcjogUG9sYXJBcmVhQ29udHJvbGxlcixcblBpZUNvbnRyb2xsZXI6IFBpZUNvbnRyb2xsZXIsXG5SYWRhckNvbnRyb2xsZXI6IFJhZGFyQ29udHJvbGxlcixcblNjYXR0ZXJDb250cm9sbGVyOiBTY2F0dGVyQ29udHJvbGxlclxufSk7XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC4nKTtcbn1cbmNsYXNzIERhdGVBZGFwdGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIH1cbiAgaW5pdChjaGFydE9wdGlvbnMpIHt9XG4gIGZvcm1hdHMoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgcGFyc2UodmFsdWUsIGZvcm1hdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGZvcm1hdCh0aW1lc3RhbXAsIGZvcm1hdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGFkZCh0aW1lc3RhbXAsIGFtb3VudCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGRpZmYoYSwgYiwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHN0YXJ0T2YodGltZXN0YW1wLCB1bml0LCB3ZWVrZGF5KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZW5kT2YodGltZXN0YW1wLCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbn1cbkRhdGVBZGFwdGVyLm92ZXJyaWRlID0gZnVuY3Rpb24obWVtYmVycykge1xuICBPYmplY3QuYXNzaWduKERhdGVBZGFwdGVyLnByb3RvdHlwZSwgbWVtYmVycyk7XG59O1xudmFyIGFkYXB0ZXJzID0ge1xuICBfZGF0ZTogRGF0ZUFkYXB0ZXJcbn07XG5cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChtZXRhc2V0LCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IHtjb250cm9sbGVyLCBkYXRhLCBfc29ydGVkfSA9IG1ldGFzZXQ7XG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgcmV0dXJuIGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBlbCA9IGRhdGFbMF07XG4gICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiBlbC5nZXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiBlbC5nZXRSYW5nZShheGlzKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcbiAgICAgICAgY29uc3QgZW5kID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlICsgcmFuZ2UpO1xuICAgICAgICByZXR1cm4ge2xvOiBzdGFydC5sbywgaGk6IGVuZC5oaX07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuZnVuY3Rpb24gZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgaGFuZGxlciwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW2F4aXNdO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXTtcbiAgICBjb25zdCB7bG8sIGhpfSA9IGJpbmFyeVNlYXJjaChtZXRhc2V0c1tpXSwgYXhpcywgdmFsdWUsIGludGVyc2VjdCk7XG4gICAgZm9yIChsZXQgaiA9IGxvOyBqIDw9IGhpOyArK2opIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuICBjb25zdCB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuICBjb25zdCB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xuICByZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcbiAgICBjb25zdCBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIV9pc1BvaW50SW5BcmVhKGVsZW1lbnQsIGNoYXJ0LmNoYXJ0QXJlYSwgMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfTtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xuICAgIGlmIChfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBpblJhbmdlID0gZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGlmIChpbnRlcnNlY3QgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XG4gICAgaWYgKCFwb2ludEluQXJlYSAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xuICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdFxuICAgID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbilcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG59XG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9KTtcbiAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxudmFyIEludGVyYWN0aW9uID0ge1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMsXG4gIG1vZGVzOiB7XG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKVxuICAgICAgICA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGxldCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6XG4gICAgICAgIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IGl0ZW1zWzBdLmRhdGFzZXRJbmRleDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuZGF0YTtcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudDogZGF0YVtpXSwgZGF0YXNldEluZGV4LCBpbmRleDogaX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcbiAgICBwb2ludChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3gnLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcbiAgICB5KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd5Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgU1RBVElDX1BPU0lUSU9OUyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gdi5wb3MgPT09IHBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcbiAgcmV0dXJuIGFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB2MCA9IHJldmVyc2UgPyBiIDogYTtcbiAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcbiAgICByZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuICAgICAgdjAuaW5kZXggLSB2MS5pbmRleCA6XG4gICAgICB2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBib3gsIHBvcywgc3RhY2ssIHN0YWNrV2VpZ2h0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xuICBjb25zdCBzdGFja3MgPSB7fTtcbiAgZm9yIChjb25zdCB3cmFwIG9mIGxheW91dHMpIHtcbiAgICBjb25zdCB7c3RhY2ssIHBvcywgc3RhY2tXZWlnaHR9ID0gd3JhcDtcbiAgICBpZiAoIXN0YWNrIHx8ICFTVEFUSUNfUE9TSVRJT05TLmluY2x1ZGVzKHBvcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBfc3RhY2sgPSBzdGFja3Nbc3RhY2tdIHx8IChzdGFja3Nbc3RhY2tdID0ge2NvdW50OiAwLCBwbGFjZWQ6IDAsIHdlaWdodDogMCwgc2l6ZTogMH0pO1xuICAgIF9zdGFjay5jb3VudCsrO1xuICAgIF9zdGFjay53ZWlnaHQgKz0gc3RhY2tXZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBidWlsZExheW91dEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcbiAgY29uc3QgZnVsbFNpemUgPSBzb3J0QnlXZWlnaHQobGF5b3V0Qm94ZXMuZmlsdGVyKHdyYXAgPT4gd3JhcC5ib3guZnVsbFNpemUpLCB0cnVlKTtcbiAgY29uc3QgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcbiAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xuICBjb25zdCB0b3AgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3RvcCcpLCB0cnVlKTtcbiAgY29uc3QgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG4gIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XG4gIGNvbnN0IGNlbnRlclZlcnRpY2FsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneScpO1xuICByZXR1cm4ge1xuICAgIGZ1bGxTaXplLFxuICAgIGxlZnRBbmRUb3A6IGxlZnQuY29uY2F0KHRvcCksXG4gICAgcmlnaHRBbmRCb3R0b206IHJpZ2h0LmNvbmNhdChjZW50ZXJWZXJ0aWNhbCkuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpLFxuICAgIGNoYXJ0QXJlYTogZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2NoYXJ0QXJlYScpLFxuICAgIHZlcnRpY2FsOiBsZWZ0LmNvbmNhdChyaWdodCkuY29uY2F0KGNlbnRlclZlcnRpY2FsKSxcbiAgICBob3Jpem9udGFsOiB0b3AuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuZnVuY3Rpb24gdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3hQYWRkaW5nKSB7XG4gIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcbiAgbWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuICBtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG4gIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKSB7XG4gIGNvbnN0IHtwb3MsIGJveH0gPSBsYXlvdXQ7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICBjaGFydEFyZWFbcG9zXSAtPSBsYXlvdXQuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7c2l6ZTogMCwgY291bnQ6IDF9O1xuICAgIHN0YWNrLnNpemUgPSBNYXRoLm1heChzdGFjay5zaXplLCBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGgpO1xuICAgIGxheW91dC5zaXplID0gc3RhY2suc2l6ZSAvIHN0YWNrLmNvdW50O1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xuICB9XG4gIGlmIChib3guZ2V0UGFkZGluZykge1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94LmdldFBhZGRpbmcoKSk7XG4gIH1cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuICByZXR1cm4gbGF5b3V0Lmhvcml6b250YWxcbiAgICA/IHtzYW1lOiB3aWR0aENoYW5nZWQsIG90aGVyOiBoZWlnaHRDaGFuZ2VkfVxuICAgIDoge3NhbWU6IGhlaWdodENoYW5nZWQsIG90aGVyOiB3aWR0aENoYW5nZWR9O1xufVxuZnVuY3Rpb24gaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIG1hcmdpbkZvclBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfTtcbiAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zKSA9PiB7XG4gICAgICBtYXJnaW5bcG9zXSA9IE1hdGgubWF4KGNoYXJ0QXJlYVtwb3NdLCBtYXhQYWRkaW5nW3Bvc10pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJnaW47XG4gIH1cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCByZWZpdEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGgsIHJlZml0ID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGJveGVzW2ldO1xuICAgIGJveCA9IGxheW91dC5ib3g7XG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgb3RoZXI7XG4gICAgaWYgKCFib3guZnVsbFNpemUpIHtcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmaXQgJiYgZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykgfHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHNldEJveERpbXMoYm94LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgYm94LnRvcCA9IHRvcDtcbiAgYm94LmxlZnQgPSBsZWZ0O1xuICBib3gucmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIGJveC5ib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIGJveC53aWR0aCA9IHdpZHRoO1xuICBib3guaGVpZ2h0ID0gaGVpZ2h0O1xufVxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuICBmb3IgKGNvbnN0IGxheW91dCBvZiBib3hlcykge1xuICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7Y291bnQ6IDEsIHBsYWNlZDogMCwgd2VpZ2h0OiAxfTtcbiAgICBjb25zdCB3ZWlnaHQgPSAobGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0KSB8fCAxO1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjaGFydEFyZWEudyAqIHdlaWdodDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHN0YWNrLnNpemUgfHwgYm94LmhlaWdodDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB5ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB1c2VyUGFkZGluZy5sZWZ0LCB5LCBwYXJhbXMub3V0ZXJXaWR0aCAtIHVzZXJQYWRkaW5nLnJpZ2h0IC0gdXNlclBhZGRpbmcubGVmdCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHk7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XG4gICAgICB5ID0gYm94LmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhcnRBcmVhLmggKiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHN0YWNrLnNpemUgfHwgYm94LndpZHRoO1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHggPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgY2hhcnRBcmVhLnRvcCArIHN0YWNrLnBsYWNlZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHg7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gaGVpZ2h0O1xuICAgICAgeCA9IGJveC5yaWdodDtcbiAgICB9XG4gIH1cbiAgY2hhcnRBcmVhLnggPSB4O1xuICBjaGFydEFyZWEueSA9IHk7XG59XG5kZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcbiAgYXV0b1BhZGRpbmc6IHRydWUsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfVxufSk7XG52YXIgbGF5b3V0cyA9IHtcbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG4gICAgaXRlbS5mdWxsU2l6ZSA9IGl0ZW0uZnVsbFNpemUgfHwgZmFsc2U7XG4gICAgaXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG4gICAgaXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9O1xuICAgIGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XG4gIH0sXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG4gIGNvbmZpZ3VyZShjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuICAgIGl0ZW0uZnVsbFNpemUgPSBvcHRpb25zLmZ1bGxTaXplO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgIGl0ZW0ud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gIH0sXG4gIHVwZGF0ZShjaGFydCwgd2lkdGgsIGhlaWdodCwgbWluUGFkZGluZykge1xuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG4gICAgZWFjaChjaGFydC5ib3hlcywgYm94ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYm94LmJlZm9yZUxheW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBib3guYmVmb3JlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmcsXG4gICAgICB3OiBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgIHk6IHBhZGRpbmcudG9wXG4gICAgfSwgcGFkZGluZyk7XG4gICAgY29uc3Qgc3RhY2tzID0gc2V0TGF5b3V0RGltcyh2ZXJ0aWNhbEJveGVzLmNvbmNhdChob3Jpem9udGFsQm94ZXMpLCBwYXJhbXMpO1xuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSkge1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcbiAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0QXJlYS54ICs9IGNoYXJ0QXJlYS53O1xuICAgIGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxuICAgICAgdG9wOiBjaGFydEFyZWEudG9wLFxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXG4gICAgICBib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaCxcbiAgICAgIGhlaWdodDogY2hhcnRBcmVhLmgsXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXG4gICAgfTtcbiAgICBlYWNoKGJveGVzLmNoYXJ0QXJlYSwgKGxheW91dCkgPT4ge1xuICAgICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICAgIE9iamVjdC5hc3NpZ24oYm94LCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgYm94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgsIHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxuY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge31cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICB9XG59XG5cbmNsYXNzIEJhc2ljUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcbmNvbnN0IGlzTnVsbE9yRW1wdHkgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJyc7XG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gIGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG4gICAgaW5pdGlhbDoge1xuICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXG4gICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJXaWR0aCkpIHtcbiAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcbiAgICBpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChhc3BlY3RSYXRpbyB8fCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcbiAgICAgIGlmIChkaXNwbGF5SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICBjb25zdCB7eCwgeX0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBjaGFydCxcbiAgICBuYXRpdmU6IGV2ZW50LFxuICAgIHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuICAgIHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuICB9O1xufVxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpZiAoZHByID09PSBvbGREZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9sZERldmljZVBpeGVsUmF0aW8gPSBkcHI7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcbiAgICAgIHJlc2l6ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKSB7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9LCB3aW5kb3cpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgY29uc3Qgd2lkdGggPSBlbnRyeS5jb250ZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgcHJveHkgPSB0aHJvdHRsZWQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgIH1cbiAgfSwgY2hhcnQsIChhcmdzKSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIHJldHVybiBbZXZlbnQsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICB9KTtcbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jYW52YXMgPT09IGNhbnZhcykge1xuICAgICAgaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgaWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjYW52YXMuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSk7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiBjcmVhdGVBdHRhY2hPYnNlcnZlcixcbiAgICAgIGRldGFjaDogY3JlYXRlRGV0YWNoT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IGNyZWF0ZVJlc2l6ZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgY3JlYXRlUHJveHlBbmRMaXN0ZW47XG4gICAgcHJveGllc1t0eXBlXSA9IGhhbmRsZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKSB7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBwcm94eSA9IHByb3hpZXNbdHlwZV07XG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IHJlbGVhc2VPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgIGhhbmRsZXIoY2hhcnQsIHR5cGUsIHByb3h5KTtcbiAgICBwcm94aWVzW3R5cGVdID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG4gIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICByZXR1cm4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gIH1cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gIGlmICghX2lzRG9tU3VwcG9ydGVkKCkgfHwgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykpIHtcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gRG9tUGxhdGZvcm07XG59XG5cbmNsYXNzIFBsdWdpblNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0ID0gW107XG4gIH1cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbHRlciA/IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KS5maWx0ZXIoZmlsdGVyKSA6IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKTtcbiAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgICAgY29uc3QgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XG4gICAgICBjb25zdCBwYXJhbXMgPSBbY2hhcnQsIGFyZ3MsIGRlc2NyaXB0b3Iub3B0aW9uc107XG4gICAgICBpZiAoY2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG4gIF9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpIHtcbiAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHgucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKHByZXZpb3VzRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKSwgY2hhcnQsICdzdG9wJyk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IGxvY2FsSWRzID0ge307XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gbG9jYWxbaV07XG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICBsb2NhbElkc1twbHVnaW4uaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtwbHVnaW5zLCBsb2NhbElkc307XG59XG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICBpZiAoIWFsbCAmJiBvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHtwbHVnaW5zLCBsb2NhbElkc30sIG9wdGlvbnMsIGFsbCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGNoYXJ0LmdldENvbnRleHQoKTtcbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IG9wdHMgPSBnZXRPcHRzKG9wdGlvbnNbaWRdLCBhbGwpO1xuICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcGx1Z2luLFxuICAgICAgb3B0aW9uczogcGx1Z2luT3B0cyhjaGFydC5jb25maWcsIHtwbHVnaW4sIGxvY2FsOiBsb2NhbElkc1tpZF19LCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywge3BsdWdpbiwgbG9jYWx9LCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIGlmIChsb2NhbCAmJiBwbHVnaW4uZGVmYXVsdHMpIHtcbiAgICBzY29wZXMucHVzaChwbHVnaW4uZGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7XG4gICAgc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBhbGxLZXlzOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGlkLCBpbmRleEF4aXMpIHtcbiAgbGV0IGF4aXMgPSBpZDtcbiAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzO1xuICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG4gIH1cbiAgcmV0dXJuIGF4aXM7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkID09PSAneCcgfHwgaWQgPT09ICd5Jykge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICByZXR1cm4gc2NhbGVPcHRpb25zLmF4aXMgfHwgYXhpc0Zyb21Qb3NpdGlvbihzY2FsZU9wdGlvbnMucG9zaXRpb24pIHx8IGlkLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBmaXJzdElEcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIE9iamVjdC5rZXlzKGNvbmZpZ1NjYWxlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3Qgc2NhbGVDb25mID0gY29uZmlnU2NhbGVzW2lkXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNjYWxlQ29uZikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBpZiAoc2NhbGVDb25mLl9wcm94eSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgSWdub3JpbmcgcmVzb2x2ZXIgcGFzc2VkIGFzIG9wdGlvbnMgZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVDb25mKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgZmlyc3RJRHNbYXhpc10gPSBmaXJzdElEc1theGlzXSB8fCBpZDtcbiAgICBzY2FsZXNbaWRdID0gbWVyZ2VJZihPYmplY3QuY3JlYXRlKG51bGwpLCBbe2F4aXN9LCBzY2FsZUNvbmYsIGRlZmF1bHRTY2FsZU9wdGlvbnNbYXhpc10sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElkXV0pO1xuICB9KTtcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgZmlyc3RJRHNbYXhpc10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcbiAgcmV0dXJuIHNjYWxlcztcbn1cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbml0RGF0YShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcbiAgZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuICBpbml0T3B0aW9ucyhjb25maWcpO1xuICByZXR1cm4gY29uZmlnO1xufVxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuY29uc3QgYWRkSWZGb3VuZCA9IChzZXQsIG9iaiwga2V5KSA9PiB7XG4gIGNvbnN0IG9wdHMgPSByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KTtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldC5hZGQob3B0cyk7XG4gIH1cbn07XG5jbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcbiAgfVxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fY29uZmlnLmRhdGEgPSBpbml0RGF0YShkYXRhKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcbiAgICBrZXlMaXN0cy5mb3JFYWNoKGtleXMgPT4ge1xuICAgICAgaWYgKG1haW5TY29wZSkge1xuICAgICAgICBzY29wZXMuYWRkKG1haW5TY29wZSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICBvcHRpb25zLFxuICAgICAgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LFxuICAgICAgZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge30sXG4gICAgICB7dHlwZX0sXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIGRlc2NyaXB0b3JzXG4gICAgXTtcbiAgfVxuICByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHskc2hhcmVkOiB0cnVlfTtcbiAgICBjb25zdCB7cmVzb2x2ZXIsIHN1YlByZWZpeGVzfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZXI7XG4gICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5jb25zdCBoYXNGdW5jdGlvbiA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKVxuICAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjIHx8IGlzRnVuY3Rpb24odmFsdWVba2V5XSksIGZhbHNlKTtcbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICBjb25zdCB7aXNTY3JpcHRhYmxlLCBpc0luZGV4YWJsZX0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xuICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgIGNvbnN0IHZhbHVlID0gKGluZGV4YWJsZSB8fCBzY3JpcHRhYmxlKSAmJiBwcm94eVtwcm9wXTtcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXG4gICAgICB8fCAoaW5kZXhhYmxlICYmIGlzQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjMuOS4xXCI7XG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXVxuICAgICAgPyBhW2wyXSAtIGJbbDJdXG4gICAgICA6IGFbbDFdIC0gYltsMV07XG4gIH07XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIGdldENhbnZhcyhpdGVtKSB7XG4gIGlmIChfaXNEb21TdXBwb3J0ZWQoKSAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbSAmJiBpdGVtLmxlbmd0aCkge1xuICAgIGl0ZW0gPSBpdGVtWzBdO1xuICB9XG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5mdW5jdGlvbiBtb3ZlTnVtZXJpY0tleXMob2JqLCBzdGFydCwgbW92ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGludEtleSA9ICtrZXk7XG4gICAgaWYgKGludEtleSA+PSBzdGFydCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIGlmIChtb3ZlID4gMCB8fCBpbnRLZXkgPiBzdGFydCkge1xuICAgICAgICBvYmpbaW50S2V5ICsgbW92ZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZUxhc3RFdmVudChlLCBsYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKSB7XG4gIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQ2xpY2spIHtcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuY2xhc3MgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihpdGVtLCB1c2VyQ29uZmlnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdDaGFydCA9IGdldENoYXJ0KGluaXRpYWxDYW52YXMpO1xuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW52YXMgaXMgYWxyZWFkeSBpbiB1c2UuIENoYXJ0IHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuaWQgKyAnXFwnJyArXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5jYW52YXMuaWQgKyAnXFwnIGNhbiBiZSByZXVzZWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKGNvbmZpZy5wbGF0Zm9ybSB8fCBfZGV0ZWN0UGxhdGZvcm0oaW5pdGlhbENhbnZhcykpKCk7XG4gICAgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpbml0aWFsQ2FudmFzLCBvcHRpb25zLmFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgdGhpcy5fbWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLl9zdGFja3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3hlcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydEFyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdjb21wbGV0ZScsIG9uQW5pbWF0aW9uc0NvbXBsZXRlKTtcbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ3Byb2dyZXNzJywgb25BbmltYXRpb25Qcm9ncmVzcyk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICByZXR1cm4gX2FzcGVjdFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVJbml0Jyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRpbmFTY2FsZSh0aGlzLCB0aGlzLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJJbml0Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdG9wKCkge1xuICAgIGFuaW1hdG9yLnN0b3AodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHt3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gIH1cbiAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IG5ld1JhdGlvID0gb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvIHx8IHRoaXMucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLndpZHRoID8gJ3Jlc2l6ZScgOiAnYXR0YWNoJztcbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2l6ZScsIHtzaXplOiBuZXdTaXplfSk7XG4gICAgY2FsbGJhY2sob3B0aW9ucy5vblJlc2l6ZSwgW3RoaXMsIG5ld1NpemVdLCB0aGlzKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlT3B0cyA9IG9wdGlvbnMuc2NhbGVzO1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZSgob2JqLCBpZCkgPT4ge1xuICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgbGV0IGl0ZW1zID0gW107XG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGVhY2goaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcbiAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuICAgICAgaWYgKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiwgYXhpcykgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuICAgICAgc2NhbGUuaW5pdChzY2FsZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWFjaChzY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5jb25maWd1cmUodGhpcywgc2NhbGUsIHNjYWxlLm9wdGlvbnMpO1xuICAgICAgbGF5b3V0cy5hZGRCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICB9XG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG4gICAgbWV0YXNldHMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xuICAgICAgZm9yIChsZXQgaSA9IG51bURhdGE7IGkgPCBudW1NZXRhOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YXNldHMuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuICB9XG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gW107XG4gICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmRhdGEuZGF0YXNldHM7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG4gICAgICBpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YS50eXBlID0gdHlwZTtcbiAgICAgIG1ldGEuaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICBtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xuICAgICAgbWV0YS5pbmRleCA9IGk7XG4gICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xuICAgICAgbWV0YS52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpO1xuICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICBjb25zdCB7ZGF0YXNldEVsZW1lbnRUeXBlLCBkYXRhRWxlbWVudFR5cGV9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ29udHJvbGxlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl91cGRhdGVNZXRhc2V0cygpO1xuICAgIHJldHVybiBuZXdDb250cm9sbGVycztcbiAgfVxuICBfcmVzZXRFbGVtZW50cygpIHtcbiAgICBlYWNoKHRoaXMuZGF0YS5kYXRhc2V0cywgKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNldCcpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcbiAgICB0aGlzLl91cGRhdGVTY2FsZXMoKTtcbiAgICB0aGlzLl9jaGVja0V2ZW50QmluZGluZ3MoKTtcbiAgICB0aGlzLl91cGRhdGVIaWRkZW5JbmRpY2VzKCk7XG4gICAgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSB0aGlzLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICB9XG4gICAgbWluUGFkZGluZyA9IHRoaXMuX21pblBhZGRpbmcgPSBvcHRpb25zLmxheW91dC5hdXRvUGFkZGluZyA/IG1pblBhZGRpbmcgOiAwO1xuICAgIHRoaXMuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVEYXRhc2V0cyhtb2RlKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge21vZGV9KTtcbiAgICB0aGlzLl9sYXllcnMuc29ydChjb21wYXJlMkxldmVsKCd6JywgJ19pZHgnKSk7XG4gICAgY29uc3Qge19hY3RpdmUsIF9sYXN0RXZlbnR9ID0gdGhpcztcbiAgICBpZiAoX2xhc3RFdmVudCkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKF9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoX2FjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG4gIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cbiAgX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7bWV0aG9kLCBzdGFydCwgY291bnR9IG9mIGNoYW5nZXMpIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICB9XG4gIH1cbiAgX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICBjb25zdCBfZGF0YUNoYW5nZXMgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICBpZiAoIV9kYXRhQ2hhbmdlcyB8fCAhX2RhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRDb3VudCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbWFrZVNldCA9IChpZHgpID0+IG5ldyBTZXQoXG4gICAgICBfZGF0YUNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGNbMF0gPT09IGlkeClcbiAgICAgICAgLm1hcCgoYywgaSkgPT4gaSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSlcbiAgICApO1xuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG4gIF91cGRhdGVMYXlvdXQobWluUGFkZGluZykge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgZWFjaCh0aGlzLmJveGVzLCAoYm94KSA9PiB7XG4gICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoaSwgaXNGdW5jdGlvbihtb2RlKSA/IG1vZGUoe2RhdGFzZXRJbmRleDogaX0pIDogbW9kZSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gICAgY29uc3QgYXJncyA9IHttZXRhLCBpbmRleCwgbW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX07XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cbiAgZHJhdygpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAodGhpcy5fcmVzaXplQmVmb3JlRHJhdykge1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0aGlzLl9kcmF3RGF0YXNldChtZXRhc2V0c1tpXSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuICBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGNsaXAgPSBtZXRhLl9jbGlwO1xuICAgIGNvbnN0IHVzZUNsaXAgPSAhY2xpcC5kaXNhYmxlZDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXREcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IHRoaXMud2lkdGggOiBhcmVhLnJpZ2h0ICsgY2xpcC5yaWdodCxcbiAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG4gIGlzUG9pbnRJbkFyZWEocG9pbnQpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJbkFyZWEocG9pbnQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgfVxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG1vZGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKHggPT4geCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICBoaWRkZW46IG51bGwsXG4gICAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgaW5kZXg6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwsIHtjaGFydDogdGhpcywgdHlwZTogJ2NoYXJ0J30pKTtcbiAgfVxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cbiAgaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIWRhdGFzZXQuaGlkZGVuO1xuICB9XG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgfVxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIGdldERhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgcmV0dXJuICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuICBfdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgY29uc3QgYW5pbXMgPSBtZXRhLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSk7XG4gICAgaWYgKGRlZmluZWQoZGF0YUluZGV4KSkge1xuICAgICAgbWV0YS5kYXRhW2RhdGFJbmRleF0uaGlkZGVuID0gIXZpc2libGU7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSk7XG4gICAgICBhbmltcy51cGRhdGUobWV0YSwge3Zpc2libGV9KTtcbiAgICAgIHRoaXMudXBkYXRlKChjdHgpID0+IGN0eC5kYXRhc2V0SW5kZXggPT09IGRhdGFzZXRJbmRleCA/IG1vZGUgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuICBoaWRlKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgZmFsc2UpO1xuICB9XG4gIHNob3coZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcbiAgfVxuICBfZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChtZXRhICYmIG1ldGEuY29udHJvbGxlcikge1xuICAgICAgbWV0YS5jb250cm9sbGVyLl9kZXN0cm95KCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICB9XG4gIF9zdG9wKCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGVzdHJveScpO1xuICAgIGNvbnN0IHtjYW52YXMsIGN0eH0gPSB0aGlzO1xuICAgIHRoaXMuX3N0b3AoKTtcbiAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdkZXN0cm95Jyk7XG4gICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGVzdHJveScpO1xuICB9XG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBiaW5kVXNlckV2ZW50cygpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuICAgIGVhY2godGhpcy5vcHRpb25zLmV2ZW50cywgKHR5cGUpID0+IF9hZGQodHlwZSwgbGlzdGVuZXIpKTtcbiAgfVxuICBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IF9yZW1vdmUgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgcGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgZGV0YWNoZWQ7XG4gICAgY29uc3QgYXR0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIF9yZW1vdmUoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcbiAgICAgIF9hZGQoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIGVhY2godGhpcy5fbGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG4gICAgaWYgKG1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uZGF0YXNldEluZGV4KTtcbiAgICAgIG1ldGEuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIH1cbiAgfVxuICBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICB9XG4gIF91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSkge1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XG4gICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChkZWFjdGl2YXRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShkZWFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgX2V2ZW50SGFuZGxlcihlLCByZXBsYXkpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgZXZlbnQ6IGUsXG4gICAgICByZXBsYXksXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYShlKVxuICAgIH07XG4gICAgY29uc3QgZXZlbnRGaWx0ZXIgPSAocGx1Z2luKSA9PiAocGx1Z2luLm9wdGlvbnMuZXZlbnRzIHx8IHRoaXMub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKGUubmF0aXZlLnR5cGUpO1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcik7XG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IHtfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10sIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gcmVwbGF5O1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcbiAgICBjb25zdCBsYXN0RXZlbnQgPSBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgdGhpcy5fbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljayk7XG4gICAgaWYgKGluQ2hhcnRBcmVhKSB7XG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICBpZiAoaXNDbGljaykge1xuICAgICAgICBjYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkIHx8IHJlcGxheSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBsYXN0RXZlbnQ7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbn1cbmNvbnN0IGludmFsaWRhdGVQbHVnaW5zID0gKCkgPT4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbmNvbnN0IGVudW1lcmFibGUgPSB0cnVlO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hhcnQsIHtcbiAgZGVmYXVsdHM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBkZWZhdWx0c1xuICB9LFxuICBpbnN0YW5jZXM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBpbnN0YW5jZXNcbiAgfSxcbiAgb3ZlcnJpZGVzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogb3ZlcnJpZGVzXG4gIH0sXG4gIHJlZ2lzdHJ5OiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogcmVnaXN0cnlcbiAgfSxcbiAgdmVyc2lvbjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IHZlcnNpb25cbiAgfSxcbiAgZ2V0Q2hhcnQ6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBnZXRDaGFydFxuICB9LFxuICByZWdpc3Rlcjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xuICAgICAgcmVnaXN0cnkuYWRkKC4uLml0ZW1zKTtcbiAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogKC4uLml0ZW1zKSA9PiB7XG4gICAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpIHtcbiAgY29uc3Qge3N0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCB4LCB5LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXN9ID0gZWxlbWVudDtcbiAgbGV0IGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBvdXRlclJhZGl1cztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4pO1xuICBpZiAoaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuICAgIGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBpbm5lclJhZGl1cztcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgSEFMRl9QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMkMShhcmMsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgYW5nbGVEZWx0YSkge1xuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICBjb25zdCBpbm5lckxpbWl0ID0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgYW5nbGVEZWx0YSAqIGlubmVyUmFkaXVzIC8gMik7XG4gIGNvbnN0IGNvbXB1dGVPdXRlckxpbWl0ID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG91dGVyQXJjTGltaXQgPSAob3V0ZXJSYWRpdXMgLSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCB2YWwpKSAqIGFuZ2xlRGVsdGEgLyAyO1xuICAgIHJldHVybiBfbGltaXRWYWx1ZSh2YWwsIDAsIE1hdGgubWluKGhhbGZUaGlja25lc3MsIG91dGVyQXJjTGltaXQpKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KSxcbiAgfTtcbn1cbmZ1bmN0aW9uIHJUaGV0YVRvWFkociwgdGhldGEsIHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICB5OiB5ICsgciAqIE1hdGguc2luKHRoZXRhKSxcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZCwgY2lyY3VsYXIpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChzcGFjaW5nKSB7XG4gICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3Qgbm9TcGFjaW5nT3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyA+IDAgPyBvdXRlclJhZGl1cyAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IChhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cykgLyAoYXZOb2dTcGFjaW5nUmFkaXVzICsgc3BhY2luZykgOiBhbHBoYTtcbiAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICB9XG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyQxKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuICAgIGlmIChvdXRlckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICAgIH1cbiAgICBjb25zdCBwNCA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgZW5kQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG4gICAgaWYgKGlubmVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICAgIH1cbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpLCB0cnVlKTtcbiAgICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cywgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gICAgfVxuICAgIGNvbnN0IHA4ID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIHN0YXJ0QW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XG4gICAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFggPSBNYXRoLmNvcyhvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuICAgIGNvbnN0IG91dGVyRW5kWCA9IE1hdGguY29zKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJFbmRZID0gTWF0aC5zaW4ob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyRW5kWCwgb3V0ZXJFbmRZKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5mdW5jdGlvbiBkcmF3QXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2V9ID0gZWxlbWVudDtcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgc3RhcnRBbmdsZSArIFRBVSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSAlIFRBVTtcbiAgICAgIGlmIChjaXJjdW1mZXJlbmNlICUgVEFVID09PSAwKSB7XG4gICAgICAgIGVuZEFuZ2xlICs9IFRBVTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgY3R4LmZpbGwoKTtcbiAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuZnVuY3Rpb24gZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCBmdWxsQ2lyY2xlc30gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gZWxlbWVudC5pbm5lclJhZGl1cyArIHBpeGVsTWFyZ2luO1xuICBsZXQgaTtcbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgc3RhcnRBbmdsZSArIFRBVSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSArIFRBVSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3Qm9yZGVyKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpIHtcbiAgY29uc3Qge29wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGV9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdyb3VuZCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xuICB9XG4gIGlmIChlbGVtZW50LmZ1bGxDaXJjbGVzKSB7XG4gICAgZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgY3R4LnN0cm9rZSgpO1xufVxuY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZShjaGFydFgsIGNoYXJ0WSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGUsIGRpc3RhbmNlfSA9IGdldEFuZ2xlRnJvbVBvaW50KHBvaW50LCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHJBZGp1c3QgPSB0aGlzLm9wdGlvbnMuc3BhY2luZyAvIDI7XG4gICAgY29uc3QgX2NpcmN1bWZlcmVuY2UgPSB2YWx1ZU9yRGVmYXVsdChjaXJjdW1mZXJlbmNlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGJldHdlZW5BbmdsZXMgPSBfY2lyY3VtZmVyZW5jZSA+PSBUQVUgfHwgX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9IF9pc0JldHdlZW4oZGlzdGFuY2UsIGlubmVyUmFkaXVzICsgckFkanVzdCwgb3V0ZXJSYWRpdXMgKyByQWRqdXN0KTtcbiAgICByZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXN9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAneCcsXG4gICAgICAneScsXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZScsXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge29mZnNldCwgc3BhY2luZ30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICAgIGNvbnN0IGhhbGZSYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG4gICAgfTtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcztcbiAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyAyO1xuICAgIGNvbnN0IHNwYWNpbmcgPSAob3B0aW9ucy5zcGFjaW5nIHx8IDApIC8gMjtcbiAgICBjb25zdCBjaXJjdWxhciA9IG9wdGlvbnMuY2lyY3VsYXI7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSBjaXJjdW1mZXJlbmNlID4gVEFVID8gTWF0aC5mbG9vcihjaXJjdW1mZXJlbmNlIC8gVEFVKSA6IDA7XG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBsZXQgcmFkaXVzT2Zmc2V0ID0gMDtcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQgLyAyO1xuICAgICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIHJhZGl1c09mZnNldCwgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIHJhZGl1c09mZnNldCk7XG4gICAgICBpZiAodGhpcy5jaXJjdW1mZXJlbmNlID49IFBJKSB7XG4gICAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY29uc3QgZW5kQW5nbGUgPSBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5BcmNFbGVtZW50LmlkID0gJ2FyYyc7XG5BcmNFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJBbGlnbjogJ2NlbnRlcicsXG4gIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gIGJvcmRlckpvaW5TdHlsZTogdW5kZWZpbmVkLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAyLFxuICBvZmZzZXQ6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIGFuZ2xlOiB1bmRlZmluZWQsXG4gIGNpcmN1bGFyOiB0cnVlLFxufTtcbkFyY0VsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xufTtcblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gIH1cbiAgcmV0dXJuIGxpbmVUbztcbn1cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgc3RhcnQsXG4gICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG4gICAgcHJldiA9IHBvaW50O1xuICB9XG4gIGlmIChsb29wKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xuICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgfVxuICByZXR1cm4gISFsb29wO1xufVxuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICBjb25zdCBkcmF3WCA9ICgpID0+IHtcbiAgICBpZiAobWluWSAhPT0gbWF4WSkge1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWluWSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIGxhc3RZKTtcbiAgICB9XG4gIH07XG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBsaW5lLl9wYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoY3R4LCBsaW5lLm9wdGlvbnMpO1xuICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWNpbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9zZWdtZW50cztcbiAgICBkZWxldGUgdGhpcy5fcGF0aDtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cbiAgbGFzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gIH1cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudHNbaV07XG4gICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IE1hdGguYWJzKCh2YWx1ZSAtIHAxW3Byb3BlcnR5XSkgLyAocDJbcHJvcGVydHldIC0gcDFbcHJvcGVydHldKSk7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgICAgaW50ZXJwb2xhdGVkW3Byb3BlcnR5XSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGNvdW50ID0gY291bnQgfHwgKHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMgfHwgW107XG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5MaW5lRWxlbWVudC5pZCA9ICdsaW5lJztcbkxpbmVFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICBib3JkZXJXaWR0aDogMyxcbiAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gIGZpbGw6IGZhbHNlLFxuICBzcGFuR2FwczogZmFsc2UsXG4gIHN0ZXBwZWQ6IGZhbHNlLFxuICB0ZW5zaW9uOiAwLFxufTtcbkxpbmVFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuTGluZUVsZW1lbnQuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiB0cnVlLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdmaWxsJyxcbn07XG5cbmZ1bmN0aW9uIGluUmFuZ2UkMShlbCwgcG9zLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gKE1hdGguYWJzKHBvcyAtIHZhbHVlKSA8IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXMpO1xufVxuY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgc2l6ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuICBkcmF3KGN0eCwgYXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgdGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXM7XG4gIH1cbn1cblBvaW50RWxlbWVudC5pZCA9ICdwb2ludCc7XG5Qb2ludEVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlcldpZHRoOiAxLFxuICBoaXRSYWRpdXM6IDEsXG4gIGhvdmVyQm9yZGVyV2lkdGg6IDEsXG4gIGhvdmVyUmFkaXVzOiA0LFxuICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgcmFkaXVzOiAzLFxuICByb3RhdGlvbjogMFxufTtcblBvaW50RWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcblxuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgYmFzZSwgd2lkdGgsIGhlaWdodH0gPSBiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xuICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xuICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICB9IGVsc2Uge1xuICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgbGVmdCA9IHggLSBoYWxmO1xuICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYmFzZSk7XG4gIH1cbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219O1xufVxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlcldpZHRoO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgYjogc2tpcE9yTGltaXQoc2tpcC5ib3R0b20sIG8uYm90dG9tLCAwLCBtYXhIKSxcbiAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMoYmFyKSB7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcbiAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHQsXG4gICAgICByYWRpdXNcbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuICAgICAgeTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuICAgICAgaDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21MZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCBfaXNCZXR3ZWVuKHgsIGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQpKVxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XG59XG5mdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbn1cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cbmNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2luZmxhdGVBbW91bnQsIG9wdGlvbnM6IHtib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yfX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICBjb25zdCBhZGRSZWN0UGF0aCA9IGhhc1JhZGl1cyhvdXRlci5yYWRpdXMpID8gYWRkUm91bmRlZFJlY3RQYXRoIDogYWRkTm9ybWFsUmVjdFBhdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG5CYXJFbGVtZW50LmlkID0gJ2Jhcic7XG5CYXJFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICBib3JkZXJXaWR0aDogMCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxufTtcbkJhckVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbnZhciBlbGVtZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkFyY0VsZW1lbnQ6IEFyY0VsZW1lbnQsXG5MaW5lRWxlbWVudDogTGluZUVsZW1lbnQsXG5Qb2ludEVsZW1lbnQ6IFBvaW50RWxlbWVudCxcbkJhckVsZW1lbnQ6IEJhckVsZW1lbnRcbn0pO1xuXG5mdW5jdGlvbiBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgfHwgYXZhaWxhYmxlV2lkdGg7XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBidWNrZXRXaWR0aCA9IChjb3VudCAtIDIpIC8gKHNhbXBsZXMgLSAyKTtcbiAgbGV0IHNhbXBsZWRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGxldCBhID0gc3RhcnQ7XG4gIGxldCBpLCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIGFyZWEsIG5leHRBO1xuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcbiAgICBmb3IgKGogPSBhdmdSYW5nZVN0YXJ0OyBqIDwgYXZnUmFuZ2VFbmQ7IGorKykge1xuICAgICAgYXZnWCArPSBkYXRhW2pdLng7XG4gICAgICBhdmdZICs9IGRhdGFbal0ueTtcbiAgICB9XG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuICAgIGZvciAoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKykge1xuICAgICAgYXJlYSA9IDAuNSAqIE1hdGguYWJzKFxuICAgICAgICAocG9pbnRBeCAtIGF2Z1gpICogKGRhdGFbal0ueSAtIHBvaW50QXkpIC1cbiAgICAgICAgKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KVxuICAgICAgKTtcbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpIHtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCB4LCB5LCBwcmV2WCwgbWluSW5kZXgsIG1heEluZGV4LCBzdGFydEluZGV4LCBtaW5ZLCBtYXhZO1xuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobWluSW5kZXgpICYmICFpc051bGxPclVuZGVmKG1heEluZGV4KSkge1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDEgPSBNYXRoLm1pbihtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDIgPSBNYXRoLm1heChtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7dmFsdWU6IGRhdGF9KTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBwb2ludHMpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQpIHtcbiAgICBjb3VudCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxudmFyIHBsdWdpbl9kZWNpbWF0aW9uID0ge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuICBkZWZhdWx0czoge1xuICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICB9LFxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG4gICAgICBpZiAocmVzb2x2ZShbaW5kZXhBeGlzLCBjaGFydC5vcHRpb25zLmluZGV4QXhpc10pID09PSAneScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFtZXRhLmNvbnRyb2xsZXIuc3VwcG9ydHNEZWNpbWF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICBkZWxldGUgZGF0YXNldC5kYXRhO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95KGNoYXJ0KSB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuICAgIGNvbnN0IGJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHBvaW50c1tzdGFydF0sIHBvaW50c1tlbmRdLCBzZWdtZW50Lmxvb3ApO1xuICAgIGlmICghdGFyZ2V0LnNlZ21lbnRzKSB7XG4gICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgc291cmNlOiBzZWdtZW50LFxuICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXG4gICAgICAgIGVuZDogcG9pbnRzW2VuZF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGFyZ2V0LCBib3VuZHMpO1xuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XG4gICAgICBjb25zdCBzdWJCb3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ3N0YXJ0JywgTWF0aC5tYXgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuZnVuY3Rpb24gX2dldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgaWYgKGxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgfVxuICByZXR1cm4ge3Byb3BlcnR5LCBzdGFydCwgZW5kfTtcbn1cbmZ1bmN0aW9uIF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpIHtcbiAgY29uc3Qge3ggPSBudWxsLCB5ID0gbnVsbH0gPSBib3VuZGFyeSB8fCB7fTtcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgbGluZS5zZWdtZW50cy5mb3JFYWNoKCh7c3RhcnQsIGVuZH0pID0+IHtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cykge1xuICBmb3IgKDtlbmQgPiBzdGFydDsgZW5kLS0pIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG4gIGlmIChpc0FycmF5KGJvdW5kYXJ5KSkge1xuICAgIF9sb29wID0gdHJ1ZTtcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuICByZXR1cm4gcG9pbnRzLmxlbmd0aCA/IG5ldyBMaW5lRWxlbWVudCh7XG4gICAgcG9pbnRzLFxuICAgIG9wdGlvbnM6IHt0ZW5zaW9uOiAwfSxcbiAgICBfbG9vcCxcbiAgICBfZnVsbExvb3A6IF9sb29wXG4gIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIF9zaG91bGRBcHBseUZpbGwoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgJiYgc291cmNlLmZpbGwgIT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuICB3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuICAgIGlmICghaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHZpc2l0ZWQucHVzaChmaWxsKTtcbiAgICBmaWxsID0gdGFyZ2V0LmZpbGw7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX2RlY29kZUZpbGwobGluZSwgaW5kZXgsIGNvdW50KSB7XG4gIGNvbnN0IGZpbGwgPSBwYXJzZUZpbGxPcHRpb24obGluZSk7XG4gIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHJldHVybiBpc05hTihmaWxsLnZhbHVlKSA/IGZhbHNlIDogZmlsbDtcbiAgfVxuICBsZXQgdGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsKTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICB9XG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cbmZ1bmN0aW9uIGRlY29kZVRhcmdldEluZGV4KGZpcnN0Q2gsIGluZGV4LCB0YXJnZXQsIGNvdW50KSB7XG4gIGlmIChmaXJzdENoID09PSAnLScgfHwgZmlyc3RDaCA9PT0gJysnKSB7XG4gICAgdGFyZ2V0ID0gaW5kZXggKyB0YXJnZXQ7XG4gIH1cbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSkge1xuICBsZXQgcGl4ZWwgPSBudWxsO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHBpeGVsID0gc2NhbGUuYm90dG9tO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS50b3A7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICByZXR1cm4gcGl4ZWw7XG59XG5mdW5jdGlvbiBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0VmFsdWUpIHtcbiAgbGV0IHZhbHVlO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgdmFsdWUgPSBmaWxsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gc2NhbGUuZ2V0QmFzZVZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcGFyc2VGaWxsT3B0aW9uKGxpbmUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IG9wdGlvbnMuZmlsbDtcbiAgbGV0IGZpbGwgPSB2YWx1ZU9yRGVmYXVsdChmaWxsT3B0aW9uICYmIGZpbGxPcHRpb24udGFyZ2V0LCBmaWxsT3B0aW9uKTtcbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWxsID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdvcmlnaW4nO1xuICB9XG4gIHJldHVybiBmaWxsO1xufVxuXG5mdW5jdGlvbiBfYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgbGluZXNCZWxvdy5wdXNoKF9jcmVhdGVCb3VuZGFyeUxpbmUoe3g6IG51bGwsIHk6IHNjYWxlLmJvdHRvbX0sIGxpbmUpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cbmZ1bmN0aW9uIGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KSB7XG4gIGNvbnN0IGJlbG93ID0gW107XG4gIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2xpbmUnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBwb3N0cG9uZWQudW5zaGlmdChwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcbn1cbmZ1bmN0aW9uIGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmICghcG9pbnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKF9pc0JldHdlZW4ocG9pbnRWYWx1ZSwgZmlyc3RWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG5cbmNsYXNzIHNpbXBsZUFyYyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnggPSBvcHRzLng7XG4gICAgdGhpcy55ID0gb3B0cy55O1xuICAgIHRoaXMucmFkaXVzID0gb3B0cy5yYWRpdXM7XG4gIH1cbiAgcGF0aFNlZ21lbnQoY3R4LCBib3VuZHMsIG9wdHMpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgYm91bmRzID0gYm91bmRzIHx8IHtzdGFydDogMCwgZW5kOiBUQVV9O1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBib3VuZHMuZW5kLCBib3VuZHMuc3RhcnQsIHRydWUpO1xuICAgIHJldHVybiAhb3B0cy5ib3VuZHM7XG4gIH1cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFRhcmdldChzb3VyY2UpIHtcbiAgY29uc3Qge2NoYXJ0LCBmaWxsLCBsaW5lfSA9IHNvdXJjZTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3N0YWNrJykge1xuICAgIHJldHVybiBfYnVpbGRTdGFja0xpbmUoc291cmNlKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG4gIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xuICAgIHJldHVybiBib3VuZGFyeTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lQnlJbmRleChjaGFydCwgaW5kZXgpIHtcbiAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgY29uc3QgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG4gIHJldHVybiB2aXNpYmxlID8gbWV0YS5kYXRhc2V0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG4gIGlmIChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3QgcGl4ZWwgPSBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUocGl4ZWwpKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gcGl4ZWwgOiBudWxsLFxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiBwaXhlbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5tYXggOiBzY2FsZS5taW47XG4gIGNvbnN0IHZhbHVlID0gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydCk7XG4gIGNvbnN0IHRhcmdldCA9IFtdO1xuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY29uc3QgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55LFxuICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICB9KTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gIGNvbnN0IHRhcmdldCA9IF9nZXRUYXJnZXQoc291cmNlKTtcbiAgY29uc3Qge2xpbmUsIHNjYWxlLCBheGlzfSA9IHNvdXJjZTtcbiAgY29uc3QgbGluZU9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBsaW5lT3B0cy5maWxsO1xuICBjb25zdCBjb2xvciA9IGxpbmVPcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgY29uc3Qge2Fib3ZlID0gY29sb3IsIGJlbG93ID0gY29sb3J9ID0gZmlsbE9wdGlvbiB8fCB7fTtcbiAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcbiAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIGRvRmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGF4aXN9KTtcbiAgICB1bmNsaXBBcmVhKGN0eCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRvRmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlfSA9IGNmZztcbiAgY29uc3QgcHJvcGVydHkgPSBsaW5lLl9sb29wID8gJ2FuZ2xlJyA6IGNmZy5heGlzO1xuICBjdHguc2F2ZSgpO1xuICBpZiAocHJvcGVydHkgPT09ICd4JyAmJiBiZWxvdyAhPT0gYWJvdmUpIHtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGFib3ZlLCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gIH1cbiAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBiZWxvdywgc2NhbGUsIHByb3BlcnR5fSk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgY2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhsYXN0UG9pbnQueCwgY2xpcFkpO1xuICAgIH1cbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC5maXJzdCgpLngsIGNsaXBZKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIGZvciAoY29uc3Qge3NvdXJjZTogc3JjLCB0YXJnZXQ6IHRndCwgc3RhcnQsIGVuZH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XG4gICAgY29uc3Qgbm90U2hhcGUgPSB0YXJnZXQgIT09IHRydWU7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgbm90U2hhcGUgJiYgX2dldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGJvdW5kcykge1xuICBjb25zdCB7dG9wLCBib3R0b219ID0gc2NhbGUuY2hhcnQuY2hhcnRBcmVhO1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0LCBlbmR9ID0gYm91bmRzIHx8IHt9O1xuICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgucmVjdChzdGFydCwgdG9wLCBlbmQgLSBzdGFydCwgYm90dG9tIC0gdG9wKTtcbiAgICBjdHguY2xpcCgpO1xuICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBpbnRlcnBvbGF0ZWRQb2ludCA9IHRhcmdldC5pbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpO1xuICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcbiAgICBjdHgubGluZVRvKGludGVycG9sYXRlZFBvaW50LngsIGludGVycG9sYXRlZFBvaW50LnkpO1xuICB9XG59XG5cbnZhciBpbmRleCA9IHtcbiAgaWQ6ICdmaWxsZXInLFxuICBhZnRlckRhdGFzZXRzVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgbGV0IG1ldGEsIGksIGxpbmUsIHNvdXJjZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgIHNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZHJhdyA9IG9wdGlvbnMuZHJhd1RpbWUgPT09ICdiZWZvcmVEcmF3JztcbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhhcmVhLCBzb3VyY2UuYXhpcyk7XG4gICAgICBpZiAoZHJhdyAmJiBzb3VyY2UuZmlsbCkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG4gICAgaWYgKCFfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkgfHwgb3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXREcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoIHx8IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBib3hXaWR0aCxcbiAgICBib3hIZWlnaHQsXG4gICAgaXRlbUhlaWdodDogTWF0aC5tYXgoZm9udFNpemUsIGJveEhlaWdodClcbiAgfTtcbn07XG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcbmNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcbiAgICB0aGlzLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYnVpbGRMYWJlbHMoKTtcbiAgICB0aGlzLmZpdCgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgbGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGxldCByb3cgPSAtMTtcbiAgICBsZXQgdG9wID0gLWxpbmVIZWlnaHQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gaXRlbVdpZHRoICsgcGFkZGluZztcbiAgICB9KTtcbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heEhlaWdodCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodExpbWl0ID0gbWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQ7XG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG4gICAgICBjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG4gIGFkanVzdEhpdEJveGVzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7bGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzLCBvcHRpb25zOiB7YWxpZ24sIGxhYmVsczoge3BhZGRpbmd9LCBydGx9fSA9IHRoaXM7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGxldCByb3cgPSAwO1xuICAgICAgbGV0IGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChyb3cgIT09IGhpdGJveC5yb3cpIHtcbiAgICAgICAgICByb3cgPSBoaXRib3gucm93O1xuICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wICs9IHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICBsZWZ0ICs9IGhpdGJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb2wgPSAwO1xuICAgICAgbGV0IHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChoaXRib3guY29sICE9PSBjb2wpIHtcbiAgICAgICAgICBjb2wgPSBoaXRib3guY29sO1xuICAgICAgICAgIHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wID0gdG9wO1xuICAgICAgICBoaXRib3gubGVmdCArPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgdG9wICs9IGhpdGJveC5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuICAgICAgdGhpcy5fZHJhdygpO1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBfZHJhdygpIHtcbiAgICBjb25zdCB7b3B0aW9uczogb3B0cywgY29sdW1uU2l6ZXMsIGxpbmVXaWR0aHMsIGN0eH0gPSB0aGlzO1xuICAgIGNvbnN0IHthbGlnbiwgbGFiZWxzOiBsYWJlbE9wdHN9ID0gb3B0cztcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3Qge2NvbG9yOiBmb250Q29sb3IsIHBhZGRpbmd9ID0gbGFiZWxPcHRzO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuICAgIGxldCBjdXJzb3I7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGNvbnN0IGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICAgIHJhZGl1czogYm94SGVpZ2h0ICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgcG9pbnRTdHlsZTogbGVnZW5kSXRlbS5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBsZWdlbmRJdGVtLnJvdGF0aW9uLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBsaW5lV2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIGhhbGZGb250U2l6ZTtcbiAgICAgICAgZHJhd1BvaW50TGVnZW5kKGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclksIGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggJiYgYm94V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgIHg6IHhCb3hMZWZ0LFxuICAgICAgICAgICAgeTogeUJveFRvcCxcbiAgICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnJlY3QoeEJveExlZnQsIHlCb3hUb3AsIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsZWdlbmRJdGVtLnRleHQsIHgsIHkgKyAoaXRlbUhlaWdodCAvIDIpLCBsYWJlbEZvbnQsIHtcbiAgICAgICAgc3RyaWtldGhyb3VnaDogbGVnZW5kSXRlbS5oaWRkZW4sXG4gICAgICAgIHRleHRBbGlnbjogcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbilcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzWzBdKSxcbiAgICAgICAgeTogdGhpcy50b3AgKyBwYWRkaW5nICsgdGl0bGVIZWlnaHQsXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogdGhpcy5sZWZ0ICsgcGFkZGluZyxcbiAgICAgICAgeTogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzWzBdLmhlaWdodCksXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3IgfHwgZm9udENvbG9yO1xuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduIHx8IChsZWdlbmRJdGVtLnRleHRBbGlnbiA9IGxhYmVsT3B0cy50ZXh0QWxpZ24pKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB0ZXh0V2lkdGg7XG4gICAgICBsZXQgeCA9IGN1cnNvci54O1xuICAgICAgbGV0IHkgPSBjdXJzb3IueTtcbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XG4gICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFsWCA9IHJ0bEhlbHBlci54KHgpO1xuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiB0aGlzLnJpZ2h0LCBvcHRzLnJ0bCk7XG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgaWYgKCF0aXRsZU9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGl0bGVPcHRzLnBvc2l0aW9uO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IHRpdGxlRm9udC5zaXplIC8gMjtcbiAgICBjb25zdCB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSA9IHRpdGxlUGFkZGluZy50b3AgKyBoYWxmRm9udFNpemU7XG4gICAgbGV0IHk7XG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5jb2x1bW5TaXplcy5yZWR1Y2UoKGFjYywgc2l6ZSkgPT4gTWF0aC5tYXgoYWNjLCBzaXplLmhlaWdodCksIDApO1xuICAgICAgeSA9IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplICsgX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgdGhpcy50b3AsIHRoaXMuYm90dG9tIC0gbWF4SGVpZ2h0IC0gb3B0cy5sYWJlbHMucGFkZGluZyAtIHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpKTtcbiAgICB9XG4gICAgY29uc3QgeCA9IF9hbGlnblN0YXJ0RW5kKHBvc2l0aW9uLCBsZWZ0LCBsZWZ0ICsgbWF4V2lkdGgpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICB9XG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG4gIF9nZXRMZWdlbmRJdGVtQXQoeCwgeSkge1xuICAgIGxldCBpLCBoaXRCb3gsIGxoO1xuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgbGggPSB0aGlzLmxlZ2VuZEhpdEJveGVzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhpdEJveCA9IGxoW2ldO1xuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmRJdGVtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIWlzTGlzdGVuZWQoZS50eXBlLCBvcHRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX2hvdmVyZWRJdGVtO1xuICAgICAgY29uc3Qgc2FtZUl0ZW0gPSBpdGVtc0VxdWFsKHByZXZpb3VzLCBob3ZlcmVkSXRlbSk7XG4gICAgICBpZiAocHJldmlvdXMgJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuICAgICAgaWYgKGhvdmVyZWRJdGVtICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsYmFjayhvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIGNhbGxiYWNrKG9wdHMub25DbGljaywgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpc3RlbmVkKHR5cGUsIG9wdHMpIHtcbiAgaWYgKCh0eXBlID09PSAnbW91c2Vtb3ZlJyB8fCB0eXBlID09PSAnbW91c2VvdXQnKSAmJiAob3B0cy5vbkhvdmVyIHx8IG9wdHMub25MZWF2ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy5vbkNsaWNrICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdtb3VzZXVwJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcbiAgaWQ6ICdsZWdlbmQnLFxuICBfZWxlbWVudDogTGVnZW5kLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBjaGFydC5sZWdlbmQpO1xuICAgIGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmICghYXJncy5yZXBsYXkpIHtcbiAgICAgIGNoYXJ0LmxlZ2VuZC5oYW5kbGVFdmVudChhcmdzLmV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uSG92ZXI6IG51bGwsXG4gICAgb25MZWF2ZTogbnVsbCxcbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBoaWRkZW46ICFtZXRhLnZpc2libGUsXG4gICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAoYm9yZGVyV2lkdGgud2lkdGggKyBib3JkZXJXaWR0aC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuXG5jbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgfVxuICBfZHJhd0FyZ3Mob2Zmc2V0KSB7XG4gICAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG4gIGlkOiAndGl0bGUnLFxuICBfZWxlbWVudDogVGl0bGUsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHBsdWdpbl9zdWJ0aXRsZSA9IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDE1MDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpLCBsZW47XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeCArPSBwb3MueDtcbiAgICAgICAgeSArPSBwb3MueTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggLyBjb3VudCxcbiAgICAgIHk6IHkgLyBjb3VudFxuICAgIH07XG4gIH0sXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2U7XG59XG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oY2hhcnQsIGl0ZW0pIHtcbiAgY29uc3Qge2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9ID0gaXRlbTtcbiAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgY29uc3Qge2xhYmVsLCB2YWx1ZX0gPSBjb250cm9sbGVyLmdldExhYmVsQW5kVmFsdWUoaW5kZXgpO1xuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuY2hhcnQuY3R4O1xuICBjb25zdCB7Ym9keSwgZm9vdGVyLCB0aXRsZX0gPSB0b29sdGlwO1xuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xuICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICBjb25zdCB0aXRsZUxpbmVDb3VudCA9IHRpdGxlLmxlbmd0aDtcbiAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBsZXQgaGVpZ2h0ID0gcGFkZGluZy5oZWlnaHQ7XG4gIGxldCB3aWR0aCA9IDA7XG4gIGxldCBjb21iaW5lZEJvZHlMZW5ndGggPSBib2R5LnJlZHVjZSgoY291bnQsIGJvZHlJdGVtKSA9PiBjb3VudCArIGJvZHlJdGVtLmJlZm9yZS5sZW5ndGggKyBib2R5SXRlbS5saW5lcy5sZW5ndGggKyBib2R5SXRlbS5hZnRlci5sZW5ndGgsIDApO1xuICBjb21iaW5lZEJvZHlMZW5ndGggKz0gdG9vbHRpcC5iZWZvcmVCb2R5Lmxlbmd0aCArIHRvb2x0aXAuYWZ0ZXJCb2R5Lmxlbmd0aDtcbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG4gIGxldCB3aWR0aFBhZGRpbmcgPSAwO1xuICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcbiAgfTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuYmVmb3JlQm9keS5jb25jYXQodG9vbHRpcC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuICB3aWR0aFBhZGRpbmcgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyAoYm94V2lkdGggKyAyICsgb3B0aW9ucy5ib3hQYWRkaW5nKSA6IDA7XG4gIGVhY2goYm9keSwgKGJvZHlJdGVtKSA9PiB7XG4gICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xuICB9KTtcbiAgd2lkdGhQYWRkaW5nID0gMDtcbiAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbiAgd2lkdGggKz0gcGFkZGluZy53aWR0aDtcbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9XG4gIHJldHVybiAnY2VudGVyJztcbn1cbmZ1bmN0aW9uIGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3QgY2FyZXQgPSBvcHRpb25zLmNhcmV0U2l6ZSArIG9wdGlvbnMuY2FyZXRQYWRkaW5nO1xuICBpZiAoeEFsaWduID09PSAnbGVmdCcgJiYgeCArIHdpZHRoICsgY2FyZXQgPiBjaGFydC53aWR0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCB7d2lkdGg6IGNoYXJ0V2lkdGgsIGNoYXJ0QXJlYToge2xlZnQsIHJpZ2h0fX0gPSBjaGFydDtcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIHhBbGlnbiA9IHggPD0gKGxlZnQgKyByaWdodCkgLyAyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfSBlbHNlIGlmICh4IDw9IHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdsZWZ0JztcbiAgfSBlbHNlIGlmICh4ID49IGNoYXJ0V2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAncmlnaHQnO1xuICB9XG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cbiAgcmV0dXJuIHhBbGlnbjtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuICByZXR1cm4ge1xuICAgIHhBbGlnbjogc2l6ZS54QWxpZ24gfHwgb3B0aW9ucy54QWxpZ24gfHwgZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pLFxuICAgIHlBbGlnblxuICB9O1xufVxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgbGV0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ICs9IHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2Uge1xuICAgIHkgLT0gKGhlaWdodCAvIDIpO1xuICB9XG4gIHJldHVybiB5O1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhcmV0U2l6ZSwgY2FyZXRQYWRkaW5nLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcbiAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICBsZXQgeCA9IGFsaWduWChzaXplLCB4QWxpZ24pO1xuICBjb25zdCB5ID0gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpO1xuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh0b29sdGlwLCBhbGlnbiwgb3B0aW9ucykge1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5mdW5jdGlvbiBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBjb250ZXh0ICYmIGNvbnRleHQuZGF0YXNldCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcC5jYWxsYmFja3M7XG4gIHJldHVybiBvdmVycmlkZSA/IGNhbGxiYWNrcy5vdmVycmlkZShvdmVycmlkZSkgOiBjYWxsYmFja3M7XG59XG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydCB8fCBjb25maWcuX2NoYXJ0O1xuICAgIHRoaXMuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5lbmFibGVkICYmIGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jaGFydCwgb3B0cyk7XG4gICAgaWYgKG9wdHMuX2NhY2hlYWJsZSkge1xuICAgICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBjb25zdCB0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIGdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5SXRlbXMgPSBbXTtcbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKHNjb3BlZC5iZWZvcmVMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIHNjb3BlZC5sYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhzY29wZWQuYWZ0ZXJMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvZHlJdGVtcztcbiAgfVxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSkpO1xuICB9XG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIF9jcmVhdGVJdGVtcyhvcHRpb25zKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGVzID0gW107XG4gICAgY29uc3QgbGFiZWxUZXh0Q29sb3JzID0gW107XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGxldCBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQsIGluZGV4LCBhcnJheSwgZGF0YSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKG9wdGlvbnMuY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIGxhYmVsQ29sb3JzLnB1c2goc2NvcGVkLmxhYmVsQ29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goc2NvcGVkLmxhYmVsUG9pbnRTdHlsZS5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKHNjb3BlZC5sYWJlbFRleHRDb2xvci5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9KTtcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGlmICghYWN0aXZlLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMub3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0aGlzLl9jcmVhdGVJdGVtcyhvcHRpb25zKTtcbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLmNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLmNoYXJ0KTtcbiAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngxLCBjYXJldFBvc2l0aW9uLnkxKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG4gIH1cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgxID0gcHRYO1xuICAgICAgICB4MiA9IHgxIC0gY2FyZXRTaXplO1xuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHgzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XG4gICAgICB9XG4gICAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgICB5MSA9IHB0WTtcbiAgICAgICAgeTIgPSB5MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuICBkcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICAgICAgdGl0bGVTcGFjaW5nID0gb3B0aW9ucy50aXRsZVNwYWNpbmc7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nO1xuICAgICAgICBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIHB0LnkgKz0gb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gdGhpcy5sYWJlbENvbG9yc1tpXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGUgPSB0aGlzLmxhYmVsUG9pbnRTdHlsZXNbaV07XG4gICAgY29uc3Qge2JveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBjb25zdCBjb2xvclggPSBnZXRBbGlnbmVkWCh0aGlzLCAnbGVmdCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJ0bENvbG9yWCA9IHJ0bEhlbHBlci54KGNvbG9yWCk7XG4gICAgY29uc3QgeU9mZlNldCA9IGJveEhlaWdodCA8IGJvZHlGb250LmxpbmVIZWlnaHQgPyAoYm9keUZvbnQubGluZUhlaWdodCAtIGJveEhlaWdodCkgLyAyIDogMDtcbiAgICBjb25zdCBjb2xvclkgPSBwdC55ICsgeU9mZlNldDtcbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsXG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKSArIGJveFdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSBjb2xvclkgKyBib3hIZWlnaHQgLyAyO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoKSkgOiAobGFiZWxDb2xvcnMuYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9ycy5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3JzLmJvcmRlckRhc2hPZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IG91dGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGggLSBib3hQYWRkaW5nKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIGJveFBhZGRpbmcgLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvcnMuYm9yZGVyUmFkaXVzKTtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtib2R5fSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYm9keUNvbG9yO1xuICAgIGVhY2godGhpcy5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuICAgICAgbGluZXMgPSBib2R5SXRlbS5saW5lcztcbiAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgZWFjaCh0aGlzLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7XG4gIH1cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9vdGVyID0gdGhpcy5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHt4LCB5fSA9IHB0O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRvb2x0aXBTaXplO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhvcHRpb25zLmNvcm5lclJhZGl1cyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyBib3R0b21MZWZ0LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1YID0gYW5pbXMgJiYgYW5pbXMueDtcbiAgICBjb25zdCBhbmltWSA9IGFuaW1zICYmIGFuaW1zLnk7XG4gICAgaWYgKGFuaW1YIHx8IGFuaW1ZKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgdGhpcy5fYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCB0aGlzLl9zaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IHBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCBjaGFydCk7XG4gICAgICBpZiAoYW5pbVguX3RvICE9PSBwb2ludC54IHx8IGFuaW1ZLl90byAhPT0gcG9pbnQueSkge1xuICAgICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FyZXRYID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5jYXJldFkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF93aWxsUmVuZGVyKCkge1xuICAgIHJldHVybiAhIXRoaXMub3BhY2l0eTtcbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG4gICAgICB0aGlzLmRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKTtcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogZS54LFxuICAgICAgICAgIHk6IGUueVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucywgcmVwbGF5KTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblRvb2x0aXAucG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcbnZhciBwbHVnaW5fdG9vbHRpcCA9IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuICBhZnRlckluaXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcCh7Y2hhcnQsIG9wdGlvbnN9KTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyRHJhdyhjaGFydCkge1xuICAgIGNvbnN0IHRvb2x0aXAgPSBjaGFydC50b29sdGlwO1xuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgfTtcbiAgICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcbiAgICAgIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyVG9vbHRpcERyYXcnLCBhcmdzKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgYXJncy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIGJlZm9yZVRpdGxlOiBub29wLFxuICAgICAgdGl0bGUodG9vbHRpcEl0ZW1zKSB7XG4gICAgICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG4gICAgICAgICAgY29uc3QgbGFiZWxzID0gaXRlbS5jaGFydC5kYXRhLmxhYmVscztcbiAgICAgICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0sXG4gICAgICBhZnRlclRpdGxlOiBub29wLFxuICAgICAgYmVmb3JlQm9keTogbm9vcCxcbiAgICAgIGJlZm9yZUxhYmVsOiBub29wLFxuICAgICAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWwgKz0gJzogJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgICAgbGFiZWwgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcbiAgICAgIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxhYmVsVGV4dENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgICAgIH0sXG4gICAgICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWZ0ZXJMYWJlbDogbm9vcCxcbiAgICAgIGFmdGVyQm9keTogbm9vcCxcbiAgICAgIGJlZm9yZUZvb3Rlcjogbm9vcCxcbiAgICAgIGZvb3Rlcjogbm9vcCxcbiAgICAgIGFmdGVyRm9vdGVyOiBub29wXG4gICAgfVxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgfVxuICB9LFxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG5cbnZhciBwbHVnaW5zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuRGVjaW1hdGlvbjogcGx1Z2luX2RlY2ltYXRpb24sXG5GaWxsZXI6IGluZGV4LFxuTGVnZW5kOiBwbHVnaW5fbGVnZW5kLFxuU3ViVGl0bGU6IHBsdWdpbl9zdWJ0aXRsZSxcblRpdGxlOiBwbHVnaW5fdGl0bGUsXG5Ub29sdGlwOiBwbHVnaW5fdG9vbHRpcFxufSk7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpID0+IHtcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICBhZGRlZExhYmVscy51bnNoaWZ0KHtpbmRleCwgbGFiZWw6IHJhd30pO1xuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcbiAgICBpbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcbmZ1bmN0aW9uIGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpIHtcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICBpZiAoZmlyc3QgPT09IC0xKSB7XG4gICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCkgPT4gaW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5jbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgfVxuICBpbml0KHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGVkID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIGZvciAoY29uc3Qge2luZGV4LCBsYWJlbH0gb2YgYWRkZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc1tpbmRleF0gPT09IGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRpb25zKTtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcbiAgICAgIDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpLCB0aGlzLl9hZGRlZExhYmVscyk7XG4gICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IGxhYmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuQ2F0ZWdvcnlTY2FsZS5pZCA9ICdjYXRlZ29yeSc7XG5DYXRlZ29yeVNjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBDYXRlZ29yeVNjYWxlLnByb3RvdHlwZS5nZXRMYWJlbEZvclZhbHVlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICBjb25zdCBtYXhTcGFjZXMgPSBtYXhUaWNrcyAtIDE7XG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XG4gIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xuICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcbiAgaWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiAhbWluRGVmaW5lZCAmJiAhbWF4RGVmaW5lZCkge1xuICAgIHJldHVybiBbe3ZhbHVlOiBybWlufSwge3ZhbHVlOiBybWF4fV07XG4gIH1cbiAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cbiAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgIG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgbmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICB9IGVsc2Uge1xuICAgIG5pY2VNaW4gPSBybWluO1xuICAgIG5pY2VNYXggPSBybWF4O1xuICB9XG4gIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQoTWF0aC5taW4oKG1heCAtIG1pbikgLyBzcGFjaW5nLCBtYXhUaWNrcykpO1xuICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcbiAgICBuaWNlTWluID0gbWluO1xuICAgIG5pY2VNYXggPSBtYXg7XG4gIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoXG4gICAgX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcbiAgKTtcbiAgZmFjdG9yID0gTWF0aC5wb3coMTAsIGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSA/IGRlY2ltYWxQbGFjZXMgOiBwcmVjaXNpb24pO1xuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcbiAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cbiAgZm9yICg7IGogPCBudW1TcGFjZXM7ICsraikge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcn0pO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkICYmIGluY2x1ZGVCb3VuZHMgJiYgbmljZU1heCAhPT0gbWF4KSB7XG4gICAgaWYgKHRpY2tzLmxlbmd0aCAmJiBhbG1vc3RFcXVhbHModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUsIG1heCwgcmVsYXRpdmVMYWJlbFNpemUobWF4LCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA9IG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1heH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghbWF4RGVmaW5lZCB8fCBuaWNlTWF4ID09PSBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbmljZU1heH0pO1xuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cbmNsYXNzIExpbmVhclNjYWxlQmFzZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiByYXcgPT09ICdudW1iZXInIHx8IHJhdyBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCtyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICtyYXc7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm99ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG4gICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcbiAgICAgICAgc2V0TWF4KDApO1xuICAgICAgfSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuICAgICAgICBzZXRNaW4oMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbGV0IG9mZnNldCA9IDE7XG4gICAgICBpZiAobWF4ID49IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IG1pbiA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLmFicyhtYXggKiAwLjA1KTtcbiAgICAgIH1cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xuICAgICAgICBzZXRNaW4obWluIC0gb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgZ2V0VGlja0xpbWl0KCkge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCB7bWF4VGlja3NMaW1pdCwgc3RlcFNpemV9ID0gdGlja09wdHM7XG4gICAgbGV0IG1heFRpY2tzO1xuICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICAgIGlmIChtYXhUaWNrcyA+IDEwMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBzY2FsZXMuJHt0aGlzLmlkfS50aWNrcy5zdGVwU2l6ZTogJHtzdGVwU2l6ZX0gd291bGQgcmVzdWx0IGdlbmVyYXRpbmcgdXAgdG8gJHttYXhUaWNrc30gdGlja3MuIExpbWl0aW5nIHRvIDEwMDAuYCk7XG4gICAgICAgIG1heFRpY2tzID0gMTAwMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VGlja3MgPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKTtcbiAgICAgIG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuICAgIH1cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuICAgIHJldHVybiBtYXhUaWNrcztcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuICAgIGNvbnN0IG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuICAgICAgbWF4VGlja3MsXG4gICAgICBib3VuZHM6IG9wdHMuYm91bmRzLFxuICAgICAgbWluOiBvcHRzLm1pbixcbiAgICAgIG1heDogb3B0cy5tYXgsXG4gICAgICBwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcbiAgICAgIHN0ZXA6IHRpY2tPcHRzLnN0ZXBTaXplLFxuICAgICAgY291bnQ6IHRpY2tPcHRzLmNvdW50LFxuICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcbiAgICAgIGhvcml6b250YWw6IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICBtaW5Sb3RhdGlvbjogdGlja09wdHMubWluUm90YXRpb24gfHwgMCxcbiAgICAgIGluY2x1ZGVCb3VuZHM6IHRpY2tPcHRzLmluY2x1ZGVCb3VuZHMgIT09IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBkYXRhUmFuZ2UgPSB0aGlzLl9yYW5nZSB8fCB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyQxKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgbGV0IGVuZCA9IHRoaXMubWF4O1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcbiAgICAgIHN0YXJ0IC09IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBzdGFydDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IGVuZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG59XG5cbmNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBtYXggOiAxO1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICB9XG59XG5MaW5lYXJTY2FsZS5pZCA9ICdsaW5lYXInO1xuTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSkpKTtcbiAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCBlbmRFeHAgPSBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcbiAgY29uc3QgZW5kU2lnbmlmaWNhbmQgPSBNYXRoLmNlaWwoZGF0YVJhbmdlLm1heCAvIE1hdGgucG93KDEwLCBlbmRFeHApKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgbGV0IHRpY2tWYWwgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWluKSkpKTtcbiAgbGV0IGV4cCA9IE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpO1xuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gIGxldCBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcbiAgZG8ge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiB0aWNrVmFsLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICAgICsrc2lnbmlmaWNhbmQ7XG4gICAgaWYgKHNpZ25pZmljYW5kID09PSAxMCkge1xuICAgICAgc2lnbmlmaWNhbmQgPSAxO1xuICAgICAgKytleHA7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHRpY2tWYWwgPSBNYXRoLnJvdW5kKHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9IHdoaWxlIChleHAgPCBlbmRFeHAgfHwgKGV4cCA9PT0gZW5kRXhwICYmIHNpZ25pZmljYW5kIDwgZW5kU2lnbmlmaWNhbmQpKTtcbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICByZXR1cm4gdGlja3M7XG59XG5jbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBtaW4gPSB0aGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcbiAgICBjb25zdCBleHAgPSAodiwgbSkgPT4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodikpICsgbSk7XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWluKGV4cChtaW4sIC0xKSk7XG4gICAgICAgIHNldE1heChleHAobWF4LCArMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluIDw9IDApIHtcbiAgICAgIHNldE1pbihleHAobWF4LCAtMSkpO1xuICAgIH1cbiAgICBpZiAobWF4IDw9IDApIHtcbiAgICAgIHNldE1heChleHAobWluLCArMSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmIG1pbiA9PT0gZXhwKHRoaXMubWluLCAwKSkge1xuICAgICAgc2V0TWluKGV4cChtaW4sIC0xKSk7XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcbiAgICAgIG1heDogdGhpcy5fdXNlck1heFxuICAgIH07XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJzAnXG4gICAgICA6IGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IGxvZzEwKHN0YXJ0KTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gbG9nMTAodGhpcy5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSB0aGlzLm1pblxuICAgICAgPyAwXG4gICAgICA6IChsb2cxMCh2YWx1ZSkgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuTG9nYXJpdGhtaWNTY2FsZS5pZCA9ICdsb2dhcml0aG1pYyc7XG5Mb2dhcml0aG1pY1NjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiB0cnVlXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xuICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGlja09wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udCAmJiB0aWNrT3B0cy5mb250LnNpemUsIGRlZmF1bHRzLmZvbnQuc2l6ZSkgKyBwYWRkaW5nLmhlaWdodDtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcbiAgaWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcbiAgICAgIGVuZDogcG9zICsgKHNpemUgLyAyKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIHNpemUsXG4gICAgICBlbmQ6IHBvc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcG9zLFxuICAgIGVuZDogcG9zICsgc2l6ZVxuICB9O1xufVxuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IG9wdHMgPSBwb2ludExhYmVsT3B0cy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQsIHNjYWxlLl9wb2ludExhYmVsc1tpXSk7XG4gICAgbGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IF9ub3JtYWxpemVBbmdsZShzY2FsZS5nZXRJbmRleEFuZ2xlKGkpICsgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKGFuZ2xlUmFkaWFucykpO1xuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICBjb25zdCB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuICAgIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlUmFkaWFucywgaExpbWl0cywgdkxpbWl0cyk7XG4gIH1cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlLCBoTGltaXRzLCB2TGltaXRzKSB7XG4gIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSk7XG4gIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSk7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAoaExpbWl0cy5zdGFydCA8IG9yaWcubCkge1xuICAgIHggPSAob3JpZy5sIC0gaExpbWl0cy5zdGFydCkgLyBzaW47XG4gICAgbGltaXRzLmwgPSBNYXRoLm1pbihsaW1pdHMubCwgb3JpZy5sIC0geCk7XG4gIH0gZWxzZSBpZiAoaExpbWl0cy5lbmQgPiBvcmlnLnIpIHtcbiAgICB4ID0gKGhMaW1pdHMuZW5kIC0gb3JpZy5yKSAvIHNpbjtcbiAgICBsaW1pdHMuciA9IE1hdGgubWF4KGxpbWl0cy5yLCBvcmlnLnIgKyB4KTtcbiAgfVxuICBpZiAodkxpbWl0cy5zdGFydCA8IG9yaWcudCkge1xuICAgIHkgPSAob3JpZy50IC0gdkxpbWl0cy5zdGFydCkgLyBjb3M7XG4gICAgbGltaXRzLnQgPSBNYXRoLm1pbihsaW1pdHMudCwgb3JpZy50IC0geSk7XG4gIH0gZWxzZSBpZiAodkxpbWl0cy5lbmQgPiBvcmlnLmIpIHtcbiAgICB5ID0gKHZMaW1pdHMuZW5kIC0gb3JpZy5iKSAvIGNvcztcbiAgICBsaW1pdHMuYiA9IE1hdGgubWF4KGxpbWl0cy5iLCBvcmlnLmIgKyB5KTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBleHRyYSA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDI7XG4gIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5kcmF3aW5nQXJlYTtcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gb3B0cy5wb2ludExhYmVscy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoX25vcm1hbGl6ZUFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi5hbmdsZSArIEhBTEZfUEkpKSk7XG4gICAgY29uc3Qgc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG4gICAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gICAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICAgIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XG4gICAgaXRlbXMucHVzaCh7XG4gICAgICB4OiBwb2ludExhYmVsUG9zaXRpb24ueCxcbiAgICAgIHksXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICBsZWZ0LFxuICAgICAgdG9wOiB5LFxuICAgICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgICBib3R0b206IHkgKyBzaXplLmhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgIHJldHVybiAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cbiAgcmV0dXJuICdyaWdodCc7XG59XG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XG4gIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gdztcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3IC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiB5Rm9yQW5nbGUoeSwgaCwgYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgeSAtPSAoaCAvIDIpO1xuICB9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcbiAgICB5IC09IGg7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eCwgb3B0aW9uczoge3BvaW50TGFiZWxzfX0gPSBzY2FsZTtcbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ24sIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xuICAgIGNvbnN0IHtiYWNrZHJvcENvbG9yfSA9IG9wdHNBdEluZGV4O1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhvcHRzQXRJbmRleC5ib3JkZXJSYWRpdXMpO1xuICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG4gICAgICBjb25zdCBiYWNrZHJvcExlZnQgPSBsZWZ0IC0gcGFkZGluZy5sZWZ0O1xuICAgICAgY29uc3QgYmFja2Ryb3BUb3AgPSB0b3AgLSBwYWRkaW5nLnRvcDtcbiAgICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgICAgY29uc3QgYmFja2Ryb3BIZWlnaHQgPSBib3R0b20gLSB0b3AgKyBwYWRkaW5nLmhlaWdodDtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGJhY2tkcm9wTGVmdCxcbiAgICAgICAgICB5OiBiYWNrZHJvcFRvcCxcbiAgICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICAgIGg6IGJhY2tkcm9wSGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbmRlclRleHQoXG4gICAgICBjdHgsXG4gICAgICBzY2FsZS5fcG9pbnRMYWJlbHNbaV0sXG4gICAgICB4LFxuICAgICAgeSArIChwbEZvbnQubGluZUhlaWdodCAvIDIpLFxuICAgICAgcGxGb250LFxuICAgICAge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgY3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIFRBVSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgbGFiZWxDb3VudCkge1xuICBjb25zdCBjdHggPSBzY2FsZS5jdHg7XG4gIGNvbnN0IGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XG4gIGlmICgoIWNpcmN1bGFyICYmICFsYWJlbENvdW50KSB8fCAhY29sb3IgfHwgIWxpbmVXaWR0aCB8fCByYWRpdXMgPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICBjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2gpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBncmlkTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldDtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LnN0cm9rZSgpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgbGFiZWwsXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gIH0pO1xufVxuY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMueENlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcoZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykgLyAyKTtcbiAgICBjb25zdCB3ID0gdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGggLSBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQ7XG4gICAgdGhpcy54Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLmxlZnQgKyB3IC8gMiArIHBhZGRpbmcubGVmdCk7XG4gICAgdGhpcy55Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLnRvcCArIGggLyAyICsgcGFkZGluZy50b3ApO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSBNYXRoLmZsb29yKE1hdGgubWluKHcsIGgpIC8gMik7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgoZmFsc2UpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmdlbmVyYXRlVGlja0xhYmVscy5jYWxsKHRoaXMsIHRpY2tzKTtcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKClcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxiYWNrKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgW3ZhbHVlLCBpbmRleF0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKHYsIGkpID0+IHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkpO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9XG4gIHNldENlbnRlclBvaW50KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG4gICAgdGhpcy54Q2VudGVyICs9IE1hdGguZmxvb3IoKGxlZnRNb3ZlbWVudCAtIHJpZ2h0TW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy55Q2VudGVyICs9IE1hdGguZmxvb3IoKHRvcE1vdmVtZW50IC0gYm90dG9tTW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSAtPSBNYXRoLm1pbih0aGlzLmRyYXdpbmdBcmVhIC8gMiwgTWF0aC5tYXgobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpKTtcbiAgfVxuICBnZXRJbmRleEFuZ2xlKGluZGV4KSB7XG4gICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcbiAgICByZXR1cm4gX25vcm1hbGl6ZUFuZ2xlKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgdG9SYWRpYW5zKHN0YXJ0QW5nbGUpKTtcbiAgfVxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gIH1cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZERpc3RhbmNlID0gZGlzdGFuY2UgLyAodGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gdGhpcy5tYXggLSBzY2FsZWREaXN0YW5jZSA6IHRoaXMubWluICsgc2NhbGVkRGlzdGFuY2U7XG4gIH1cbiAgZ2V0UG9pbnRMYWJlbENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG4gIGdldFBvaW50UG9zaXRpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlciwgYWRkaXRpb25hbEFuZ2xlID0gMCkge1xuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIEhBTEZfUEkgKyBhZGRpdGlvbmFsQW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueENlbnRlcixcbiAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueUNlbnRlcixcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICB9XG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRQb2ludExhYmVsUG9zaXRpb24oaW5kZXgpIHtcbiAgICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICB9O1xuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtiYWNrZ3JvdW5kQ29sb3IsIGdyaWQ6IHtjaXJjdWxhcn19ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHBhdGhSYWRpdXNMaW5lKHRoaXMsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5fZW5kVmFsdWUpLCBjaXJjdWxhciwgdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0dyaWQoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7YW5nbGVMaW5lcywgZ3JpZH0gPSBvcHRzO1xuICAgIGNvbnN0IGxhYmVsQ291bnQgPSB0aGlzLl9wb2ludExhYmVscy5sZW5ndGg7XG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG4gICAgaWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZHJhd1BvaW50TGFiZWxzKHRoaXMsIGxhYmVsQ291bnQpO1xuICAgIH1cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGljay52YWx1ZSk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4IC0gMSkpO1xuICAgICAgICAgIGRyYXdSYWRpdXNMaW5lKHRoaXMsIG9wdHNBdEluZGV4LCBvZmZzZXQsIGxhYmVsQ291bnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlTGluZXMuZGlzcGxheSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGZvciAoaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gb3B0c0F0SW5kZXg7XG4gICAgICAgIGlmICghbGluZVdpZHRoIHx8ICFjb2xvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguc2V0TGluZURhc2gob3B0c0F0SW5kZXguYm9yZGVyRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gdGhpcy5taW4gOiB0aGlzLm1heCk7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGksIG9mZnNldCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgICAgIGN0eC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGRyYXdCb3JkZXIoKSB7fVxuICBkcmF3TGFiZWxzKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xuICAgIGxldCBvZmZzZXQsIHdpZHRoO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgY3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiAhb3B0cy5yZXZlcnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRpY2subGFiZWwpLndpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcjtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgLXdpZHRoIC8gMiAtIHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCxcbiAgICAgICAgICB3aWR0aCArIHBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgdGlja0ZvbnQuc2l6ZSArIHBhZGRpbmcuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7fVxufVxuUmFkaWFsTGluZWFyU2NhbGUuaWQgPSAncmFkaWFsTGluZWFyJztcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRzID0ge1xuICBkaXNwbGF5OiB0cnVlLFxuICBhbmltYXRlOiB0cnVlLFxuICBwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG4gIGFuZ2xlTGluZXM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjBcbiAgfSxcbiAgZ3JpZDoge1xuICAgIGNpcmN1bGFyOiBmYWxzZVxuICB9LFxuICBzdGFydEFuZ2xlOiAwLFxuICB0aWNrczoge1xuICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgfSxcbiAgcG9pbnRMYWJlbHM6IHtcbiAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgZm9udDoge1xuICAgICAgc2l6ZTogMTBcbiAgICB9LFxuICAgIGNhbGxiYWNrKGxhYmVsKSB7XG4gICAgICByZXR1cm4gbGFiZWw7XG4gICAgfSxcbiAgICBwYWRkaW5nOiA1LFxuICAgIGNlbnRlclBvaW50TGFiZWxzOiBmYWxzZVxuICB9XG59O1xuUmFkaWFsTGluZWFyU2NhbGUuZGVmYXVsdFJvdXRlcyA9IHtcbiAgJ2FuZ2xlTGluZXMuY29sb3InOiAnYm9yZGVyQ29sb3InLFxuICAncG9pbnRMYWJlbHMuY29sb3InOiAnY29sb3InLFxuICAndGlja3MuY29sb3InOiAnY29sb3InXG59O1xuUmFkaWFsTGluZWFyU2NhbGUuZGVzY3JpcHRvcnMgPSB7XG4gIGFuZ2xlTGluZXM6IHtcbiAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICB9XG59O1xuXG5jb25zdCBJTlRFUlZBTFMgPSB7XG4gIG1pbGxpc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxLCBzdGVwczogMTAwMH0sXG4gIHNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMTAwMCwgc3RlcHM6IDYwfSxcbiAgbWludXRlOiB7Y29tbW9uOiB0cnVlLCBzaXplOiA2MDAwMCwgc3RlcHM6IDYwfSxcbiAgaG91cjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMzYwMDAwMCwgc3RlcHM6IDI0fSxcbiAgZGF5OiB7Y29tbW9uOiB0cnVlLCBzaXplOiA4NjQwMDAwMCwgc3RlcHM6IDMwfSxcbiAgd2Vlazoge2NvbW1vbjogZmFsc2UsIHNpemU6IDYwNDgwMDAwMCwgc3RlcHM6IDR9LFxuICBtb250aDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMi42MjhlOSwgc3RlcHM6IDEyfSxcbiAgcXVhcnRlcjoge2NvbW1vbjogZmFsc2UsIHNpemU6IDcuODg0ZTksIHN0ZXBzOiA0fSxcbiAgeWVhcjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMy4xNTRlMTB9XG59O1xuY29uc3QgVU5JVFMgPSAoT2JqZWN0LmtleXMoSU5URVJWQUxTKSk7XG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCB7cGFyc2VyLCByb3VuZCwgaXNvV2Vla2RheX0gPSBzY2FsZS5fcGFyc2VPcHRzO1xuICBsZXQgdmFsdWUgPSBpbnB1dDtcbiAgaWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKCFpc051bWJlckZpbml0ZSh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBwYXJzZXIgPT09ICdzdHJpbmcnXG4gICAgICA/IGFkYXB0ZXIucGFyc2UodmFsdWUsIHBhcnNlcilcbiAgICAgIDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHJvdW5kKSB7XG4gICAgdmFsdWUgPSByb3VuZCA9PT0gJ3dlZWsnICYmIChpc051bWJlcihpc29XZWVrZGF5KSB8fCBpc29XZWVrZGF5ID09PSB0cnVlKVxuICAgICAgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSlcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XG4gIH1cbiAgcmV0dXJuICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG4gIGNvbnN0IGlsZW4gPSBVTklUUy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuICAgIGNvbnN0IGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcbiAgICBjb25zdCBmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBVTklUU1tpbGVuIC0gMV07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5sZW5ndGggLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xuICAgIGNvbnN0IHVuaXQgPSBVTklUU1tpXTtcbiAgICBpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSBudW1UaWNrcyAtIDEpIHtcbiAgICAgIHJldHVybiB1bml0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcykge1xuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICB0aWNrc1t0aW1lXSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICBjb25zdCB7bG8sIGhpfSA9IF9sb29rdXAodGltZXN0YW1wcywgdGltZSk7XG4gICAgY29uc3QgdGltZXN0YW1wID0gdGltZXN0YW1wc1tsb10gPj0gdGltZSA/IHRpbWVzdGFtcHNbbG9dIDogdGltZXN0YW1wc1toaV07XG4gICAgdGlja3NbdGltZXN0YW1wXSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCkge1xuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZih0aWNrc1swXS52YWx1ZSwgbWFqb3JVbml0KTtcbiAgY29uc3QgbGFzdCA9IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICBsZXQgbWFqb3IsIGluZGV4O1xuICBmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XG4gICAgaW5kZXggPSBtYXBbbWFqb3JdO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBtYXAgPSB7fTtcbiAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpLCB2YWx1ZTtcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgIG1hcFt2YWx1ZV0gPSBpO1xuICAgIHRpY2tzLnB1c2goe1xuICAgICAgdmFsdWUsXG4gICAgICBtYWpvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XG59XG5jbGFzcyBUaW1lU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgIHRoaXMuX21ham9yVW5pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vZmZzZXRzID0ge307XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0KHNjYWxlT3B0cywgb3B0cykge1xuICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXIgPSBuZXcgYWRhcHRlcnMuX2RhdGUoc2NhbGVPcHRzLmFkYXB0ZXJzLmRhdGUpO1xuICAgIGFkYXB0ZXIuaW5pdChvcHRzKTtcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB7XG4gICAgICBwYXJzZXI6IHRpbWUucGFyc2VyLFxuICAgICAgcm91bmQ6IHRpbWUucm91bmQsXG4gICAgICBpc29XZWVrZGF5OiB0aW1lLmlzb1dlZWtkYXlcbiAgICB9O1xuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRzKTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgc3VwZXIuYmVmb3JlTGF5b3V0KCk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgZnVuY3Rpb24gX2FwcGx5Qm91bmRzKGJvdW5kcykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGJvdW5kcy5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkICYmICFpc05hTihib3VuZHMubWF4KSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGJvdW5kcy5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1pbkRlZmluZWQgfHwgIW1heERlZmluZWQpIHtcbiAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuZ2V0TWluTWF4KGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpO1xuICAgIG1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDE7XG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgIHRoaXMubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcbiAgfVxuICBfZ2V0TGFiZWxCb3VuZHMoKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluLCBtYXh9O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcbiAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG4gICAgdGhpcy5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXG4gICAgICA/IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpXG4gICAgICA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gIXRpY2tPcHRzLm1ham9yLmVuYWJsZWQgfHwgdGhpcy5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXG4gICAgICA6IGRldGVybWluZU1ham9yVW5pdCh0aGlzLl91bml0KTtcbiAgICB0aGlzLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXApIHtcbiAgICAgIHRoaXMuaW5pdE9mZnNldHModGhpcy50aWNrcy5tYXAodGljayA9PiArdGljay52YWx1ZSkpO1xuICAgIH1cbiAgfVxuICBpbml0T2Zmc2V0cyh0aW1lc3RhbXBzKSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBsZXQgZmlyc3QsIGxhc3Q7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbmQgPSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gKGxhc3QgLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHtzdGFydCwgZW5kLCBmYWN0b3I6IDEgLyAoc3RhcnQgKyAxICsgZW5kKX07XG4gIH1cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgY29uc3Qgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdCh0aW1lT3B0cy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBmb3IgKHRpbWUgPSBmaXJzdCwgY291bnQgPSAwOyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vciksIGNvdW50KyspIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cbiAgICBpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnIHx8IGNvdW50ID09PSAxKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRpY2tzKS5zb3J0KChhLCBiKSA9PiBhIC0gYikubWFwKHggPT4gK3gpO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG4gICAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcbiAgfVxuICBfdGlja0Zvcm1hdEZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLl9hZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgfHwgKG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCkpO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG4gICAgcmV0dXJuIGZvcm1hdHRlciA/IGNhbGxiYWNrKGZvcm1hdHRlciwgW2xhYmVsLCBpbmRleCwgdGlja3NdLCB0aGlzKSA6IGxhYmVsO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24odGljay52YWx1ZSwgaSwgdGlja3MpO1xuICAgIH1cbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiAodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHBvcyAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuICBfZ2V0TGFiZWxTaXplKGxhYmVsKSB7XG4gICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tMYWJlbFdpZHRoID0gdGhpcy5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9SYWRpYW5zKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aWNrc09wdHMubWF4Um90YXRpb24gOiB0aWNrc09wdHMubWluUm90YXRpb24pO1xuICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHRpY2tGb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkuc2l6ZTtcbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG4gIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBjb25zdCBkaXNwbGF5Rm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IGZvcm1hdCA9IGRpc3BsYXlGb3JtYXRzW3RpbWVPcHRzLnVuaXRdIHx8IGRpc3BsYXlGb3JtYXRzLm1pbGxpc2Vjb25kO1xuICAgIGNvbnN0IGV4YW1wbGVMYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCBbZXhhbXBsZVRpbWVdLCB0aGlzLl9tYWpvclVuaXQpLCBmb3JtYXQpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRMYWJlbFNpemUoZXhhbXBsZUxhYmVsKTtcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gbWV0YXNbMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5jb25jYXQobWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cbiAgZ2V0TGFiZWxUaW1lc3RhbXBzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5sYWJlbHMgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKHBhcnNlKHRoaXMsIGxhYmVsc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG4gIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KHNvcnRlcikpO1xuICB9XG59XG5UaW1lU2NhbGUuaWQgPSAndGltZSc7XG5UaW1lU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGJvdW5kczogJ2RhdGEnLFxuICBhZGFwdGVyczoge30sXG4gIHRpbWU6IHtcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIHVuaXQ6IGZhbHNlLFxuICAgIHJvdW5kOiBmYWxzZSxcbiAgICBpc29XZWVrZGF5OiBmYWxzZSxcbiAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgIGRpc3BsYXlGb3JtYXRzOiB7fVxuICB9LFxuICB0aWNrczoge1xuICAgIHNvdXJjZTogJ2F1dG8nLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUodGFibGUsIHZhbCwgcmV2ZXJzZSkge1xuICBsZXQgbG8gPSAwO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgcHJldlNvdXJjZSwgbmV4dFNvdXJjZSwgcHJldlRhcmdldCwgbmV4dFRhcmdldDtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS5wb3MgJiYgdmFsIDw9IHRhYmxlW2hpXS5wb3MpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3BvcycsIHZhbCkpO1xuICAgIH1cbiAgICAoe3BvczogcHJldlNvdXJjZSwgdGltZTogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7cG9zOiBuZXh0U291cmNlLCB0aW1lOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10udGltZSAmJiB2YWwgPD0gdGFibGVbaGldLnRpbWUpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3RpbWUnLCB2YWwpKTtcbiAgICB9XG4gICAgKHt0aW1lOiBwcmV2U291cmNlLCBwb3M6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3RpbWU6IG5leHRTb3VyY2UsIHBvczogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9XG4gIGNvbnN0IHNwYW4gPSBuZXh0U291cmNlIC0gcHJldlNvdXJjZTtcbiAgcmV0dXJuIHNwYW4gPyBwcmV2VGFyZ2V0ICsgKG5leHRUYXJnZXQgLSBwcmV2VGFyZ2V0KSAqICh2YWwgLSBwcmV2U291cmNlKSAvIHNwYW4gOiBwcmV2VGFyZ2V0O1xufVxuY2xhc3MgVGltZVNlcmllc1NjYWxlIGV4dGVuZHMgVGltZVNjYWxlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5fdGFibGUgPSBbXTtcbiAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKTtcbiAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zO1xuICAgIHN1cGVyLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICB9XG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdGFibGUgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuICAgICAgaWYgKGN1cnIgPj0gbWluICYmIGN1cnIgPD0gbWF4KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVtcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7dGltZTogbWluLCBwb3M6IDB9LFxuICAgICAgICB7dGltZTogbWF4LCBwb3M6IDF9XG4gICAgICBdO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xuICAgICAgcHJldiA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgIGN1cnIgPSBpdGVtc1tpXTtcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuICAgICAgICB0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsIHx8IFtdO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAmJiBsYWJlbC5sZW5ndGgpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aGlzLm5vcm1hbGl6ZShkYXRhLmNvbmNhdChsYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lc3RhbXBzID0gZGF0YS5sZW5ndGggPyBkYXRhIDogbGFiZWw7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xuICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIHZhbHVlKSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIGRlY2ltYWwgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCB0cnVlKTtcbiAgfVxufVxuVGltZVNlcmllc1NjYWxlLmlkID0gJ3RpbWVzZXJpZXMnO1xuVGltZVNlcmllc1NjYWxlLmRlZmF1bHRzID0gVGltZVNjYWxlLmRlZmF1bHRzO1xuXG52YXIgc2NhbGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQ2F0ZWdvcnlTY2FsZTogQ2F0ZWdvcnlTY2FsZSxcbkxpbmVhclNjYWxlOiBMaW5lYXJTY2FsZSxcbkxvZ2FyaXRobWljU2NhbGU6IExvZ2FyaXRobWljU2NhbGUsXG5SYWRpYWxMaW5lYXJTY2FsZTogUmFkaWFsTGluZWFyU2NhbGUsXG5UaW1lU2NhbGU6IFRpbWVTY2FsZSxcblRpbWVTZXJpZXNTY2FsZTogVGltZVNlcmllc1NjYWxlXG59KTtcblxuY29uc3QgcmVnaXN0ZXJhYmxlcyA9IFtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG5dO1xuXG5leHBvcnQgeyBBbmltYXRpb24sIEFuaW1hdGlvbnMsIEFyY0VsZW1lbnQsIEJhckNvbnRyb2xsZXIsIEJhckVsZW1lbnQsIEJhc2VQbGF0Zm9ybSwgQmFzaWNQbGF0Zm9ybSwgQnViYmxlQ29udHJvbGxlciwgQ2F0ZWdvcnlTY2FsZSwgQ2hhcnQsIERhdGFzZXRDb250cm9sbGVyLCBwbHVnaW5fZGVjaW1hdGlvbiBhcyBEZWNpbWF0aW9uLCBEb21QbGF0Zm9ybSwgRG91Z2hudXRDb250cm9sbGVyLCBFbGVtZW50LCBpbmRleCBhcyBGaWxsZXIsIEludGVyYWN0aW9uLCBwbHVnaW5fbGVnZW5kIGFzIExlZ2VuZCwgTGluZUNvbnRyb2xsZXIsIExpbmVFbGVtZW50LCBMaW5lYXJTY2FsZSwgTG9nYXJpdGhtaWNTY2FsZSwgUGllQ29udHJvbGxlciwgUG9pbnRFbGVtZW50LCBQb2xhckFyZWFDb250cm9sbGVyLCBSYWRhckNvbnRyb2xsZXIsIFJhZGlhbExpbmVhclNjYWxlLCBTY2FsZSwgU2NhdHRlckNvbnRyb2xsZXIsIHBsdWdpbl9zdWJ0aXRsZSBhcyBTdWJUaXRsZSwgVGlja3MsIFRpbWVTY2FsZSwgVGltZVNlcmllc1NjYWxlLCBwbHVnaW5fdGl0bGUgYXMgVGl0bGUsIHBsdWdpbl90b29sdGlwIGFzIFRvb2x0aXAsIGFkYXB0ZXJzIGFzIF9hZGFwdGVycywgX2RldGVjdFBsYXRmb3JtLCBhbmltYXRvciwgY29udHJvbGxlcnMsIGVsZW1lbnRzLCBsYXlvdXRzLCBwbHVnaW5zLCByZWdpc3RlcmFibGVzLCByZWdpc3RyeSwgc2NhbGVzIH07XG4iLCAiaW1wb3J0IHtDaGFydCwgcmVnaXN0ZXJhYmxlc30gZnJvbSAnLi4vZGlzdC9jaGFydC5tanMnO1xuXG5DaGFydC5yZWdpc3RlciguLi5yZWdpc3RlcmFibGVzKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCAiaW1wb3J0IENoYXJ0IGZyb20gJ2NoYXJ0LmpzL2F1dG8nXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0YXRzT3ZlcnZpZXdDYXJkQ2hhcnQoeyBsYWJlbHMsIHZhbHVlcyB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnQ6IG51bGwsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0Q2hhcnQoKVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRDaGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KHRoaXMuJHJlZnMuY2FudmFzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZ2V0Q29tcHV0ZWRTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kcmVmcy5iYWNrZ3JvdW5kQ29sb3JFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGdldENvbXB1dGVkU3R5bGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuYm9yZGVyQ29sb3JFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9LFxuICAgIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFNQSxTQUFTLE9BQU87QUFBQztBQUNqQixJQUFNLE1BQU8sV0FBVztBQUN0QixNQUFJLEtBQUs7QUFDVCxTQUFPLFdBQVc7QUFDaEIsV0FBTztBQUFBLEVBQ1Q7QUFDRixFQUFFO0FBQ0YsU0FBUyxjQUFjLE9BQU87QUFDNUIsU0FBTyxVQUFVLFFBQVEsT0FBTyxVQUFVO0FBQzVDO0FBQ0EsU0FBUyxRQUFRLE9BQU87QUFDdEIsTUFBSSxNQUFNLFdBQVcsTUFBTSxRQUFRLEtBQUssR0FBRztBQUN6QyxXQUFPO0FBQUEsRUFDVDtBQUNBLFFBQU0sT0FBTyxPQUFPLFVBQVUsU0FBUyxLQUFLLEtBQUs7QUFDakQsTUFBSSxLQUFLLE1BQU0sR0FBRyxDQUFDLE1BQU0sYUFBYSxLQUFLLE1BQU0sRUFBRSxNQUFNLFVBQVU7QUFDakUsV0FBTztBQUFBLEVBQ1Q7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLFNBQVMsT0FBTztBQUN2QixTQUFPLFVBQVUsUUFBUSxPQUFPLFVBQVUsU0FBUyxLQUFLLEtBQUssTUFBTTtBQUNyRTtBQUNBLElBQU0saUJBQWlCLENBQUMsV0FBVyxP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QUNOLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFdBQVc7QUFBQSxFQUNYLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFlBQVk7QUFBQSxFQUNaLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLEtBQUs7QUFBQSxFQUNMLFVBQVU7QUFBQSxFQUNWLFlBQVk7QUFBQSxFQUNaLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFlBQVk7QUFBQSxFQUNaLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLGFBQWE7QUFBQSxFQUNiLElBQUk7QUFBQSxFQUNKLFVBQVU7QUFBQSxFQUNWLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLElBQUk7QUFBQSxFQUNKLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxF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bkI7QUFBQSxJQUVBLFdBQVcsV0FBWTtBQUNuQixhQUFRLEtBQUssUUFBUSxJQUFJLGFBQU0sS0FBSyxNQUFNLFFBQVE7QUFBQSxRQUM5QyxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsVUFDRjtBQUFBLFVBQ0EsVUFBVTtBQUFBLFlBQ047QUFBQSxjQUNJLE1BQU07QUFBQSxjQUNOLGlCQUFpQjtBQUFBLGdCQUNiLEtBQUssTUFBTTtBQUFBLGNBQ2YsRUFBRTtBQUFBLGNBQ0YsYUFBYTtBQUFBLGdCQUNULEtBQUssTUFBTTtBQUFBLGNBQ2YsRUFBRTtBQUFBLGNBQ0YsYUFBYTtBQUFBLGNBQ2IsTUFBTTtBQUFBLGNBQ04sU0FBUztBQUFBLFlBQ2I7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUFBLFFBQ0EsU0FBUztBQUFBLFVBQ0wsVUFBVTtBQUFBLFlBQ04sT0FBTztBQUFBLGNBQ0gsUUFBUTtBQUFBLFlBQ1o7QUFBQSxVQUNKO0FBQUEsVUFDQSxxQkFBcUI7QUFBQSxVQUNyQixTQUFTO0FBQUEsWUFDTCxRQUFRO0FBQUEsY0FDSixTQUFTO0FBQUEsWUFDYjtBQUFBLFVBQ0o7QUFBQSxVQUNBLFFBQVE7QUFBQSxZQUNKLEdBQUc7QUFBQSxjQUNDLFNBQVM7QUFBQSxZQUNiO0FBQUEsWUFDQSxHQUFHO0FBQUEsY0FDQyxTQUFTO0FBQUEsWUFDYjtBQUFBLFVBQ0o7QUFBQSxVQUNBLFVBQVU7QUFBQSxZQUNOLFNBQVM7QUFBQSxVQUNiO0FBQUEsUUFDSjtBQUFBLE1BQ0osQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQ0o7IiwKICAibmFtZXMiOiBbImluZGV4IiwgInNldCIsICJjYWxsYmFjayIsICJhcmdzIiwgImNvbG9yIiwgIl9kZXNjcmlwdG9ycyIsICJpbmRleCIsICJkZWZhdWx0cyIsICJyZXNvbHZlIiwgImRlc2NyaXB0b3JzIiwgInNldCIsICJnZXRDb21wdXRlZFN0eWxlIiwgImRyYXciLCAiZnJvbSIsICJ0byIsICJpbmRleCIsICJzY2FsZXMiLCAiZWxlbWVudHMiLCAibmFtZXMiLCAiaSIsICJ2YWxpZEluZGV4IiwgImNvbG9yIiwgInJlZ2lzdHJ5IiwgImluUmFuZ2UiLCAibGF5b3V0cyIsICJwb3NpdGlvbnMiLCAiZGVzY3JpcHRvcnMiLCAicGx1Z2lucyIsICJzZXQiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJsaXN0ZW5lciIsICJhbHBoYSIsICJza2lwIiwgImZpbGwiLCAibWFwIiwgImNhbGxiYWNrIiwgInJvdW5kIiwgImludGVycG9sYXRlIl0KfQo=
